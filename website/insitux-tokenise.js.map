{"version":3,"file":"insitux-tokenise.js","mappings":"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","sources":["webpack://insituxTokenise/webpack/bootstrap","webpack://insituxTokenise/webpack/runtime/define property getters","webpack://insituxTokenise/webpack/runtime/hasOwnProperty shorthand","webpack://insituxTokenise/webpack/runtime/make namespace object","webpack://insituxTokenise/./src/poly-fills.ts","webpack://insituxTokenise/./src/parse.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const toNum = (x: unknown): number => Number(x);\r\nexport const slice = <T>(arr: T[], start?: number, end?: number): T[] =>\r\n  arr.slice(start, end);\r\nexport const splice = <T>(arr: T[], start: number, numDel?: number): T[] =>\r\n  arr.splice(start, numDel);\r\nexport const len = (arr: unknown[]): number => arr.length;\r\nexport const slen = (str: string): number => str.length;\r\nexport const isNum = (x: unknown): x is number => !Number.isNaN(Number(x));\r\nexport const isArray = <T>(x: unknown): x is T[] => Array.isArray(x);\r\nexport const substr = (str: string, start: number, length?: number): string =>\r\n  str.substring(start, start + (length ?? str.length));\r\nexport const strIdx = (str: string, idx: number): string => str[idx];\r\nexport const sub = (x: string, s: string): boolean => x.includes(s);\r\nexport const subIdx = (x: string, s: string) => x.indexOf(s);\r\nexport const has = <T>(x: T[], y: T): boolean => x.includes(y);\r\nexport const starts = (str: string, x: string): boolean => str.startsWith(x);\r\nexport const ends = (str: string, x: string): boolean => str.endsWith(x);\r\nexport const flat = <T>(arr: T[][]): T[] => arr.flat(); //e.g. [[0], [1], []] => [0, 1]\r\nexport const concat = <T>(a: T[], b: T[]): T[] => a.concat(b);\r\nexport const push = <T>(arr: T[], add: T[]) => arr.push(...add);\r\nexport const sortBy = <T>(arr: T[], by: (a: T, b: T) => number) => arr.sort(by);\r\nexport const reverse = <T>(arr: T[]) => arr.reverse();\r\nexport const lowerCase = (str: string) => str.toLowerCase();\r\nexport const upperCase = (str: string) => str.toUpperCase();\r\nexport const trim = (str: string) => str.trim();\r\nexport const trimStart = (str: string) => str.trimStart();\r\nexport const trimEnd = (str: string) => str.trimEnd();\r\nexport const padEnd = (str: string, by: number) => str.padEnd(by);\r\nexport const randNum = (a: number, b: number) => a + Math.random() * (b - a);\r\nexport const randInt = (a: number, b: number) => Math.floor(randNum(a, b));\r\nexport const range = (len: number) => [...Array(len).keys()];\r\nexport const objKeys = (x: object) => Object.keys(x);\r\nexport const getTimeMs = () => new Date().getTime();\r\nexport const abs = Math.abs;\r\nexport const min = Math.min;\r\nexport const max = Math.max;\r\nexport const sin = Math.sin;\r\nexport const cos = Math.cos;\r\nexport const tan = Math.tan;\r\nexport const sqrt = Math.sqrt;\r\nexport const round = Math.round;\r\nexport const floor = Math.floor;\r\nexport const ceil = Math.ceil;\r\nexport const sign = Math.sign;\r\nexport const logn = Math.log;\r\nexport const log2 = Math.log2;\r\nexport const log10 = Math.log10;","import { arityCheck, keyOpErr, numOpErr, typeCheck } from \"./checks\";\r\nimport * as pf from \"./poly-fills\";\r\nconst { concat, has, flat, push, slice, splice } = pf;\r\nconst { slen, starts, sub, substr, strIdx } = pf;\r\nconst { isNum, len, toNum } = pf;\r\nimport { ErrCtx, Func, Funcs, Ins, ops, Val } from \"./types\";\r\nimport { assertUnreachable, InvokeError } from \"./types\";\r\n\r\ntype Token = {\r\n  typ: \"str\" | \"num\" | \"sym\" | \"rem\" | \"(\" | \")\";\r\n  text: string;\r\n  errCtx: ErrCtx;\r\n};\r\ntype NamedTokens = {\r\n  name: string;\r\n  tokens: Token[];\r\n  errCtx: ErrCtx;\r\n};\r\ntype ParserIns = Ins | { typ: \"err\"; value: string; errCtx: ErrCtx };\r\nconst nullVal: Val = { t: \"null\", v: undefined };\r\nconst falseVal = <Val>{ t: \"bool\", v: false };\r\n\r\nexport function tokenise(\r\n  code: string,\r\n  sourceId: string,\r\n  makeCollsOps = true,\r\n  emitComments = false,\r\n) {\r\n  const tokens: Token[] = [];\r\n  const digits = \"0123456789\";\r\n  let inString = false,\r\n    isEscaped = false,\r\n    inStringAt = [0, 0],\r\n    inSymbol = false,\r\n    inNumber = false,\r\n    inComment = false,\r\n    line = 1,\r\n    col = 0;\r\n  for (let i = 0, l = slen(code); i < l; ++i) {\r\n    const c = strIdx(code, i),\r\n      nextCh = i + 1 !== l ? strIdx(code, i + 1) : \"\";\r\n    ++col;\r\n    if (inComment) {\r\n      if (c === \"\\n\") {\r\n        inComment = false;\r\n        ++line;\r\n        col = 0;\r\n      } else if (emitComments) {\r\n        tokens[len(tokens) - 1].text += c;\r\n      }\r\n      continue;\r\n    }\r\n    if (isEscaped) {\r\n      isEscaped = false;\r\n      if (inString) {\r\n        tokens[len(tokens) - 1].text +=\r\n          { n: \"\\n\", t: \"\\t\", '\"': '\"' }[c] || `\\\\${c}`;\r\n      }\r\n      continue;\r\n    }\r\n    if (c === \"\\\\\") {\r\n      isEscaped = true;\r\n      continue;\r\n    }\r\n    if (c === '\"') {\r\n      if ((inString = !inString)) {\r\n        inStringAt = [line, col];\r\n        tokens.push({\r\n          typ: \"str\",\r\n          text: \"\",\r\n          errCtx: { sourceId: sourceId, line, col },\r\n        });\r\n      }\r\n      inNumber = inSymbol = false;\r\n      continue;\r\n    }\r\n    const isWhite = sub(\" \\t\\n\\r,\", c);\r\n    if (!inString && isWhite) {\r\n      inNumber = inSymbol = false;\r\n      if (c === \"\\n\") {\r\n        ++line;\r\n        col = 0;\r\n      }\r\n      continue;\r\n    }\r\n    if (!inString && c === \";\") {\r\n      inComment = true;\r\n      if (emitComments) {\r\n        tokens.push({\r\n          typ: \"rem\",\r\n          text: \"\",\r\n          errCtx: { sourceId: sourceId, line, col },\r\n        });\r\n      }\r\n      continue;\r\n    }\r\n    const errCtx: ErrCtx = { sourceId: sourceId, line, col };\r\n    const isDigit = (ch: string) => sub(digits, ch);\r\n    const isParen = sub(\"()[]{}\", c);\r\n    //Allow one . per number, or convert into symbol\r\n    if (inNumber && !isDigit(c)) {\r\n      inNumber = c === \".\" && !sub(tokens[len(tokens) - 1].text, \".\");\r\n      if (!inNumber && !isParen && !isWhite) {\r\n        inSymbol = true;\r\n        tokens[len(tokens) - 1].typ = \"sym\";\r\n      }\r\n    }\r\n    //Stop scanning symbol if a paren\r\n    if (inSymbol && isParen) {\r\n      inSymbol = false;\r\n    }\r\n    //If we just finished concatenating a token\r\n    if (!inString && !inSymbol && !inNumber) {\r\n      if (isParen) {\r\n        const parens: { [ch: string]: Token[\"typ\"] } = {\r\n          \"[\": \"(\",\r\n          \"{\": \"(\",\r\n          \"(\": \"(\",\r\n          \")\": \")\",\r\n          \"}\": \")\",\r\n          \"]\": \")\",\r\n        };\r\n        const text = parens[c]!;\r\n        tokens.push({ typ: text, text: makeCollsOps ? text : c, errCtx });\r\n        if (makeCollsOps) {\r\n          if (c === \"[\") {\r\n            tokens.push({ typ: \"sym\", text: \"vec\", errCtx });\r\n          } else if (c === \"{\") {\r\n            tokens.push({ typ: \"sym\", text: \"dict\", errCtx });\r\n          }\r\n        }\r\n        continue;\r\n      }\r\n      inNumber =\r\n        isDigit(c) ||\r\n        (c === \".\" && isDigit(nextCh)) ||\r\n        (c === \"-\" && (isDigit(nextCh) || nextCh === \".\"));\r\n      inSymbol = !inNumber;\r\n      const typ: Token[\"typ\"] = inSymbol ? \"sym\" : \"num\";\r\n      tokens.push({ typ, text: \"\", errCtx });\r\n    }\r\n    tokens[len(tokens) - 1].text += c;\r\n  }\r\n  return { tokens, stringError: inString ? inStringAt : undefined };\r\n}\r\n\r\nfunction segment(tokens: Token[]): Token[][] {\r\n  const segments: Token[][] = [[]];\r\n  let depth = 0;\r\n  tokens.forEach(token => {\r\n    segments[len(segments) - 1].push(token);\r\n    depth += toNum(token.typ === \"(\") - toNum(token.typ === \")\");\r\n    if (depth === 0) {\r\n      segments.push([]);\r\n    }\r\n  });\r\n  return segments;\r\n}\r\n\r\nfunction funcise(segments: Token[][]): NamedTokens[] {\r\n  const isFunc = (segment: Token[]) =>\r\n    len(segment) > 1 &&\r\n    segment[1].typ === \"sym\" &&\r\n    segment[1].text === \"function\";\r\n  const funcs = segments.filter(t => isFunc(t));\r\n  const entries = flat(segments.filter(t => !isFunc(t)));\r\n  const described = funcs.map(tokens => ({\r\n    name: tokens[2].text,\r\n    tokens: slice(tokens, 3),\r\n    errCtx: tokens[2].errCtx,\r\n  }));\r\n  return len(entries)\r\n    ? concat(described, [\r\n        {\r\n          name: \"entry\",\r\n          tokens: entries,\r\n          errCtx: entries[0].errCtx,\r\n        },\r\n      ])\r\n    : described;\r\n}\r\n\r\nfunction parseAll(tokens: Token[], params: string[]) {\r\n  const args: ParserIns[][] = [];\r\n  while (true) {\r\n    const arg = parseArg(tokens, params);\r\n    if (!len(arg)) {\r\n      break;\r\n    }\r\n    args.push(arg);\r\n  }\r\n  return args;\r\n}\r\n\r\nfunction parseForm(\r\n  tokens: Token[],\r\n  params: string[],\r\n  inPartial = true,\r\n): ParserIns[] {\r\n  const head = tokens.shift();\r\n  if (!head) {\r\n    return [];\r\n  }\r\n  const { typ, text, errCtx } = head;\r\n  let op = text;\r\n  const err = (value: string) => [<ParserIns>{ typ: \"err\", value, errCtx }];\r\n  if (op === \"catch\") {\r\n    if (tokens[0].typ !== \"(\") {\r\n      return err(\"argument 1 must be expression\");\r\n    }\r\n    const body = parseArg(tokens, params);\r\n    const when = flat(parseAll(tokens, params));\r\n    if (!len(body) || !len(when)) {\r\n      return err(\"must provide at least 2 arguments\");\r\n    }\r\n    return [...body, { typ: \"cat\", value: len(when), errCtx }, ...when];\r\n  } else if (op === \"var\" || op === \"let\") {\r\n    const ins: Ins[] = [];\r\n    while (true) {\r\n      const defIns = parseArg(tokens, params);\r\n      if (len(ins) && !len(defIns)) {\r\n        return ins;\r\n      }\r\n      const val = parseArg(tokens, params);\r\n      if (!len(ins) && (!len(defIns) || !len(val))) {\r\n        return err(`must provide at least one declaration name and value`);\r\n      } else if (!len(val)) {\r\n        return err(`must provide a value after each declaration name`);\r\n      }\r\n      const def = defIns[0];\r\n      if (def.typ !== \"ref\") {\r\n        return err(\"declaration name must be symbol\");\r\n      }\r\n      push(ins, val);\r\n      ins.push({ typ: op, value: def.value, errCtx });\r\n    }\r\n  } else if (op === \"var!\" || op === \"let!\") {\r\n    const ins: Ins[] = [];\r\n    //Rewrite e.g. (var! a + 1) -> (var a (+ a 1))\r\n    const defIns = parseArg(tokens, params);\r\n    if (!len(defIns)) {\r\n      return err(`must provide declaration name`);\r\n    }\r\n    const def = defIns[0];\r\n    if (def.typ !== \"ref\") {\r\n      return err(\"declaration name must be symbol\");\r\n    }\r\n    const func = parseArg(tokens, params);\r\n    if (!len(func)) {\r\n      return err(\"must provide an operation\");\r\n    }\r\n    const args = parseAll(tokens, params);\r\n    ins.push({ typ: \"ref\", value: def.value, errCtx });\r\n    push(ins, flat(args));\r\n    push(ins, func);\r\n    ins.push({ typ: \"exe\", value: len(args) + 1, errCtx });\r\n    ins.push({ typ: op === \"var!\" ? \"var\" : \"let\", value: def.value, errCtx });\r\n    return ins;\r\n  } else if (op === \"if\" || op === \"if!\" || op === \"when\") {\r\n    const cond = parseArg(tokens, params);\r\n    if (!len(cond)) {\r\n      return err(\"must provide condition\");\r\n    }\r\n    const ins: ParserIns[] = cond;\r\n    if (op === \"if!\") {\r\n      ins.push({ typ: \"val\", value: { t: \"func\", v: \"!\" }, errCtx });\r\n      ins.push({ typ: \"exe\", value: 1, errCtx });\r\n    }\r\n    if (op === \"if\" || op === \"if!\") {\r\n      const ifT = parseArg(tokens, params);\r\n      if (!len(ifT)) {\r\n        return err(\"must provide a branch\");\r\n      }\r\n      ins.push({ typ: \"if\", value: len(ifT) + 1, errCtx });\r\n      push(ins, ifT);\r\n      const ifF = parseArg(tokens, params);\r\n      if (len(ifF)) {\r\n        ins.push({ typ: \"jmp\", value: len(ifF), errCtx });\r\n        push(ins, ifF);\r\n        if (len(parseArg(tokens, params))) {\r\n          return err(\"too many branches\");\r\n        }\r\n      } else {\r\n        ins.push({ typ: \"jmp\", value: 1, errCtx });\r\n        ins.push({ typ: \"val\", value: nullVal, errCtx });\r\n      }\r\n    } else {\r\n      const body = flat(parseAll(tokens, params));\r\n      ins.push({ typ: \"if\", value: len(body) + 1, errCtx });\r\n      push(ins, body);\r\n      ins.push({ typ: \"jmp\", value: 1, errCtx });\r\n      ins.push({ typ: \"val\", value: nullVal, errCtx });\r\n    }\r\n    return ins;\r\n  } else if (op === \"and\" || op === \"or\" || op === \"while\") {\r\n    const args = parseAll(tokens, params);\r\n    let insCount = args.reduce((acc, a) => acc + len(a), 0);\r\n    if (len(args) < 2) {\r\n      return err(\"requires at least two arguments\");\r\n    }\r\n    const ins: Ins[] = [];\r\n    if (op === \"while\") {\r\n      ins.push({ typ: \"val\", value: nullVal, errCtx }); //If first is false\r\n      insCount += 2; //+1 for the if ins, +1 for the pop ins\r\n      const head = args.shift()!;\r\n      push(ins, head);\r\n      ins.push({ typ: \"if\", value: insCount - len(head), errCtx });\r\n      ins.push({ typ: \"pop\", value: len(args), errCtx });\r\n      args.forEach(as => push(ins, as));\r\n      ins.push({ typ: \"loo\", value: -(insCount + 1), errCtx });\r\n      return ins;\r\n    }\r\n    insCount += len(args); //+1 for each if/or ins\r\n    insCount += toNum(op === \"and\");\r\n    const typ = op === \"and\" ? \"if\" : \"or\";\r\n    for (let a = 0; a < len(args); ++a) {\r\n      push(ins, args[a]);\r\n      insCount -= len(args[a]);\r\n      ins.push({ typ, value: insCount, errCtx });\r\n      --insCount;\r\n    }\r\n    if (op === \"and\") {\r\n      push(ins, [\r\n        { typ: \"val\", value: <Val>{ t: \"bool\", v: true }, errCtx },\r\n        { typ: \"jmp\", value: 1, errCtx },\r\n        { typ: \"val\", value: falseVal, errCtx },\r\n      ]);\r\n    } else {\r\n      ins.push({ typ: \"val\", value: falseVal, errCtx });\r\n    }\r\n    return ins;\r\n  } else if (op === \"match\") {\r\n    const cond = parseArg(tokens, params);\r\n    if (!len(cond)) {\r\n      return err(\"must provide condition\");\r\n    }\r\n    const args = parseAll(tokens, params);\r\n    const otherwise: ParserIns[] = len(args) % 2 ? args.pop()! : [];\r\n    if (!len(args)) {\r\n      return err(\"must provide at least one case\");\r\n    }\r\n    let insCount =\r\n      args.reduce((acc, a) => acc + len(a) + 1, len(otherwise) ? -1 : 0) + 2;\r\n    const ins: ParserIns[] = cond;\r\n    while (len(args) > 1) {\r\n      const a = args.shift()!;\r\n      const when = args.shift()!;\r\n      push(ins, a);\r\n      ins.push({ typ: \"mat\", value: len(when) + 1, errCtx });\r\n      push(ins, when);\r\n      insCount -= len(a) + len(when) + 2;\r\n      ins.push({ typ: \"jmp\", value: insCount, errCtx });\r\n    }\r\n    if (len(otherwise)) {\r\n      push(ins, otherwise);\r\n    } else {\r\n      ins.push({ typ: \"pop\", value: 1, errCtx });\r\n      ins.push({ typ: \"val\", value: falseVal, errCtx });\r\n    }\r\n    return ins;\r\n  }\r\n  const headIns: Ins[] = [];\r\n  //Head is a expression or parameter\r\n  if (typ === \"(\" || has(params, text) || sub(\"%#@\", strIdx(text, 0))) {\r\n    tokens.unshift(head);\r\n    const ins = parseArg(tokens, params);\r\n    if (inPartial) {\r\n      headIns.push({ typ: \"exp\", value: len(ins), errCtx });\r\n    }\r\n    push(headIns, ins);\r\n  }\r\n  const parsedArgs = parseAll(tokens, params);\r\n  const [body, nArgs] = [flat(parsedArgs), len(parsedArgs)];\r\n  if (op === \"return\") {\r\n    return [...body, { typ: \"ret\", value: !!len(body), errCtx }];\r\n  }\r\n\r\n  //Operation arity check, optionally disabled for partial closures\r\n  if (ops[op] && !inPartial) {\r\n    const errors = arityCheck(op, nArgs, errCtx);\r\n    push(headIns, errors?.map(e => err(e.m)[0]) ?? []);\r\n    if (!errors) {\r\n      //Upgrade some math and logic functions to their fast counterparts\r\n      if (nArgs === 2 && ops[`fast${op}`]) {\r\n        op = `fast${op}`;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (len(headIns)) {\r\n    headIns.push({ typ: \"exe\", value: nArgs, errCtx });\r\n  } else {\r\n    const value: Val =\r\n      typ === \"num\"\r\n        ? { t: \"num\", v: toNum(op) }\r\n        : starts(op, \":\")\r\n        ? { t: \"key\", v: op }\r\n        : ops[op]\r\n        ? { t: \"func\", v: op }\r\n        : op === \"true\" || op === \"false\"\r\n        ? { t: \"bool\", v: op === \"true\" }\r\n        : { t: \"str\", v: op };\r\n    headIns.push({ typ: \"val\", value, errCtx });\r\n    headIns.push({ typ: \"exe\", value: nArgs, errCtx });\r\n  }\r\n  return [...body, ...headIns];\r\n}\r\n\r\nfunction parseArg(\r\n  tokens: Token[],\r\n  params: string[],\r\n  inPartial = false,\r\n): ParserIns[] {\r\n  if (!len(tokens)) {\r\n    return [];\r\n  }\r\n  const { typ, text, errCtx } = tokens.shift() as Token;\r\n  //Upon closure\r\n  if (\r\n    typ === \"sym\" &&\r\n    sub(\"#@\", text) &&\r\n    len(tokens) &&\r\n    tokens[0].typ === \"(\"\r\n  ) {\r\n    const texts = tokens.map(t => t.text);\r\n    const body = parseArg(tokens, params, text === \"@\");\r\n    const err = body.find(t => t.typ === \"err\");\r\n    if (err) {\r\n      return [err];\r\n    }\r\n    const value: [string, Ins[]] = [\r\n      slice(texts, 0, len(texts) - len(tokens)).join(\" \"),\r\n      <Ins[]>body,\r\n    ];\r\n    return [{ typ: text === \"#\" ? \"clo\" : \"par\", value, errCtx }];\r\n  }\r\n  switch (typ) {\r\n    case \"str\":\r\n      return [{ typ: \"val\", value: <Val>{ t: \"str\", v: text }, errCtx }];\r\n    case \"num\":\r\n      return [{ typ: \"val\", value: <Val>{ t: \"num\", v: toNum(text) }, errCtx }];\r\n    case \"sym\":\r\n      if (text === \"true\" || text === \"false\") {\r\n        return [\r\n          { typ: \"val\", value: <Val>{ t: \"bool\", v: text === \"true\" }, errCtx },\r\n        ];\r\n      } else if (text === \"null\") {\r\n        return [{ typ: \"val\", value: nullVal, errCtx }];\r\n      } else if (text === \"_\") {\r\n        return [{ typ: \"val\", value: { t: \"wild\", v: undefined }, errCtx }];\r\n      } else if (starts(text, \":\")) {\r\n        return [{ typ: \"val\", value: <Val>{ t: \"key\", v: text }, errCtx }];\r\n      } else if (starts(text, \"%\") && isNum(substr(text, 1))) {\r\n        const value = toNum(substr(text, 1));\r\n        if (value < 0) {\r\n          return [{ typ: \"val\", value: nullVal, errCtx }];\r\n        }\r\n        return [{ typ: \"upa\", value, errCtx }];\r\n      } else if (has(params, text)) {\r\n        return [{ typ: \"npa\", value: params.indexOf(text), errCtx }];\r\n      } else if (text === \"args\") {\r\n        return [{ typ: \"upa\", value: -1, errCtx }];\r\n      } else if (text === \"PI\" || text === \"E\") {\r\n        const v = text === \"PI\" ? 3.141592653589793 : 2.718281828459045;\r\n        return [{ typ: \"val\", value: { t: \"num\", v }, errCtx }];\r\n      } else if (ops[text]) {\r\n        return [{ typ: \"val\", value: <Val>{ t: \"func\", v: text }, errCtx }];\r\n      }\r\n      return [{ typ: \"ref\", value: text, errCtx }];\r\n    case \"(\":\r\n      return parseForm(tokens, params, inPartial);\r\n    case \")\":\r\n    case \"rem\":\r\n      return [];\r\n    default:\r\n      return assertUnreachable(typ);\r\n  }\r\n}\r\n\r\nfunction syntaxise(\r\n  { name, tokens }: NamedTokens,\r\n  errCtx: ErrCtx,\r\n): [\"func\", Func] | [\"err\", InvokeError] {\r\n  const err = (m: string, eCtx = errCtx) =>\r\n    <ReturnType<typeof syntaxise>>[\"err\", { e: \"Parse\", m, errCtx: eCtx }];\r\n  const firstNonParam = tokens.findIndex(\r\n    t => t.typ !== \"sym\" || sub(\"%#@\", t.text),\r\n  );\r\n  const params = slice(tokens, 0, firstNonParam);\r\n  const body = slice(tokens, firstNonParam);\r\n  //In the case of e.g. (function (+))\r\n  if (name === \"(\") {\r\n    return err(\"nameless function\");\r\n  }\r\n  //In the case of e.g. (function)\r\n  if (!len(params) && !len(body)) {\r\n    return err(\"empty function body\");\r\n  }\r\n  if (len(body) && body[0].typ === \")\") {\r\n    if (len(params)) {\r\n      //In the case of e.g. (function f %) or (function x y z)\r\n      body.unshift(params.pop()!);\r\n    } else {\r\n      //In the case of e.g. (function name)\r\n      return err(\"empty function body\");\r\n    }\r\n  }\r\n  //In the case of e.g. (function entry x y z)\r\n  if (len(params) && !len(body)) {\r\n    body.push(params.pop()!);\r\n  }\r\n  const ins: ParserIns[] = [];\r\n  while (len(body)) {\r\n    push(\r\n      ins,\r\n      parseArg(\r\n        body,\r\n        params.map(p => p.text),\r\n      ),\r\n    );\r\n  }\r\n  for (let i = 0, lim = len(ins); i < lim; i++) {\r\n    const x = ins[i];\r\n    if (x.typ === \"err\") {\r\n      return err(x.value, x.errCtx);\r\n    }\r\n  }\r\n  return [\"func\", { name, ins: <Ins[]>ins }];\r\n}\r\n\r\nfunction findParenImbalance(\r\n  tokens: Token[],\r\n  numL: number,\r\n  numR: number,\r\n): [number, number] {\r\n  //Scan for first instance of untimely closed\r\n  //  or last instance of unclosed open\r\n  const untimely = numR >= numL;\r\n  const [l, r] = [untimely ? \"(\" : \")\", untimely ? \")\" : \"(\"];\r\n  const direction = untimely ? 1 : -1;\r\n  for (\r\n    let lim = len(tokens), t = untimely ? 0 : lim - 1, depth = 0;\r\n    untimely ? t < lim : t >= 0;\r\n    t += direction\r\n  ) {\r\n    const {\r\n      typ,\r\n      errCtx: { line, col },\r\n    } = tokens[t];\r\n    depth += toNum(typ === l) - toNum(typ === r);\r\n    if (depth < 0) {\r\n      return [line, col];\r\n    }\r\n  }\r\n  return [0, 0];\r\n}\r\n\r\nfunction tokenErrorDetect(stringError: number[] | undefined, tokens: Token[]) {\r\n  const sourceId = len(tokens) ? tokens[0].errCtx.sourceId : \"\";\r\n  const errors: InvokeError[] = [];\r\n  const err = (m: string, errCtx: ErrCtx) =>\r\n    errors.push({ e: \"Parse\", m, errCtx });\r\n\r\n  //Check for paren imbalance\r\n  const countTyp = (t: Token[\"typ\"]) =>\r\n    len(tokens.filter(({ typ }) => typ === t));\r\n  const [numL, numR] = [countTyp(\"(\"), countTyp(\")\")];\r\n  {\r\n    const [line, col] = findParenImbalance(tokens, numL, numR);\r\n    if (line + col) {\r\n      err(\"unmatched parenthesis\", { sourceId: sourceId, line, col });\r\n    }\r\n  }\r\n\r\n  //Check for double-quote imbalance\r\n  if (stringError) {\r\n    const [line, col] = stringError;\r\n    err(\"unmatched double quotation marks\", { sourceId: sourceId, line, col });\r\n  }\r\n\r\n  //Check for any empty expressions\r\n  let emptyHead: Token | undefined;\r\n  for (let t = 0, lastWasL = false; t < len(tokens); ++t) {\r\n    if (lastWasL && tokens[t].typ === \")\") {\r\n      emptyHead = tokens[t];\r\n      break;\r\n    }\r\n    lastWasL = tokens[t].typ === \"(\";\r\n  }\r\n  if (emptyHead) {\r\n    err(\"empty expression forbidden\", emptyHead.errCtx);\r\n  }\r\n\r\n  return errors;\r\n}\r\n\r\nfunction insErrorDetect(fins: Ins[]): InvokeError[] | undefined {\r\n  type TypeInfo = {\r\n    types?: Val[\"t\"][];\r\n    val?: Val;\r\n  };\r\n  const stack: TypeInfo[] = [];\r\n  for (let i = 0, lim = len(fins); i < lim; ++i) {\r\n    const ins = fins[i];\r\n    switch (ins.typ) {\r\n      case \"val\":\r\n        stack.push({ types: [ins.value.t], val: ins.value });\r\n        break;\r\n      case \"exe\": {\r\n        const head = stack.pop()!;\r\n        const args = splice(stack, len(stack) - ins.value, ins.value);\r\n        const badMatch = (okTypes: Val[\"t\"][]) =>\r\n          args.findIndex(\r\n            ({ types }) => types && !okTypes.find(t => has(types, t)),\r\n          );\r\n        const headIs = (t: Val[\"t\"]) =>\r\n          head.val\r\n            ? head.val.t === t\r\n            : head.types && len(head.types) === 1 && head.types[0] === t;\r\n        if (head.val && head.val.t === \"func\") {\r\n          if (head.val.v === \"recur\") {\r\n            splice(stack, len(stack) - ins.value, ins.value);\r\n            break;\r\n          }\r\n          const errors = typeCheck(\r\n            head.val.v,\r\n            args.map(a => a.types ?? []),\r\n            ins.errCtx,\r\n            true,\r\n          );\r\n          if (errors) {\r\n            return errors;\r\n          }\r\n          const { returns, numeric: onlyNum } = ops[head.val.v];\r\n          stack.push(\r\n            onlyNum && onlyNum !== \"in only\"\r\n              ? { types: [\"num\"] }\r\n              : { types: returns },\r\n          );\r\n        } else if (headIs(\"num\")) {\r\n          const badArg = badMatch([\"str\", \"dict\", \"vec\"]);\r\n          if (badArg !== -1) {\r\n            return numOpErr(ins.errCtx, args[badArg].types!);\r\n          }\r\n          stack.push({});\r\n        } else if (headIs(\"key\")) {\r\n          const badArg = badMatch([\"dict\", \"vec\"]);\r\n          if (badArg !== -1) {\r\n            return keyOpErr(ins.errCtx, args[badArg].types!);\r\n          }\r\n          stack.push({});\r\n        } else if (headIs(\"str\") || headIs(\"bool\")) {\r\n          stack.push({});\r\n        } else if (!head.types && !head.val) {\r\n          stack.push({});\r\n        }\r\n        break;\r\n      }\r\n      case \"or\":\r\n        stack.pop();\r\n        stack.push({});\r\n        i += ins.value;\r\n        break;\r\n      case \"exp\":\r\n      case \"cat\":\r\n      case \"var\":\r\n      case \"let\":\r\n      case \"loo\":\r\n      case \"jmp\":\r\n        break;\r\n      case \"clo\":\r\n      case \"par\": {\r\n        const errors = insErrorDetect(ins.value[1]);\r\n        if (errors) {\r\n          return errors;\r\n        }\r\n      }\r\n      case \"ref\":\r\n      case \"npa\":\r\n      case \"upa\":\r\n        stack.push({});\r\n        break;\r\n      case \"if\": {\r\n        stack.pop();\r\n        stack.push({});\r\n        const ifIns = slice(fins, i + 1, ins.value + 1);\r\n        const errors = insErrorDetect(ifIns);\r\n        if (errors) {\r\n          return errors;\r\n        }\r\n        i += ins.value - 1;\r\n        break;\r\n      }\r\n      case \"mat\": {\r\n        stack.pop(); //first match\r\n        stack.pop(); //cond\r\n        i += ins.value;\r\n        i += fins[i].value as number; //The first jmp\r\n        stack.push({});\r\n        break;\r\n      }\r\n      case \"pop\":\r\n        splice(stack, len(stack) - ins.value, ins.value);\r\n        break;\r\n      case \"ret\":\r\n        if (ins.value) {\r\n          stack.pop();\r\n        }\r\n        break;\r\n      default:\r\n        assertUnreachable(ins);\r\n    }\r\n  }\r\n}\r\n\r\nexport function parse(\r\n  code: string,\r\n  sourceId: string,\r\n): { funcs: Funcs; errors: InvokeError[] } {\r\n  const { tokens, stringError } = tokenise(code, sourceId);\r\n  const tokenErrors = tokenErrorDetect(stringError, tokens);\r\n  if (len(tokenErrors)) {\r\n    return { errors: tokenErrors, funcs: {} };\r\n  }\r\n  const segments = segment(tokens);\r\n  const labelled = funcise(segments);\r\n  const funcsAndErrors = labelled.map(named =>\r\n    syntaxise(named, {\r\n      sourceId: sourceId,\r\n      line: named.errCtx.line,\r\n      col: named.errCtx.col,\r\n    }),\r\n  );\r\n  const okFuncs: Func[] = [],\r\n    errors: InvokeError[] = [];\r\n  funcsAndErrors.forEach(fae => {\r\n    if (fae[0] === \"err\") {\r\n      errors.push(fae[1]);\r\n    } else {\r\n      okFuncs.push(fae[1]);\r\n    }\r\n  });\r\n  push(errors, flat(okFuncs.map(f => insErrorDetect(f.ins) ?? [])));\r\n  const funcs: Funcs = {};\r\n  okFuncs.forEach(func => (funcs[func.name] = func));\r\n  return { errors, funcs };\r\n}\r\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","toNum","x","Number","slice","arr","start","end","splice","numDel","length","slen","str","isNum","isNaN","Array","isArray","substr","substring","strIdx","idx","sub","s","includes","subIdx","indexOf","y","starts","startsWith","ends","endsWith","flat","concat","a","b","push","add","sortBy","by","sort","reverse","lowerCase","toLowerCase","upperCase","toUpperCase","trim","trimStart","trimEnd","padEnd","randNum","Math","random","randInt","floor","range","keys","objKeys","getTimeMs","Date","getTime","abs","min","max","sin","cos","tan","sqrt","round","ceil","sign","logn","log","log2","log10","has","len","tokenise","code","sourceId","makeCollsOps","emitComments","tokens","inString","isEscaped","inStringAt","inSymbol","inNumber","inComment","line","col","i","l","c","nextCh","text","n","t","typ","errCtx","isWhite","isDigit","ch","isParen","stringError"],"sourceRoot":""}