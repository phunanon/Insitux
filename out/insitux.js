(()=>{"use strict";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.d(t,{invoker:()=>Qt});var r={};e.r(r),e.d(r,{abs:()=>S,ceil:()=>W,charCode:()=>I,codeChar:()=>P,concat:()=>h,cos:()=>F,ends:()=>y,flat:()=>x,floor:()=>V,getTimeMs:()=>N,has:()=>v,isArray:()=>c,isNum:()=>i,len:()=>o,log10:()=>G,log2:()=>U,logn:()=>z,lowerCase:()=>A,max:()=>T,min:()=>H,objKeys:()=>q,padEnd:()=>B,push:()=>b,randInt:()=>M,randNum:()=>j,range:()=>D,reverse:()=>C,round:()=>L,sign:()=>K,sin:()=>O,slen:()=>u,slice:()=>a,sortBy:()=>g,splice:()=>s,sqrt:()=>R,starts:()=>f,strIdx:()=>p,sub:()=>d,subIdx:()=>m,substr:()=>l,tan:()=>_,toNum:()=>n,trim:()=>w,trimEnd:()=>E,trimStart:()=>$,upperCase:()=>k});const n=e=>Number(e),a=(e,t,r)=>e.slice(t,r),s=(e,t,r)=>e.splice(t,r),o=e=>e.length,u=e=>e.length,i=e=>!Number.isNaN(Number(e)),c=e=>Array.isArray(e),l=(e,t,r)=>e.substring(t,t+(r??e.length)),p=(e,t)=>e[t],d=(e,t)=>e.includes(t),m=(e,t)=>e.indexOf(t),v=(e,t)=>e.includes(t),f=(e,t)=>e.startsWith(t),y=(e,t)=>e.endsWith(t),x=e=>e.flat(),h=(e,t)=>e.concat(t),b=(e,t)=>e.push(...t),g=(e,t)=>e.sort(t),C=e=>e.reverse(),A=e=>e.toLowerCase(),k=e=>e.toUpperCase(),w=e=>e.trim(),$=e=>e.trimStart(),E=e=>e.trimEnd(),B=(e,t)=>e.padEnd(t),I=e=>e.charCodeAt(0),P=e=>String.fromCharCode(e),j=(e,t)=>e+Math.random()*(t-e),M=(e,t)=>Math.floor(j(e,t)),D=e=>[...Array(e).keys()],q=e=>Object.keys(e),N=()=>(new Date).getTime(),S=Math.abs,H=Math.min,T=Math.max,O=Math.sin,F=Math.cos,_=Math.tan,R=Math.sqrt,L=Math.round,V=Math.floor,W=Math.ceil,K=Math.sign,z=Math.log,U=Math.log2,G=Math.log10,J={print:{returns:["null"]},"print-str":{returns:["null"]},"!":{exactArity:1,returns:["bool"]},"=":{minArity:2},"!=":{minArity:2},"+":{minArity:2,numeric:!0},"-":{minArity:1,numeric:!0},"*":{minArity:2,numeric:!0},"/":{minArity:2,numeric:!0},"//":{minArity:2,numeric:!0},"**":{minArity:1,maxArity:2,numeric:!0},"<":{minArity:2,numeric:!0},">":{minArity:2,numeric:!0},"<=":{minArity:2,numeric:!0},">=":{minArity:2,numeric:!0},"fast=":{exactArity:2},"fast!=":{exactArity:2},"fast+":{exactArity:2,numeric:!0},"fast-":{exactArity:2,numeric:!0},"fast*":{exactArity:2,numeric:!0},"fast/":{exactArity:2,numeric:!0},"fast//":{exactArity:2,numeric:!0},"fast<":{exactArity:2,numeric:!0},"fast>":{exactArity:2,numeric:!0},"fast<=":{exactArity:2,numeric:!0},"fast>=":{exactArity:2,numeric:!0},inc:{exactArity:1,numeric:!0},dec:{exactArity:1,numeric:!0},min:{minArity:2,numeric:!0},max:{minArity:2,numeric:!0},abs:{exactArity:1,numeric:!0},sqrt:{exactArity:1,numeric:!0},round:{minArity:1,maxArity:2,numeric:!0},floor:{exactArity:1,numeric:!0},ceil:{exactArity:1,numeric:!0},logn:{exactArity:1,numeric:!0},log2:{exactArity:1,numeric:!0},log10:{exactArity:1,numeric:!0},and:{minArity:1},or:{minArity:1},xor:{exactArity:2},"&":{exactArity:2,numeric:!0},"|":{exactArity:2,numeric:!0},"^":{exactArity:2,numeric:!0},"~":{exactArity:1,numeric:!0},"<<":{exactArity:2,numeric:!0},">>":{exactArity:2,numeric:!0},">>>":{exactArity:2,numeric:!0},"odd?":{exactArity:1,numeric:"in only",returns:["bool"]},"even?":{exactArity:1,numeric:"in only",returns:["bool"]},"pos?":{exactArity:1,numeric:"in only",returns:["bool"]},"neg?":{exactArity:1,numeric:"in only",returns:["bool"]},"zero?":{exactArity:1,numeric:"in only",returns:["bool"]},"null?":{exactArity:1,returns:["bool"]},"num?":{exactArity:1,returns:["bool"]},"bool?":{exactArity:1,returns:["bool"]},"str?":{exactArity:1,returns:["bool"]},"vec?":{exactArity:1,returns:["bool"]},"dict?":{exactArity:1,returns:["bool"]},"key?":{exactArity:1,returns:["bool"]},"func?":{exactArity:1,returns:["bool"]},"wild?":{exactArity:1,returns:["bool"]},rem:{minArity:2,numeric:!0},sin:{exactArity:1,numeric:!0},cos:{exactArity:1,numeric:!0},tan:{exactArity:1,numeric:!0},vec:{returns:["vec"]},dict:{returns:["dict"]},len:{exactArity:1,params:[["str","vec","dict"]],returns:["num"]},"to-num":{exactArity:1,params:[["str","num"]],returns:["num","null"]},"to-key":{exactArity:1,params:[["str","num"]],returns:["key"]},"has?":{exactArity:2,params:["str","str"],returns:["bool"]},idx:{minArity:2,maxArity:3,params:[["str","vec"]],returns:["num"]},map:{minArity:2,returns:["vec"]},for:{minArity:2,returns:["vec"]},reduce:{minArity:2,maxArity:3},filter:{minArity:2,params:[[],["vec","dict","str"]],returns:["vec"]},remove:{minArity:2,params:[[],["vec","dict","str"]],returns:["vec"]},find:{minArity:2,params:[[],["vec","dict","str"]]},count:{minArity:2,params:[[],["vec","dict","str"]],returns:["num"]},repeat:{minArity:2,params:[[],"num"]},"->":{minArity:2},str:{returns:["str"]},rand:{maxArity:2,numeric:!0,returns:["num"]},"rand-int":{maxArity:2,numeric:!0,returns:["num"]},".":{minArity:1},"..":{minArity:2},"...":{minArity:2},into:{exactArity:2,params:[["vec","dict"],["vec","dict"]],returns:["vec","dict"]},push:{minArity:2,maxArity:3,params:[["vec","dict"]],returns:["vec","dict"]},sect:{minArity:1,maxArity:3,params:[["vec","str"],"num","num"],returns:["vec","str"]},reverse:{exactArity:1,params:[["vec","str"]],returns:["vec","str"]},sort:{minArity:1,maxArity:2,params:[["vec","dict","str"]],returns:["vec"]},keys:{exactArity:1,params:["dict"]},vals:{exactArity:1,params:["dict"]},do:{minArity:1},val:{minArity:1},range:{minArity:1,maxArity:3,numeric:"in only",returns:["vec"]},"empty?":{exactArity:1,params:[["str","vec","dict"]],returns:["bool"]},split:{minArity:1,maxArity:2,params:["str","str"],returns:["vec"]},join:{exactArity:2,params:["str",["vec","dict","str"]],returns:["str"]},"starts-with?":{exactArity:2,params:["str","str"],returns:["bool"]},"ends-with?":{exactArity:2,params:["str","str"],returns:["bool"]},"lower-case":{exactArity:1,params:["str"],returns:["str"]},"upper-case":{exactArity:1,params:["str"],returns:["str"]},trim:{exactArity:1,params:["str"],returns:["str"]},"trim-start":{exactArity:1,params:["str"],returns:["str"]},"trim-end":{exactArity:1,params:["str"],returns:["str"]},"str*":{exactArity:2,params:["str","num"],returns:["str"]},"char-code":{minArity:1,maxArity:2,params:[["str","num"],"num"],returns:["str","num","null"]},time:{exactArity:0,returns:["num"]},version:{exactArity:0,returns:["num"]},tests:{minArity:0,maxArity:1,params:["bool"],returns:["str"]},symbols:{exactArity:0,returns:["vec"]},eval:{exactArity:1,params:["str"]},reset:{exactArity:0},recur:{}},Q={null:"null",str:"string",num:"number",bool:"boolean",key:"keyword",ref:"reference",vec:"vector",dict:"dictionary",func:"function",clo:"closure",wild:"wildcard"},X=e=>"bool"===e.t?e.v:"null"!==e.t;function Y(e,t,r){const{exactArity:n,maxArity:a,minArity:s}=J[e],o=(n,a)=>[{e:"Arity",m:`${e} needs ${n} argument${1!==a?"s":""}, not ${t}`,errCtx:r}];if(void 0!==n){if(t!==n)return o(`exactly ${n}`,n)}else{if(s&&!a&&t<s)return o(`at least ${s}`,s);if(!s&&a&&t>a)return o(`at most ${a}`,a);if(s&&a&&(t<s||t>a))return o(`between ${s} and ${a}`,a)}}function Z(e,t,r,n=!1){const{params:a,numeric:s}=J[e],u=o(t);if(s){const a=t.findIndex((e=>!!o(e)&&(n?!e.find((e=>"num"===e)):"num"!==e[0])));if(-1===a)return;const s=t[a].map((e=>Q[e])).join(", ");return[ee(`${e} takes numeric arguments only, not ${s}`,r)]}if(!a)return;const i=a.map(((e,r)=>{if(r>=u||!t[r])return!1;const a=t[r];if(c(e)){if(!o(e)||(n?!o(a)||a.some((t=>v(e,t))):1===o(a)&&v(e,a[0])))return!1;const t=a.map((e=>Q[e]));return`argument ${r+1} must be either: ${e.map((e=>Q[e])).join(", ")}, not ${t}`}{if(n?!o(a)||v(a,e):1===o(a)&&e===a[0])return!1;const t=a.map((e=>Q[e]));return`argument ${r+1} must be ${Q[e]}, not ${t}`}})).filter((e=>!!e));return o(i)?i.map((e=>ee(e,r))):void 0}const ee=(e,t)=>({e:"Type",m:e,errCtx:t});function te(e,t){const r=t.map((e=>Q[e])).join(", ");return[ee(`number as operation argument must be string, vector, or dictionary, not ${r}`,e)]}function re(e,t){const r=t.map((e=>Q[e])).join(", ");return[ee(`keyword as operation argument must be dictionary or vector, not ${r}`,e)]}const{concat:ne,has:ae,flat:se,push:oe,slice:ue,splice:ie}=r,{slen:ce,starts:le,sub:pe,substr:de,strIdx:me}=r,{isNum:ve,len:fe,toNum:ye}=r,xe={t:"null",v:void 0},he={t:"bool",v:!1},be=({typ:e})=>ye("("===e)-ye(")"===e);function ge(e,t){const r=[];for(;;){const n=Ce(e,t);if(!fe(n))break;r.push(n)}return r}function Ce(e,t,r=!1){if(!fe(e))return[];const{typ:n,text:a,errCtx:s}=e.shift(),o="sym"===n&&pe("#@",a)&&fe(e)&&"("===e[0].typ,u="("===n&&fe(e)&&"fn"===e[0].text;if(o||u){const r=e.map((e=>e.text)),n=u?e.shift():void 0,o=[];if(u){const r=Ae(e);if(t=r.params,oe(o,r.errors),")"===e[0].typ)return[{typ:"err",value:"fn requires a body",errCtx:n.errCtx}];e.unshift({typ:"sym",text:"do",errCtx:s}),e.unshift({typ:"(",text:"(",errCtx:s})}oe(o,Ce(e,t,"@"===a));const i=o.filter((e=>"err"===e.typ));if(fe(i))return i;u&&o.forEach((e=>{"npa"===e.typ&&(e.typ="upa")}));const c=[(u?"(":a)+ue(r,0,fe(r)-fe(e)).join(" "),o];return[{typ:"@"===a?"par":"clo",value:c,errCtx:s}]}switch(n){case"str":return[{typ:"val",value:{t:"str",v:a},errCtx:s}];case"num":return[{typ:"val",value:{t:"num",v:ye(a)},errCtx:s}];case"sym":if("true"===a||"false"===a)return[{typ:"val",value:{t:"bool",v:"true"===a},errCtx:s}];if("null"===a)return[{typ:"val",value:xe,errCtx:s}];if("_"===a)return[{typ:"val",value:{t:"wild",v:void 0},errCtx:s}];if(le(a,":"))return[{typ:"val",value:{t:"key",v:a},errCtx:s}];if(le(a,"%")&&ve(de(a,1))){const e=ye(de(a,1));return e<0?[{typ:"val",value:xe,errCtx:s}]:[{typ:"upa",value:e,errCtx:s}]}if(ae(t.map((({name:e})=>e)),a)){const e=t.find((({name:e})=>e===a));return 1===fe(e.position)?[{typ:"npa",value:e.position[0],errCtx:s}]:[{typ:"dpa",value:e.position,errCtx:s}]}return"args"===a?[{typ:"upa",value:-1,errCtx:s}]:"PI"===a||"E"===a?[{typ:"val",value:{t:"num",v:"PI"===a?3.141592653589793:2.718281828459045},errCtx:s}]:J[a]?[{typ:"val",value:{t:"func",v:a},errCtx:s}]:[{typ:"ref",value:a,errCtx:s}];case"(":return function(e,t,r=!0){const n=e.shift();if(!n)return[];const{typ:a,text:s,errCtx:o}=n;let u=s;const i=(e,t=o)=>[{typ:"err",value:e,errCtx:t}];if("catch"===u){if("("!==e[0].typ)return i("argument 1 must be expression");const r=Ce(e,t),n=se(ge(e,t));return fe(r)&&fe(n)?[...r,{typ:"cat",value:fe(n),errCtx:o},...n]:i("must provide at least 2 arguments")}if("var"===u||"let"===u){const r=[];for(;;){const n=Ae(e,!0);if(fe(n.errors))return n.errors;let a;if(fe(n.params)&&(a={typ:"var"===u?"dva":"dle",value:n.params,errCtx:o}),a||([a]=Ce(e,t)),fe(r)&&!a)return r;const s=Ce(e,t);if(!(fe(r)||a&&fe(s)))return i("must provide at least one declaration name and value");if(!fe(s))return i("must provide a value after each declaration name");if("ref"!==a.typ&&"dva"!==a.typ&&"dle"!==a.typ)return[{typ:"err",value:`${u} declaration name must be a symbol`,errCtx:a.errCtx}];oe(r,s),"ref"===a.typ?r.push({typ:u,value:a.value,errCtx:o}):"dva"!==a.typ&&"dle"!==a.typ||r.push({typ:a.typ,value:a.value,errCtx:o})}}else{if("var!"===u||"let!"===u){const r=[],n=Ce(e,t);if(!fe(n))return i("must provide declaration name");const a=n[0];if("ref"!==a.typ)return i("declaration name must be symbol");const s=Ce(e,t);if(!fe(s))return i("must provide an operation");const c=ge(e,t);return r.push({typ:"ref",value:a.value,errCtx:o}),oe(r,se(c)),oe(r,s),r.push({typ:"exe",value:fe(c)+1,errCtx:o}),r.push({typ:"var!"===u?"var":"let",value:a.value,errCtx:o}),r}if("if"===u||"if!"===u||"when"===u){const r=Ce(e,t);if(!fe(r))return i("must provide condition");const n=r;if("if!"===u&&(n.push({typ:"val",value:{t:"func",v:"!"},errCtx:o}),n.push({typ:"exe",value:1,errCtx:o})),"if"===u||"if!"===u){const r=Ce(e,t);if(!fe(r))return i("must provide a branch");n.push({typ:"if",value:fe(r)+1,errCtx:o}),oe(n,r);const a=Ce(e,t);if(fe(a)){n.push({typ:"jmp",value:fe(a),errCtx:o}),oe(n,a);const r=Ce(e,t);if(fe(r))return i("too many branches; delete this branch",r[0].errCtx)}else n.push({typ:"jmp",value:1,errCtx:o}),n.push({typ:"val",value:xe,errCtx:o})}else{const r=se(ge(e,t));n.push({typ:"if",value:fe(r)+1,errCtx:o}),oe(n,r),n.push({typ:"jmp",value:1,errCtx:o}),n.push({typ:"val",value:xe,errCtx:o})}return n}if("and"===u||"or"===u||"while"===u){const r=ge(e,t);let n=r.reduce(((e,t)=>e+fe(t)),0);if(fe(r)<2)return i("requires at least two arguments");const a=[];if("while"===u){a.push({typ:"val",value:xe,errCtx:o}),n+=2;const e=r.shift();return oe(a,e),a.push({typ:"if",value:n-fe(e),errCtx:o}),a.push({typ:"pop",value:fe(r),errCtx:o}),r.forEach((e=>oe(a,e))),a.push({typ:"loo",value:-(n+1),errCtx:o}),a}n+=fe(r),n+=ye("and"===u);const s="and"===u?"if":"or";for(let e=0;e<fe(r);++e)oe(a,r[e]),n-=fe(r[e]),a.push({typ:s,value:n,errCtx:o}),--n;return"and"===u?oe(a,[{typ:"val",value:{t:"bool",v:!0},errCtx:o},{typ:"jmp",value:1,errCtx:o},{typ:"val",value:he,errCtx:o}]):a.push({typ:"val",value:he,errCtx:o}),a}if("match"===u){const r=Ce(e,t);if(!fe(r))return i("must provide condition");const n=ge(e,t),a=fe(n)%2?n.pop():[];if(!fe(n))return i("must provide at least one case");let s=n.reduce(((e,t)=>e+fe(t)+1),fe(a)?fe(a)-2:0)+2;const u=r;for(;fe(n)>1;){const e=n.shift(),t=n.shift();oe(u,e),u.push({typ:"mat",value:fe(t)+1,errCtx:o}),oe(u,t),s-=fe(e)+fe(t)+2,u.push({typ:"jmp",value:s,errCtx:o})}return fe(a)?oe(u,a):(u.push({typ:"pop",value:1,errCtx:o}),u.push({typ:"val",value:he,errCtx:o})),u}}const c=[];if("("===a||ae(t.map((({name:e})=>e)),s)||pe("%#@",me(s,0))){e.unshift(n);const a=Ce(e,t);r&&c.push({typ:"exp",value:fe(a),errCtx:o}),oe(c,a)}const l=ge(e,t),[p,d]=[se(l),fe(l)];if("return"===u)return[...p,{typ:"ret",value:!!fe(p),errCtx:o}];if(J[u]&&!r){const e=Y(u,d,o);oe(c,e?.map((e=>i(e.m)[0]))??[]),e||2===d&&J[`fast${u}`]&&(u=`fast${u}`)}if(fe(c))c.push({typ:"exe",value:d,errCtx:o});else{const e="num"===a?{t:"num",v:ye(u)}:le(u,":")?{t:"key",v:u}:J[u]?{t:"func",v:u}:"true"===u||"false"===u?{t:"bool",v:"true"===u}:{t:"str",v:u};c.push({typ:"val",value:e,errCtx:o}),c.push({typ:"exe",value:d,errCtx:o})}return[...p,...c]}(e,t,r);case")":case"rem":return[];default:return 0}}function Ae(e,t=!1){if(!fe(e)||")"===e[0].typ)return{params:[],errors:[]};let r=0;const n=[];let a=[],s=0;for(;fe(e)&&(r||(n.push([]),a=n[fe(n)-1]),r+=be(e[0]),!(r<0));){if(a.push(e.shift()),"sym"===a[0].typ&&pe("#@%",a[0].text)){e.unshift(a[0]),n.pop(),s=1;break}if(fe(a)>1&&("sym"!==a[1].typ||"vec"!==a[1].text)){s=2;break}if(t&&!r){if(1===fe(a))return e.unshift(a[0]),{params:[],errors:[]};break}}if(2===s&&r>0)e.unshift(a[1]),e.unshift(a[0]),n.pop();else if(r<0)n.pop(),n.pop().reverse().forEach((t=>e.unshift(t)));else if(!s&&!t){const t=n.pop();1===fe(t)&&")"===t[0].typ&&oe(e,n.pop()),oe(e,t)}const o=[],u=[],i=[0];return n.forEach((e=>{e.forEach((({typ:e,text:t,errCtx:r})=>{if("sym"===e){if("vec"===t)return;return o.push({name:t,position:ue(i)}),void++i[fe(i)-1]}"("===e?i.push(0):")"===e?(i.pop(),++i[fe(i)-1]):u.push({typ:"err",value:"disallowed in destructuring",errCtx:r})}))})),{params:o,errors:u}}function ke(e){const t=[];for(let r=0,n=fe(e);r<n;++r){const n=e[r];switch(n.typ){case"val":t.push({types:[n.value.t],val:n.value});break;case"exe":{const e=t.pop(),r=ie(t,fe(t)-n.value,n.value),a=e=>r.findIndex((({types:t})=>t&&!e.find((e=>ae(t,e))))),s=t=>e.val?e.val.t===t:e.types&&1===fe(e.types)&&e.types[0]===t;if(e.val&&"func"===e.val.t){if("recur"===e.val.v){ie(t,fe(t)-n.value,n.value);break}const a=Z(e.val.v,r.map((e=>e.types??[])),n.errCtx,!0);if(a)return a;const{returns:s,numeric:o}=J[e.val.v];t.push(o&&"in only"!==o?{types:["num"]}:{types:s})}else if(s("num")){const e=a(["str","dict","vec"]);if(-1!==e)return te(n.errCtx,r[e].types);t.push({})}else if(s("key")){const e=a(["dict","vec"]);if(-1!==e)return re(n.errCtx,r[e].types);t.push({})}else s("str")||s("bool")?t.push({}):e.types||e.val||t.push({});break}case"or":t.pop(),t.push({}),r+=n.value;break;case"exp":case"cat":case"var":case"let":case"dva":case"dle":case"loo":case"jmp":break;case"clo":case"par":{const e=ke(n.value[1]);if(e)return e}case"ref":case"npa":case"upa":case"dpa":t.push({});break;case"if":{t.pop(),t.push({});const a=ke(ue(e,r+1,n.value+1));if(a)return a;r+=n.value-1;break}case"mat":t.pop(),t.pop(),r+=n.value,r+=e[r].value,t.push({});break;case"pop":ie(t,fe(t)-n.value,n.value);break;case"ret":n.value&&t.pop()}}}function we(e,t){const{tokens:r,stringError:n}=function(e,t,r=!0,n=!1){const a=[];let s=!1,o=!1,u=[0,0],i=!1,c=!1,l=!1,p=!1,d=1,m=0;for(let v=0,f=ce(e);v<f;++v){const y=me(e,v),x=v+1!==f?me(e,v+1):"";if(++m,p){"\n"===y?(p=!1,++d,m=0):n&&(a[fe(a)-1].text+=y);continue}if(o){o=!1,s&&(a[fe(a)-1].text+={n:"\n",t:"\t",r:"\r",'"':'"'}[y]||`\\${y}`);continue}if("\\"===y){o=!0;continue}if('"'===y){(s=!s)&&(u=[d,m],a.push({typ:"str",text:"",errCtx:{sourceId:t,line:d,col:m}})),c=i=!1;continue}const h=pe(" \t\n\r,",y);if(!s&&h){c=i=!1,"\n"===y&&(++d,m=0);continue}if(!s&&";"===y){p=!0,n&&a.push({typ:"rem",text:"",errCtx:{sourceId:t,line:d,col:m}});continue}const b={sourceId:t,line:d,col:m},g=e=>pe("0123456789",e),C=pe("()[]{}",y);if(c&&!g(y)){const e="x"===y&&"0"===a[fe(a)-1].text;l=l||e,c="b"===y&&"0"===a[fe(a)-1].text||"."===y&&!pe(a[fe(a)-1].text,".")||l&&(e||pe("ABCDEFabcdef",y)),c||C||h||(i=!0,a[fe(a)-1].typ="sym")}if(i&&C&&(i=!1),!s&&!i&&!c){if(C){const e={"[":"(","{":"(","(":"(",")":")","}":")","]":")"}[y];a.push({typ:e,text:r?e:y,errCtx:b}),r&&("["===y?a.push({typ:"sym",text:"vec",errCtx:b}):"{"===y&&a.push({typ:"sym",text:"dict",errCtx:b}));continue}c=g(y)||"."===y&&g(x)||"-"===y&&(g(x)||"."===x),l=!1,i=!c;const e=i?"sym":"num";a.push({typ:e,text:"",errCtx:b})}a[fe(a)-1].text+=y}return{tokens:a,stringError:s?u:void 0}}(e,t),a=function(e,t){const r=fe(t)?t[0].errCtx.sourceId:"",n=[],a=(e,t)=>n.push({e:"Parse",m:e,errCtx:t});if(e){const[t,s]=e;return a("unmatched double quotation marks",{sourceId:r,line:t,col:s}),n}const s=e=>fe(t.filter((({typ:t})=>t===e))),[o,u]=[s("("),s(")")];{const[e,n]=function(e,t,r){const n=r>=t,[a,s]=[n?"(":")",n?")":"("],o=n?1:-1;for(let t=fe(e),r=n?0:t-1,u=0;n?r<t:r>=0;r+=o){const{typ:t,errCtx:{line:n,col:o}}=e[r];if(u+=ye(t===a)-ye(t===s),u<0)return[n,o]}return[0,0]}(t,o,u);e+n&&a("unmatched parenthesis",{sourceId:r,line:e,col:n})}let i;for(let e=0,r=!1;e<fe(t);++e){if(r&&")"===t[e].typ){i=t[e];break}r="("===t[e].typ}return i&&a("empty expression forbidden",i.errCtx),n}(n,r);if(fe(a))return{errors:a,funcs:{}};const s=function(e){const t=e=>fe(e)>1&&"sym"===e[1].typ&&"function"===e[1].text,r=e.filter((e=>t(e))),n=se(e.filter((e=>!t(e)))),a=r.map((e=>({name:e[2].text,tokens:ue(e,3),errCtx:e[2].errCtx})));return fe(n)?ne(a,[{name:"entry",tokens:n,errCtx:n[0].errCtx}]):a}(function(e){const t=[[]];let r=0;return e.forEach((e=>{t[fe(t)-1].push(e),r+=be(e),0===r&&t.push([])})),t}(r)).map((e=>function({name:e,tokens:t},r){const n=(e,t=r)=>["err",{e:"Parse",m:e,errCtx:t}];if("("===e||")"===e)return n("nameless function");if(")"===t[0].typ)return n("empty function body");const{params:a,errors:s}=Ae(t);for(;fe(t);)oe(s,Ce(t,a));for(let e=0,t=fe(s);e<t;e++){const t=s[e];if("err"===t.typ)return n(t.value,t.errCtx)}return["func",{name:e,ins:s}]}(e,{sourceId:t,line:e.errCtx.line,col:e.errCtx.col}))),o=[],u=[];s.forEach((e=>{"err"===e[0]?u.push(e[1]):o.push(e[1])})),oe(u,se(o.map((e=>ke(e.ins)??[]))));const i={};return o.forEach((e=>i[e.name]=e)),{errors:u,funcs:i}}function $e(e,t){return e.dict.has(t)?{kind:"val",value:e.dict.get(t)}:{kind:"err",err:`"${t} not found.`}}function Ee(e,t,r){e.dict.set(t,r)}function Be(e,t,r){switch(t){case"test.function":e.output+=r[0].v+"\n";break;default:return{kind:"err",err:`operation ${t} does not exist`}}return{kind:"val",value:{t:"null",v:void 0}}}const Ie=[{name:"Hello, world!",code:'"Hello, world!"',out:"Hello, world!"},{name:"Say Hello, world!",code:'(print "Hello, world!")',out:"Hello, world!\nnull"},{name:"1 + 1 = 2",code:"(+ 1 1)",out:"2"},{name:"Negate 1 = -1",code:"(- 1)",out:"-1"},{name:"(1+1)+1+(1+1) = 5",code:"(+ (+ 1 1) 1 (+ 1 1))",out:"5"},{name:"Conditional head",code:"((if true + -) 12 9 1)",out:"22"},{name:"Whens",code:'[(when 123 (print "hi") 234) (when false (print "bye"))]',out:"hi\n[234 null]"},{name:"match and wildcard",code:'(match [1 2]\n             [0 0] (print "hello")\n             [0 2] (print "bye")\n             [1 _] "hey")',out:"hey"},{name:"Cond number head",code:"((if false 1 2) [:a :b :c])",out:":c"},{name:"and & short-circuit",code:"[(and true (if true null 1) true) (and 1 2 3)]",out:"[false true]"},{name:"or & short-circuit",code:'[(or true (print "hello") 1) (or false (print-str "-> ") 1)]',out:"-> [true 1]"},{name:"String retrieve",code:'(2 "Hello")',out:"l"},{name:"Vector retrieve",code:"(2 [:a :b :c :d])",out:":c"},{name:"Key as operation",code:'[(:age {:name "Patrick" :age 24}) (:abc [:a :abc :c])]',out:"[24 :abc]"},{name:"Dictionary as op 1",code:'({"name" "Patrick" "age" 24} "age")',out:"24"},{name:"Dictionary as op 2",code:'({"name" "Patrick"} "age" 24)',out:'{"name" "Patrick", "age" 24}'},{name:"Equalities",code:'[(= 1 2 1)\n            (!= 1 2 1)\n            (= "Hello" "hello")\n            (!= "world" "world")\n            (= [0 [1]] [0 [1]])]',out:"[false 1 false false [0 [1]]]"},{name:"Define and retrieve",code:"(var a 1) a",out:"1"},{name:"Define and add",code:"(var a 1) (inc a)",out:"2"},{name:"Define op and call",code:"(var f +) (f 2 2)",out:"4"},{name:"Define vec and call",code:"(var f [1]) (f 1)",out:"1"},{name:"Define num and call",code:"(var f 1) (f [:a :b :c])",out:":b"},{name:"Apply op to var",code:"(var a 10) (var! a + 10)",out:"20"},{name:"Apply op to let",code:"(let a 10) (let! a (if true + -) (+ 2 3) 5)",out:"20"},{name:"Print simple vector",code:"[1 2 3]",out:"[1 2 3]"},{name:"Boolean select",code:"[(true 1 2) (false 1)]",out:"[1 null]"},{name:"Sum vector of numbers",code:"[(reduce + [1 2 3]) (reduce + 3 [1 2 3])]",out:"[6 9]"},{name:"Sum vectors of numbers",code:"(map + [1 2 3] [1 2 3 4])",out:"[2 4 6]"},{name:"Filter by integer",code:'(filter 2 [[1] [:a :b :c] "hello" "hi"])',out:'[[:a :b :c] "hello"]'},{name:"Comments, short decimal",code:';((print "Hello")\n           .456',out:"0.456"},{name:"Dictionary into vector",code:"(into [1 2] {3 4 5 6})",out:"[1 2 [3 4] [5 6]]"},{name:"Vector into dictionary",code:"(into {[0] 1 [2] 3} [[0] 2])",out:"{[0] 2, [2] 3}"},{name:"While loop",code:"(var n 5)\n           (while (< 0 n)\n             (print-str n)\n             (var n (dec n)))",out:"543210"},{name:"Catch error",code:'(catch\n             (:e (catch (do (let a :a) (+ 1 a)) (0 errors)))\n             (print "hi"))',out:"Type"},{name:"Define with no call",code:'(function func (print "Nothing."))'},{name:"Call greet func",code:'(function greeting (print "Hello!")) (greeting)',out:"Hello!\nnull"},{name:"Call const value func",code:"(function const 123) (const)",out:"123"},{name:"Call identity funcs",code:"(function id1 %)\n           (function id2 x x)\n           [(id1 123) (id2 456)]",out:"[123 456]"},{name:"Call greet with name",code:'(function greeting name (print "Hello, " name "!"))\n           (greeting "Patrick")',out:"Hello, Patrick!\nnull"},{name:"Call with too few args",code:"(function func a b c [a b c]) (func 1 2)",out:"[1 2 null]"},{name:"Define func and call",code:"(function func a b (+ a b)) (var f func) (f 2 2)",out:"4"},{name:"Anonymous parameters",code:"(function avg<n? (< (/ (.. + %) (len %)) %1))\n           (avg<n? [0 10 20 30 40] 5)",out:"false"},{name:"Call parameter",code:'(function f x (x "hello")) (f print)',out:"hello\nnull"},{name:"Let and retrieve",code:"(function f (let a 1) a) (f)",out:"1"},{name:"Let num op and call",code:"(function f (let n 0) (n [1])) (f)",out:"1"},{name:"Explicit return",code:"(function f (return 123) (print 456)) (f)",out:"123"},{name:"Closure 1",code:"(let x 10)\n           (let closure #(+ x x))\n           (let x 11)\n           (closure)",out:"20"},{name:"Closure 2",code:"(filter #(or (.. = args) (even? %)) (range 10) 5)",out:"[0 2 4 5 6 8]"},{name:"Closure 3",code:"(function f #(+ x x))\n           (var x 10) (let c20 (f))\n           (var x 20) (let c40 (f))\n           [(c20) (c40)]",out:"[20 40]"},{name:"Func returns closure",code:"(function f x #(x 2 2))\n           (let closure (f +))\n           (closure)",out:"4"},{name:"Dictionary closure",code:"(function f x #{x 2})\n           (let closure (f :a))\n           (closure)",out:"{:a 2}"},{name:"Vector closure",code:"(function f x #[1 x %])\n           (let closure (f 2))\n           (closure 3)",out:"[1 2 3]"},{name:"Closure as head",code:"(#[% %1 %2] 1 2 3)",out:"[1 2 3]"},{name:"Partial closure 1",code:"(@[] 1 2 3)",out:"[1 2 3]"},{name:"Partial closure 2",code:"(@((do +) 2) 2)",out:"4"},{name:"Parameterised closure 1",code:"((fn a b (+ a b)) 2 2)",out:"4"},{name:"Parameterised closure 2",code:"((fn a b (print-str a b) (+ a b)) 2 2)",out:"224"},{name:"Parameterised closure 3",code:"(((fn (fn 1))))",out:"1"},{name:"Destructure var",code:"(var [x [y]] [1 [2]]) [y x]",out:"[2 1]"},{name:"Destructure string",code:'(let [a b c] "hello") [a b c]',out:'["h" "e" "l"]'},{name:"Destructure function",code:"(function f a [[b c] d] e [e d c b a]) (f 0 [[1 2] 3] 4)",out:"[4 3 2 1 0]"},{name:"Destructuring closure",code:"(let f (fn a [b [c]] d [d c b a])) (f 0 [1 [2]] 3)",out:"[3 2 1 0]"},{name:"Destructuring fn decoy",code:"(let f (fn a [a [a]])) (f 0)",out:"[0 [0]]"},{name:"Threading",code:"(-> 1 inc @(+ 10))",out:"12"},{name:"String instead of number",code:'(function sum (.. + args))\n           (print (sum 2 2))\n           (sum 2 "hi")',out:"4",err:["Type"]},{name:"Reference non-existing",code:"x",err:["Reference"]},{name:"Expired let retrieve",code:"(function f (let a 1) a) (f) a",err:["Reference"]},{name:"Call non-existing",code:"(x)",err:["External"]},{name:"Call budget",code:"(function f (f)) (f)",err:["Budget"]},{name:"Loop budget",code:"(var n 10000)\n           (while (< 0 n)\n             (var n (dec n)))",err:["Budget"]},{name:"Range budget",code:"(range 10000)",err:["Budget"]},{name:"Fibonacci 13",code:"(function fib n\n             (if (< n 2) n\n               (+ (fib (dec n))\n                  (fib (- n 2)))))\n           (fib 13)",out:"233"},{name:"dedupe (recur)",code:"(function dedupe list -out\n             (let out (or -out []))\n             (let next (if (out (0 list)) [] [(0 list)]))\n             (if (empty? list) out\n                 (recur (sect list) (into out next))))\n           (dedupe [1 1 2 3 3 3])",out:"[1 2 3]"},{name:"frequencies",code:'(function frequencies list\n             (reduce #(push % %1 (inc (or (% %1) 0))) {} list))\n           (frequencies "12121212")',out:'{"1" 4, "2" 4}'},{name:"set get",code:"[($globals.time_offset 5.5) $globals.time_offset]",out:"[5.5 5.5]"},{name:"exe",code:"(test.function 123)",out:"123\nnull"},{name:"Empty parens",code:"()",err:["Parse"]},{name:"Imbalanced parens 1",code:'(print ("hello!")',err:["Parse"]},{name:"Imbalanced parens 2",code:'print "hello!")',err:["Parse"]},{name:"Imbalanced quotes",code:'(print "Hello)',err:["Parse"]},{name:"Function as op",code:"(function)",err:["Parse"]},{name:"Function without name",code:"(function (+))",err:["Parse"]},{name:"Function without body",code:"(function func)",err:["Parse"]},{name:"Variable not symbol",code:"(var 1 2)",err:["Parse"]},{name:"Parser type error 1",code:"(function f (+ 1 :a))",err:["Type"]},{name:"Parser type error 2",code:"(function f (+ 1 (into {} {})))",err:["Type"]},{name:"Parser type error 3",code:"(function f (if true (into 2 {}) (+ 2 2)))",err:["Type"]}],Pe=({v:e})=>e,je=({v:e})=>e,Me=({v:e})=>e,De=({v:e})=>e,qe=(e,t)=>o(e)===o(t)&&!e.some(((e,r)=>!Ne(e,t[r]))),Ne=(e,t)=>{if("wild"===e.t||"wild"===t.t)return!0;if(e.t!==t.t)return!1;switch(e.t){case"null":return!0;case"bool":case"num":return e.v===t.v;case"vec":return qe(e.v,Me(t));case"dict":{const r=De(t);return o(e.v.keys)===o(r.keys)&&qe(e.v.keys,r.keys)}case"str":case"ref":case"key":case"func":return je(e)===je(t);case"clo":return e.v.name===t.v.name}return 0},Se=e=>e.reduce(((e,t)=>e+He(t)),""),He=e=>{const t=e=>"str"===e.t?`"${e.v}"`:He(e);if("clo"===e.t)return e.v.name;if("vec"===e.t)return`[${e.v.map(t).join(" ")}]`;if("dict"===e.t){const{keys:r,vals:n}=e.v,[a,s]=[r.map(t),n.map(t)];return`{${a.map(((e,t)=>`${e} ${s[t]}`)).join(", ")}}`}return"null"===e.t?"null":"wild"===e.t?"_":`${e.v}`},Te=e=>"vec"===e.t?a(e.v):"str"===e.t?[...e.v].map((e=>({t:"str",v:e}))):"dict"===e.t?e.v.keys.map(((t,r)=>({t:"vec",v:[t,e.v.vals[r]]}))):[],Oe=e=>{o(e)%2==1&&e.pop();const t=e.filter(((e,t)=>t%2==0)),r=e.filter(((e,t)=>t%2==1)),n=[],a=[];return t.forEach(((e,t)=>{const s=n.findIndex((t=>Ne(t,e)));-1===s?(n.push(e),a.push(r[t])):a[s]=r[t]})),{t:"dict",v:{keys:n,vals:a}}},Fe=({keys:e,vals:t},r)=>{const n=e.findIndex((e=>Ne(e,r)));return-1===n?{t:"null",v:void 0}:t[n]},_e=({keys:e,vals:t},r,n)=>{const[s,o]=[a(e),a(t)],u=e.findIndex((e=>Ne(e,r)));return-1!==u?o[u]=n:(s.push(r),o.push(n)),{keys:s,vals:o}},{abs:Re,cos:Le,sin:Ve,tan:We,sign:Ke,sqrt:ze,floor:Ue,ceil:Ge,round:Je,max:Qe,min:Xe}=r,{logn:Ye,log2:Ze,log10:et}=r,{concat:tt,has:rt,flat:nt,push:at,reverse:st,slice:ot,splice:ut,sortBy:it}=r,{ends:ct,slen:lt,starts:pt,sub:dt,subIdx:mt,substr:vt,upperCase:ft,lowerCase:yt}=r,{trim:xt,trimStart:ht,trimEnd:bt,charCode:gt,codeChar:Ct,strIdx:At}=r,{getTimeMs:kt,randInt:wt,randNum:$t}=r,{isNum:Et,len:Bt,objKeys:It,range:Pt,toNum:jt}=r,Mt={};let Dt,qt=[],Nt=[];const St=e=>qt.push({t:"bool",v:e}),Ht=e=>qt.push({t:"num",v:e}),Tt=(e="")=>qt.push({t:"str",v:e}),Ot=(e=[])=>qt.push({t:"vec",v:e}),Ft=e=>qt.push({t:"dict",v:e}),_t=()=>qt.push({t:"null",v:void 0}),Rt=e=>qt.push({t:"func",v:e});function Lt(e,t,r,n=!0){const u=[{e:"Arity",m:`${Q[t.t]} as op requires one sole argument`,errCtx:r}];if("str"===t.t||"func"===t.t){const i=t.v;return J[i]?J[i].external?e=>{const t=Mt[i](e);if("err"===t.kind)return[{e:"External",m:t.err,errCtx:r}];qt.push(t.value)}:t=>function(e,t,r,n,u){const i=e=>[ee(e,n)];if(u){const r=Y(e,Bt(t),n);if(r)return r}{const r=Z(e,t.map((e=>[e.t])),n);if(r)return r}switch(e){case"str":return void qt.push({t:"str",v:Se(t)});case"print":case"print-str":return r.print(Se(t),"print"===e),void _t();case"vec":return void Ot(t);case"dict":return void qt.push(Oe(t));case"len":return void Ht("str"===t[0].t?lt(t[0].v):"vec"===t[0].t?Bt(t[0].v):Bt(De(t[0]).keys));case"to-num":return void(Et(t[0].v)?Ht(jt(t[0].v)):_t());case"to-key":return void qt.push({t:"key",v:`:${He(t[0])}`});case"!":return void St(!X(t[0]));case"=":case"!=":for(let r=1,n=Bt(t);r<n;++r)if(Ne(t[r-1],t[r])!==("="===e))return void St(!1);return void qt.push(t[0]);case"-":return void Ht(1===Bt(t)?-Pe(t[0]):t.map(Pe).reduce(((e,t)=>e-t)));case"**":return void Ht(Pe(t[0])**(1===Bt(t)?2:Pe(t[1])));case"+":return void Ht(t.map(Pe).reduce(((e,t)=>e+t)));case"*":return void Ht(t.map(Pe).reduce(((e,t)=>e*t)));case"/":return void Ht(t.map(Pe).reduce(((e,t)=>e/t)));case"//":return void Ht(t.map(Pe).reduce(((e,t)=>Ue(e/t))));case"fast=":case"fast!=":return Ne(t[0],t[1])!==("fast="===e)?void St(!1):void qt.push(t[0]);case"fast-":return void Ht(t[0].v-t[1].v);case"fast+":return void Ht(t[0].v+t[1].v);case"fast*":return void Ht(t[0].v*t[1].v);case"fast/":return void Ht(t[0].v/t[1].v);case"fast//":return void Ht(Ue(t[0].v/t[1].v));case"fast<":return void St(t[0].v<t[1].v);case"fast>":return void St(t[0].v>t[1].v);case"fast<=":return void St(t[0].v<=t[1].v);case"fast>=":return void St(t[0].v>=t[1].v);case"rem":return void Ht(t.map(Pe).reduce(((e,t)=>e%t)));case"min":return void Ht(t.map(Pe).reduce(((e,t)=>Xe(e,t))));case"max":return void Ht(t.map(Pe).reduce(((e,t)=>Qe(e,t))));case"<":case">":case"<=":case">=":for(let r=1,n=Bt(t);r<n;++r){const[n,a]=[t[r-1].v,t[r].v];if("<"===e&&n>=a||">"===e&&n<=a||"<="===e&&n>a||">="===e&&n<a)return void St(!1)}return void St(!0);case"inc":return void Ht(t[0].v+1);case"dec":return void Ht(t[0].v-1);case"abs":return void Ht(Re(t[0].v));case"round":if(2===Bt(t)){const e=10**t[1].v;Ht(Je(t[0].v*e)/e)}else Ht(Je(t[0].v));return;case"sin":case"cos":case"tan":case"sqrt":case"floor":case"ceil":case"logn":case"log2":case"log10":return void Ht({sin:Ve,cos:Le,tan:We,sqrt:ze,floor:Ue,ceil:Ge,logn:Ye,log2:Ze,log10:et}[e](Pe(t[0])));case"and":return void St(t.every(X));case"or":return void St(t.some(X));case"xor":return void(X(t[0])!==X(t[1])?qt.push(X(t[0])?t[0]:t[1]):St(!1));case"&":case"|":case"^":case"<<":case">>":case">>>":const[u,c]=[Pe(t[0]),Pe(t[1])];return void Ht("&"===e?u&c:"|"===e?u|c:"^"===e?u^c:"<<"===e?u<<c:">>"===e?u>>c:u>>>c);case"~":return void Ht(~Pe(t[0]));case"odd?":case"even?":return void St(Pe(t[0])%2==("odd?"===e?1:0));case"pos?":case"neg?":case"zero?":{const r=Pe(t[0]);return void St("pos?"===e?r>0:"neg?"===e?r<0:!r)}case"null?":case"num?":case"bool?":case"str?":case"dict?":case"vec?":case"key?":case"func?":case"wild?":return void St("null?"===e&&"null"===t[0].t||"num?"===e&&"num"===t[0].t||"bool?"===e&&"bool"===t[0].t||"str?"===e&&"str"===t[0].t||"dict?"===e&&"dict"===t[0].t||"vec?"===e&&"vec"===t[0].t||"key?"===e&&"key"===t[0].t||"func?"===e&&("func"===t[0].t||"clo"===t[0].t)||"wild?"===e&&"wild"===t[0].t);case"has?":return void St(dt(je(t[0]),je(t[1])));case"idx":{let e=-1;if("str"===t[0].t){if("str"!==t[1].t)return i("strings can only contain strings");if(!(Bt(t)<3)){const e=t[0].v.split("");return e[Pe(t[2])]=t[1].v,void Tt(e.join(""))}e=mt(t[0].v,t[1].v)}else if("vec"===t[0].t){if(!(Bt(t)<3)){const e=ot(t[0].v);return e[Pe(t[2])]=t[1],void Ot(e)}e=t[0].v.findIndex((e=>Ne(e,t[1])))}return void(-1===e?_t():Ht(e))}case"map":case"for":case"reduce":case"filter":case"remove":case"find":case"count":{const a=Lt(r,t.shift(),n);if("map"===e||"for"===e){const e=t.findIndex((({t:e})=>"vec"!==e&&"str"!==e&&"dict"!==e));if(-1!==e)return i(`argument ${e+2} must be either: string, vector, dictionary, not ${Q[t[e].t]}`)}if("for"===e){const e=t.map(Te),s=e.map(Bt),o=s.map(((e,t)=>ot(s,0,t+1).reduce(((e,t)=>e*t))));o.unshift(1);const u=o.pop();if(u>r.loopBudget)return[{e:"Budget",m:"would exceed loop budget",errCtx:n}];const i=[];for(let t=0;t<u;++t){const r=o.map(((e,r)=>Ue(t/e%s[r]))),n=a(e.map(((e,t)=>e[r[t]])));if(n)return n;i.push(qt.pop())}return void Ot(i)}if("map"===e){const e=t.map(Te),r=Xe(...e.map(Bt)),n=[];for(let t=0;t<r;++t){const r=a(e.map((e=>e[t])));if(r)return r;n.push(qt.pop())}return void Ot(n)}if("reduce"!==e){const r=Te(t.shift()),n="remove"===e,s="find"===e,o="count"===e,u=[];let i=0;for(let e=0,c=Bt(r);e<c;++e){const c=a([r[e],...t]);if(c)return c;const l=X(qt.pop());if(o)i+=l?1:0;else if(s){if(l)return void qt.push(r[e])}else l!==n&&u.push(r[e])}switch(e){case"count":return void Ht(i);case"find":return void _t()}return void Ot(u)}const s=t.pop();if(!rt(["vec","dict","str"],s.t))return i(`must reduce either: string, vector, dictionary, not ${Q[s.t]}`);const o=Te(s);if(!Bt(o))return void(Bt(t)?qt.push(t[0]):Ot());if(Bt(o)<2&&!Bt(t))return void at(qt,o);let u=(Bt(t)?t:o).shift();for(let e=0,t=Bt(o);e<t;++e){const t=a([u,o[e]]);if(t)return t;u=qt.pop()}return void qt.push(u)}case"repeat":{const e=t.shift(),a=[],s=Pe(t[0]);if(s>r.rangeBudget)return[{e:"Budget",m:"would exceed range budget",errCtx:n}];if(r.rangeBudget-=s,"func"===e.t||"clo"===e.t){const t=Lt(r,e,n);for(let e=0;e<s;++e){const r=t([{t:"num",v:e}]);if(r)return r;a.push(qt.pop())}}else for(let t=0;t<s;++t)a.push(e);return void Ot(a)}case"->":qt.push(t.shift());for(let e=0,a=Bt(t);e<a;++e){const a=Lt(r,t[e],n)([qt.pop()]);if(a)return a}return;case"rand-int":case"rand":{const r=Bt(t),[n,a]=[r<2?0:Pe(t[0]),0===r?1+jt("rand-int"===e):Pe(1===r?t[0]:t[1])];Ht("rand-int"===e?wt(n,a):$t(n,a))}return;case"do":case"val":return void qt.push("do"===e?t.pop():t.shift());case".":case"..":case"...":{const a=Lt(r,t.shift(),n);if("."===e)return a(t);let s=t;if(".."===e)s=nt(t.map((e=>"vec"===e.t?e.v:[e])));else{const e=s.pop();at(s,nt(["vec"===e.t?e.v:[e]]))}return a(s)}case"into":if("vec"===t[0].t)Ot(tt(t[0].v,Te(t[1])));else if("vec"===t[1].t)qt.push(Oe(tt(nt(Te(t[0]).map(Me)),t[1].v)));else{const{keys:e,vals:r}=De(t[0]),n=De(t[1]);Ft({keys:tt(e,n.keys),vals:tt(r,n.vals)})}return;case"push":if("vec"===t[0].t){const e=t[0].v;if(Bt(t)<3)Ot(tt(e,[t[1]]));else{const r=Pe(t[2]);Ot(tt(tt(ot(e,0,r),[t[1]]),ot(e,r)))}}else Bt(t)<3?qt.push((({keys:e,vals:t},r)=>{const[n,o]=[a(e),a(t)],u=e.findIndex((e=>Ne(e,r)));return-1!==u&&(s(n,u,1),s(o,u,1)),{t:"dict",v:{keys:n,vals:o}}})(De(t[0]),t[1])):Ft(_e(De(t[0]),t[1],t[2]));return;case"sect":{const e=t[0],r="vec"===e.t?Bt(e.v):lt(je(e));let n=0,a=r;switch(Bt(t)){case 1:n=1;break;case 2:{const e=Pe(t[1]);e<0?a+=e:n+=e;break}case 3:{const e=Pe(t[1]),s=Pe(t[2]);n=e<0?r+e+(s<0?s:0):n+e,a=(s<0?a:n)+s;break}}return n=Qe(n,0),a=Xe(a,r),n>a?void("vec"===e.t?Ot:Tt)():void("vec"===e.t?Ot(ot(e.v,n,a)):Tt(vt(je(t[0]),n,a-n)))}case"reverse":return void("str"===t[0].t?Tt(Se(st(Te(t[0])))):Ot(st(Te(t[0]))));case"sort":{const e=Te(t[0]);if(!Bt(e))return void Ot();const a=[];if(1===Bt(t))at(a,e.map((e=>[e,e])));else{const s=Lt(r,t.pop(),n);for(let t=0,r=Bt(e);t<r;++t){const r=s([e[t]]);if(r)return r;a.push([e[t],qt.pop()])}}const s=a[0][1].t;return a.some((([e,{t}])=>t!==s||!rt(["num","str"],t)))?i("can only sort by all number or all string"):("num"===a[0][1].t?it(a,(([e,t],[r,n])=>Pe(t)>Pe(n)?1:-1)):it(a,(([e,t],[r,n])=>je(t)>je(n)?1:-1)),void Ot(a.map((([e])=>e))))}case"range":{const[e,a,s]=t.map(Pe),o=s&&s<0&&e<a,[u,i]=Bt(t)>1?o?[a-1,e-1]:[e,a]:[0,e],c=Ke((i-u)*(s||1))*(s||1),l=Ge(Re((i-u)/c));if(!l)return void Ot([]);if(l>r.rangeBudget)return[{e:"Budget",m:"would exceed range budget",errCtx:n}];r.rangeBudget-=l;const p=Pt(l).map((e=>e*c+u));return void Ot(p.map((e=>({t:"num",v:e}))))}case"empty?":return void St(!Bt(Te(t[0])));case"keys":case"vals":return void Ot(De(t[0])["keys"===e?"keys":"vals"]);case"split":return void Ot(je(t[Bt(t)-1]).split(Bt(t)-1?je(t[0]):" ").map((e=>({t:"str",v:e}))));case"join":return void Tt(Te(t[1]).map(He).join(je(t[0])));case"starts-with?":case"ends-with?":return void St(("starts-with?"===e?pt:ct)(je(t[0]),je(t[1])));case"upper-case":case"lower-case":case"trim":case"trim-start":case"trim-end":return void Tt(("upper-case"===e?ft:"lower-case"===e?yt:"trim"===e?xt:"trim-start"===e?ht:bt)(je(t[0])));case"str*":{const e=je(t[0]);return void Tt(Pt(Qe(Ge(Pe(t[1])),0)).map((t=>e)).join(""))}case"char-code":if("str"===t[0].t){const e=Bt(t)>1?Pe(t[1]):0,r=je(t[0]);lt(r)<=e||e<0?_t():Ht(gt(At(r,e)))}else Tt(Ct(Pe(t[0])));return;case"time":return void Ht(kt());case"version":return void Ht(20211208);case"tests":return void Tt(function(e,t=!0){const r=[];for(let t=0;t<o(Ie);++t){const{name:n,code:a,err:s,out:o}=Ie[t],u={dict:new Map,output:""},i={funcs:{},vars:{}},c=N(),l=e({get:e=>$e(u,e),set:(e,t)=>Ee(u,e,t),print(e,t){u.output+=e+(t?"\n":"")},exe:(e,t)=>Be(u,e,t),functions:[],env:i,loopBudget:1e4,rangeBudget:1e3,callBudget:1e3,recurBudget:1e4},a,a,!0),p="errors"===l.kind?l.errors:[],d=(s||[]).join()===p.map((({e})=>e)).join(),m=!o||w(u.output)===o,v=N()-c,[f,y,x,h,b]=[B(`${t+1}`,3),B(n,24),B(`${v}ms`,6),m||o+"\t!=\t"+w(u.output),d||p.map((({e,m:t,errCtx:{line:r,col:n}})=>`${e} ${r}:${n}: ${t}`))];r.push({okErr:d,okOut:m,elapsedMs:v,display:`${f} ${y} ${x} ${h} ${b}`})}const n=r.reduce(((e,{elapsedMs:t})=>e+t),0),a=o(r.filter((({okOut:e,okErr:t})=>e&&t)));return h(r.filter((e=>!t||!e.okOut||!e.okErr)).map((e=>e.display)),[`---- ${a}/${o(r)} tests passed in ${n}ms.`])}(Ut,!(Bt(t)&&X(t[0]))).join("\n"));case"symbols":return void Ot(function(e,t=!0){let r=t?["function","let","var","if","if!","while"]:[];at(r,["args","PI","E"]),r=tt(r,It(J)),r=tt(r,It(e.env.funcs)),r=tt(r,It(e.env.vars));const n=["entry"];return r=r.filter((e=>!rt(n,e))),it(r,((e,t)=>e>t?1:-1))}(r,!1).map((e=>({t:"str",v:e}))));case"eval":{delete r.env.funcs.entry;const e=Bt(qt),a=`${n.sourceId} eval`,s=zt(r,je(t[0]),a);return s?[{e:"Eval",m:"error within evaluated code",errCtx:n},...s]:void(e===Bt(qt)&&_t())}case"recur":return void(Dt=t);case"reset":return r.env.vars={},r.env.funcs={},Nt=[],void _t()}return[{e:"Unexpected",m:"operation doesn't exist",errCtx:n}]}(i,t,e,r,n):i in e.env.funcs?t=>Kt(e,e.env.funcs[i],t):i in e.env.vars?Lt(e,e.env.vars[i],r):i in Nt[Bt(Nt)-1]?Lt(e,Nt[Bt(Nt)-1][i],r):pt(i,"$")?t=>{if(!Bt(t))return u;const n=e.set(vt(i,1),t[0]);return qt.push(t[0]),n?[{e:"External",m:n,errCtx:r}]:void 0}:t=>{const n=e.exe(i,t);if("val"!==n.kind)return[{e:"External",m:n.err,errCtx:r}];qt.push(n.value)}}if("clo"===t.t)return r=>Kt(e,t.v,r);if("key"===t.t)return e=>{if(!Bt(e))return u;if("dict"===e[0].t)qt.push(Fe(De(e[0]),t));else{if("vec"!==e[0].t)return re(r,[e[0].t]);{const r=Me(e[0]).find((e=>Ne(e,t)));qt.push(r??{t:"null",v:void 0})}}};if("num"===t.t){const e=Ue(t.v);return t=>{if(!Bt(t))return u;const n=t[0];if("str"!==n.t&&"vec"!==n.t&&"dict"!==n.t)return te(r,[n.t]);const a=Te(n);Re(e)>=Bt(a)?_t():e<0?qt.push(a[Bt(a)+e]):qt.push(a[e])}}if("vec"===t.t){const{v:e}=t;return t=>{if(!Bt(t))return u;const r=e.find((e=>Ne(e,t[0])));r?qt.push(r):_t()}}if("dict"===t.t){const e=t.v;return t=>{if(1===Bt(t))qt.push(Fe(e,t[0]));else{if(2!==Bt(t))return[{e:"Arity",m:"dictionary as operation takes one or two arguments only",errCtx:r}];Ft(_e(e,t[0],t[1]))}}}if("bool"===t.t){const e=t.v;return t=>{if(!Bt(t)||Bt(t)>2)return[{e:"Arity",m:"boolean as operation takes one or two arguments only",errCtx:r}];qt.push(e?t[0]:Bt(t)>1?t[1]:{t:"null",v:void 0})}}return e=>[{e:"Operation",m:`${He(t)} is an invalid operation`,errCtx:r}]}function Vt(e){const t=(e,t,r)=>_e(e,{t:"key",v:t},r);return e.map((({e,m:r,errCtx:n})=>{let a=t({keys:[],vals:[]},":e",{t:"str",v:e});return a=t(a,":m",{t:"str",v:r}),a=t(a,":line",{t:"num",v:n.line}),a=t(a,":col",{t:"num",v:n.col}),{t:"dict",v:a}}))}function Wt(e,t){let r=e;for(let e=0,n=Bt(t)-1;e<n;++e){const a=r[t[e]];if("vec"!==a.t)return"str"===a.t&&e+1===n&&t[e+1]<lt(a.v)?{t:"str",v:At(a.v,t[e+1])}:{t:"null",v:void 0};r=a.v}const n=t[Bt(t)-1];return n>=Bt(r)?{t:"null",v:void 0}:r[n]}function Kt(e,t,r,n=!1){--e.callBudget,n||Nt.push({});const a=Bt(qt);for(let n=0,s=Bt(t.ins);n<s;++n){const o=t.ins[n],{errCtx:u}=t.ins[n],i=e.loopBudget<1;if(i||e.callBudget<1)return[{e:"Budget",m:(i?"looped":"called")+" too many times",errCtx:u}];switch(o.typ){case"val":qt.push(o.value);break;case"var":e.env.vars[o.value]=qt[Bt(qt)-1];break;case"let":Nt[Bt(Nt)-1][o.value]=qt[Bt(qt)-1];break;case"dle":case"dva":{const t=o.value,r=qt.pop();let n;t.forEach((({name:t,position:a})=>{n="dva"===o.typ?e.env.vars[t]=Wt([r],a):Nt[Bt(Nt)-1][t]=Wt([r],a)})),qt.push(n);break}case"npa":case"upa":{const e=o.value;-1===e?Ot(r):Bt(r)<=e?_t():qt.push(r[e]);break}case"dpa":qt.push(Wt(r,o.value));break;case"ref":{const t=o.value;if(J[t])Rt(t);else if(pt(t,"$")){const r=e.get(vt(t,1));if("err"===r.kind)return[{e:"External",m:r.err,errCtx:u}];qt.push(r.value)}else if(t in e.env.vars)qt.push(e.env.vars[t]);else if(t in Nt[Bt(Nt)-1])qt.push(Nt[Bt(Nt)-1][t]);else{if(!(t in e.env.funcs))return[{e:"Reference",m:`"${t}" did not exist`,errCtx:u}];Rt(t)}break}case"exe":{const a=Lt(e,qt.pop(),u,!1),s=o.value,i=a(ut(qt,Bt(qt)-s,s));if(i){const e=ot(t.ins,n).findIndex((e=>"cat"===e.typ));if(-1!==e){n+=e,Nt[Bt(Nt)-1].errors={t:"vec",v:Vt(i)};break}return i}if(Dt){if(Nt[Bt(Nt)-1]={},n=-1,o.value,r=Dt,Dt=void 0,--e.recurBudget,!e.recurBudget)return[{e:"Budget",m:"recurred too many times",errCtx:u}];break}break}case"or":X(qt[Bt(qt)-1])?n+=o.value:qt.pop();break;case"mat":{const e=qt[Bt(qt)-2];Ne(e,qt.pop())?qt.pop():n+=o.value;break}case"if":X(qt.pop())||(n+=o.value);break;case"jmp":case"cat":n+=o.value;break;case"loo":n+=o.value,--e.loopBudget;break;case"pop":ut(qt,Bt(qt)-o.value,o.value);break;case"ret":o.value?ut(qt,a,Bt(qt)-a-1):_t(),n=s;break;case"clo":case"par":{const t=o.value[0];let n=o.value[1];const a=({typ:e,value:t},r)=>"ref"===e&&!n.find((e=>"let"===e.typ&&e.value===t))||"npa"===e||"val"===e&&r+1!==Bt(n)&&"exe"===n[r+1].typ,s={name:"",ins:n.map(((e,t)=>{if(t+1===Bt(n))return e;const r="val"===e.typ&&"str"===e.value.t&&"exe"===n[t+1].typ&&Nt[Bt(Nt)-1][e.value.v];return r?{typ:"val",value:r}:e})).filter(a)},i=Kt(e,s,r,!0);if(i)return i;const c=Bt(s.ins),l=ut(qt,Bt(qt)-c,c);if(n=n.map(((e,t)=>a(e,t)?{typ:"val",value:l.shift(),errCtx:u}:e)),"par"===o.typ){const{value:e,errCtx:t}=n.pop();if(Bt(n)>0&&"exe"===n[Bt(n)-1].typ){const e=n.findIndex((e=>"exp"===e.typ)),t=ut(n,e,Bt(n)-e);at(t,n),n=t}else n.unshift(n.pop());n.push({typ:"upa",value:-1,errCtx:t}),n.push({typ:"val",value:{t:"str",v:"..."},errCtx:t}),n.push({typ:"exe",value:e+2,errCtx:t})}qt.push({t:"clo",v:{name:t,ins:n}});break}}}n||(Nt.pop(),ut(qt,a,Bt(qt)-(a+1)))}function zt(e,t,r){const n=we(t,r);return Bt(n.errors)?n.errors:(e.env.funcs={...e.env.funcs,...n.funcs},"entry"in e.env.funcs?Kt(e,e.env.funcs.entry,[]):void 0)}function Ut(e,t,r,n=!1){const{callBudget:a,loopBudget:s,recurBudget:o,rangeBudget:u}=e;e.functions.forEach((({name:e,definition:t,handler:r})=>{if(J[e]&&!Mt[e])throw"Redefining internal operations is disallowed.";J[e]={...t,external:!0},Mt[e]=r}));const i=zt(e,t,r);(function(e){e.forEach((({name:e})=>{delete J[e],delete Mt[e]}))})(e.functions),[e.callBudget,e.recurBudget]=[a,o],[e.loopBudget,e.rangeBudget]=[s,u],delete e.env.funcs.entry;const c=qt.pop();return[qt,Nt]=[[],[]],n&&!i&&c&&e.print(He(c),!0),i?{kind:"errors",errors:i}:c?{kind:"val",value:c}:{kind:"empty"}}const Gt=new Map,Jt=/[\[\]\(\) ,]/;function Qt(e,t){const r=N().toString();Gt.set(r,t);const n=Ut(e,t,r,!0);if("errors"!==n.kind)return[];let a=[];return n.errors.forEach((({e,m:t,errCtx:{line:r,col:n,sourceId:s}})=>{const o=Gt.get(s);if(!o)return void a.push({type:"message",text:`${e} Error: line ${r} col ${n}: ${t}\n`});const i=o.split("\n")[r-1],c=l(i,n-1).split(Jt)[0],p=$(l(i,0,n-1));if(a.push({type:"message",text:B(`${r}`,4)+p}),c){const e=l(i,n-1+u(c));a.push({type:"error",text:c}),a.push({type:"message",text:`${e}\n`})}else{const e=l(i,n);a.push({type:"error",text:i[n-1]}),a.push({type:"message",text:`${e}\n`})}a.push({type:"message",text:`${e} Error: ${t}.\n`})})),a}window.insitux=t.invoker})();
//# sourceMappingURL=insitux.js.map