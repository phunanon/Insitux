{"version":3,"file":"repl.js","mappings":";;;;;;;;AAAa;;AAEb;AACA;AACA;AACA,EAAE;;AAEF;AACA,4BAA4B,4BAA4B;AACxD,aAAa,IAAI,IAAI,IAAI,IAAI;AAC7B;;AAEA;AACA;;;;;;;;ACbA,kBAAkB,mBAAO,CAAC,EAAY;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb,eAAe;AACf,eAAe;AACf,gBAAgB;;AAEhB;AACA,kBAAe;;;;;;;;ACrBf;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,GAAQ;;AAEpB,cAAc,6BAA8B;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;;AAEL;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;;;;;;;;ACjCA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4BAA4B;AAC5B;AACA;;;;;;;;ACvBA,aAAa,mBAAO,CAAC,GAAgB;;AAErC;AACA;AACA,yCAAyC;AACzC,KAAK;AACL;;;;;;;;;ACNY;;AAEZ,SAAS,mBAAO,CAAC,GAAI;AACrB,gBAAgB,mBAAO,CAAC,CAAY;AACpC,eAAe;;AAEf;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB,oBAAoB,aAAa,UAAU,OAAO;AAClD,eAAe,QAAQ;AACvB;AACA,aAAa,UAAU;AACvB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,+BAA+B;AAC/B,iCAAiC,oBAAoB,SAAS;;AAE9D;;;AAGA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA,eAAe,QAAQ;AACvB,aAAa,QAAQ;AACrB,sBAAsB,aAAa,UAAU,OAAO;AACpD;AACA;AACA,eAAe,QAAQ;AACvB;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iFAAiF;AACjF;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,iCAAiC;AACtE;AACA;AACA;;AAEA;;;;;;;;;AClPa;AACb,kBAAkB,mBAAO,CAAC,GAAY;;AAEtC;;AAEA;AACA,yBAAsB;;;;;;;;;ACNT;;AAEb,eAAe,mBAAO,CAAC,GAAU;AACjC,mBAAmB,mBAAO,CAAC,EAAyB;;AAEpD;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,gDAAgD,4BAA4B;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;;;;;;;;;AChMpB;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD,iBAAiB;AACnE,mDAAmD,gBAAgB;;AAEnE,oDAAoD,iBAAiB;AACrE,6DAA6D,gBAAgB;;AAE7E,mDAAmD,iBAAiB;AACpE,4DAA4D,gBAAgB;;AAE5E,wDAAwD,sCAAsC;AAC9F,iEAAiE,qCAAqC;;AAEtG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;AC5La;AACb,YAAY,mBAAO,CAAC,GAAqB;;AAEzC,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,qBAAqB;AACpE;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,+CAA+C;AAChF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,uCAAuC;AAClE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,2CAA2C;AACtE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,6BAA6B,uCAAuC;AACpE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,6CAA6C;AACxE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,2CAA2C;AAC1E;;AAEA;AACA;AACA;AACA;;;;;;;;;ACvMa;;AAEb,oBAAoB,mBAAO,CAAC,GAAoB;AAChD,cAAc,mBAAO,CAAC,GAAY;AAClC,aAAa,mBAAO,CAAC,GAAgB;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,cAAc,UAAU;AACxB,cAAc;AACd;AACA;;;;;;;;;;AClMa;;AAEb,mDAAwC;AACxC,2DAAkE;AAClE,iEAA8E;AAC9E,4DAAoE;AACpE,6DAAsE;AACtE,6DAAsE;AACtE,4DAAoE;AACpE,+DAA0E;AAC1E,uDAA0D;;;;;;;;;ACV7C;AACb,iBAAiB,mBAAO,CAAC,GAAU;AACnC,aAAa,mBAAO,CAAC,GAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mCAAmC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,8CAA8C;AAC9C;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,+CAA+C,sEAAsE;AACrH;;;;;;;;;AChxCa;;AAEb,oBAAoB;AACpB;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA,4BAA4B;AAC5B,yBAAyB;;AAEzB,6BAA6B;AAC7B;AACA;;AAEA,6BAA6B;AAC7B;AACA;;;;;;;;;;AClBA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;ACAA,MAAM,+BAA4B;;ACAlC,MAAM,6BAA4B;;ACAlC,MAAM,4BAA4B;;;;ACAlC,MAAM,8BAA4B;;ACAlC,MAAM,6BAA4B;;ACAN;AACJ;AACF;AACa;AACT;AACF;;AAExB;;AAEA;AACA,iBAAiB,wCAAe;;AAEhC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;;AAEA;AACA,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,UAAU;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA,oBAAoB,2CAAkB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kFAAkF;AAClF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG,yBAAyB,kCAAkC;AAC9D;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG,yBAAyB,+BAAM,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,+BAAM;AAC3B;AACA,iHAAiH,UAAU,IAAI,YAAY;AAC3I;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,+EAA+E,YAAY,UAAU,YAAY;AACjH;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,SAAS,kBAAkB;AAC3B,aAAa,kBAAkB;AAC/B,gBAAgB,kBAAkB;AAClC,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS;AACT,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qEAAqE,SAAS;AAC9E;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,+BAAM;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE,YAAY,QAAQ,eAAe;AACvG,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yEAAyE,WAAW,IAAI,YAAY;AACpG;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,YAAY,cAAc,YAAY;AACnF;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,4EAA4E,WAAW,IAAI,YAAY;AACvG;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,GAAG;AACf,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,+BAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,qBAAqB;AACrB,GAAG;AACH;AACA,4CAA4C;AAC5C,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,8BAA8B,WAAW,mBAAmB;AAC5D,GAAG,yBAAyB,+BAAM;AAClC;AACA;AACA;AACA,GAAG;AACH;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB;AACA,yBAAyB,MAAM;AAC/B;AACA;;AAEA;AACA,YAAY,MAAM;AAClB;AACA,yBAAyB,OAAO;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,QAAQ,kBAAkB;AAC1B,YAAY,kBAAkB;AAC9B,QAAQ,kBAAkB;AAC1B,WAAW,kBAAkB;AAC7B,QAAQ,kBAAkB;AAC1B,WAAW,kBAAkB;AAC7B,SAAS,kBAAkB;AAC3B,WAAW,kBAAkB;AAC7B,YAAY;AACZ,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;;AAE9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB,0CAAiB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,QAAQ,kBAAkB;AAC1B,WAAW,kBAAkB;AAC7B,OAAO,kBAAkB;AACzB,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC,YAAY,kBAAkB;AAC9B,UAAU;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,YAAY,gCAAO,IAAI,cAAa;;AAEpC;AACA,kBAAkB,kCAAS;AAC3B,mBAAmB,mCAAU;;AAE7B;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gDAAgD,kDAAyB;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B,MAAM;AAClC;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,WAAW,kBAAkB;AAC7B,QAAQ,kBAAkB;AAC1B,YAAY,kBAAkB;AAC9B,aAAa,kBAAkB;AAC/B,UAAU,kBAAkB;AAC5B,WAAW;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,wCAAe;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,gCAAO,IAAI,cAAa;;AAEtC;AACA,sBAAsB,2CAAkB;;AAExC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,8BAAK,GAAG,6BAAI;AAC5D;;AAEA;;AAEA;AACA;AACA;AACA,+CAA+C,wCAAe;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA,KAAK;AACL,IAAI;AACJ;;AAEA;AACA,uCAAuC,aAAa,kBAAkB,YAAY;AAClF;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,oFAAoF,SAAS;AAC7F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sGAAsG,YAAY;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D,YAAY;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAAiB;AAC5B,iBAAiB,0CAAiB;AAClC;;AAEA;AACA;AACA,qBAAqB,0CAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAkB;AACzC,OAAO;AACP,uBAAuB,8CAAqB;AAC5C;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,iCAAiC,oDAA2B;AAC5D,qBAAqB,oDAA2B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0CAAe,KAAK,EAAC;AAC6B;;;;;;;;;;;;;;;UCrpDlD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNO,MAAM,QAAQ,CAAC,MAAuB,OAAO;AAC7C,MAAM,QAAQ,CAAI,KAAU,OAAgB,QACjD,IAAI,MAAM,OAAO;AACZ,MAAM,SAAS,CAAI,KAAU,OAAe,WACjD,IAAI,OAAO,OAAO;AACb,MAAM,MAAM,CAAI,QAAqB,IAAI;AACzC,MAAM,OAAO,CAAC,QAAwB,IAAI;AAC1C,MAAM,QAAQ,CAAC,MACpB,MAAM,MAAM,CAAC,OAAO,MAAM,OAAO;AAC5B,MAAM,UAAU,CAAI,MAAyB,MAAM,QAAQ;AAC3D,MAAM,SAAS,CAAC,KAAa,OAAe,WACjD,IAAI,UAAU,OAAO,QAAS,WAAU,IAAI;AACvC,MAAM,SAAS,CAAC,KAAa,QAAwB,IAAI;AACzD,MAAM,MAAM,CAAC,GAAW,MAAuB,EAAE,SAAS;AAC1D,MAAM,SAAS,CAAC,GAAW,MAAc,EAAE,QAAQ;AACnD,MAAM,MAAM,CAAI,GAAQ,MAAkB,EAAE,SAAS;AACrD,MAAM,SAAS,CAAC,KAAa,WAClC,IAAI,WAAW;AACV,MAAM,OAAO,CAAC,KAAa,MAAuB,IAAI,SAAS;AAC/D,MAAM,UAAU,CAAC,KAAa,MAAc,OACjD,IAAI,MAAM,MAAM,KAAK;AAChB,MAAM,WAAW,CAAC,KAAa,MAAc,OAClD,IAAI,QAAQ,IAAI,OAAO,MAAM,MAAM;AAC9B,MAAM,OAAO,CAAI,QAAoB,IAAI;AACzC,MAAM,SAAS,CAAI,GAAQ,MAAgB,EAAE,OAAO;AACpD,MAAM,OAAO,CAAI,KAAU,QAAa,IAAI,KAAK,GAAG;AACpD,MAAM,SAAS,CAAI,KAAU,OAA+B,IAAI,KAAK;AACrE,MAAM,UAAU,CAAI,QAAa,IAAI;AACrC,MAAM,YAAY,CAAC,QAAgB,IAAI;AACvC,MAAM,YAAY,CAAC,QAAgB,IAAI;AACvC,MAAM,OAAO,CAAC,QAAgB,IAAI;AAClC,MAAM,YAAY,CAAC,QAAgB,IAAI;AACvC,MAAM,UAAU,CAAC,QAAgB,IAAI;AACrC,MAAM,SAAS,CAAC,KAAa,OAAe,IAAI,OAAO;AACvD,MAAM,WAAW,CAAC,QAAwB,IAAI,WAAW;AACzD,MAAM,WAAW,CAAC,QAAwB,OAAO,aAAa;AAC9D,MAAM,UAAU,CAAC,GAAW,MAAc,IAAI,KAAK,WAAY,KAAI;AACnE,MAAM,UAAU,CAAC,GAAW,MAAc,KAAK,MAAM,QAAQ,GAAG;AAChE,MAAM,QAAQ,CAAC,SAAgB,CAAC,GAAG,MAAM,MAAK;AAC9C,MAAM,UAAU,CAAC,MAAc,OAAO,KAAK;AAC3C,MAAM,YAAY,MAAM,IAAI,OAAO;AACnC,MAAM,MAAM,KAAK;AACjB,MAAM,MAAM,KAAK;AACjB,MAAM,MAAM,KAAK;AACjB,MAAM,MAAM,KAAK;AACjB,MAAM,MAAM,KAAK;AACjB,MAAM,MAAM,KAAK;AACjB,MAAM,OAAO,KAAK;AAClB,MAAM,OAAO,KAAK;AAClB,MAAM,OAAO,KAAK;AAClB,MAAM,OAAO,KAAK;AAClB,MAAM,OAAO,KAAK;AAClB,MAAM,OAAO,KAAK;AAClB,MAAM,OAAO,KAAK;AAClB,MAAM,QAAQ,KAAK;AACnB,MAAM,QAAQ,KAAK;AACnB,MAAM,OAAO,KAAK;AAClB,MAAM,OAAO,KAAK;AAClB,MAAM,OAAO,KAAK;AAClB,MAAM,OAAO,KAAK;AAClB,MAAM,QAAQ,KAAK;;;ACSnB,MAAM,aAAa;AAAA,EACxB,KAAK,EAAE,OAAO,IAAI,MAAM;AAAA,EACxB,YAAY;AAAA,EACZ,aAAa;AAAA,EACb,YAAY;AAAA,EACZ,aAAa;AAAA;AA2CR,MAAM,SAAG,GAEZ;AAAA,EACF,OAAO,EAAE,SAAS,CAAC;AAAA,EACnB,aAAa,EAAE,SAAS,CAAC;AAAA,EACzB,KAAK,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EAChC,KAAK,EAAE,UAAU,GAAG,SAAS,CAAC;AAAA,EAC9B,MAAM,EAAE,UAAU,GAAG,SAAS,CAAC;AAAA,EAC/B,KAAK,EAAE,UAAU,GAAG,SAAS;AAAA,EAC7B,KAAK,EAAE,UAAU,GAAG,SAAS;AAAA,EAC7B,KAAK,EAAE,UAAU,GAAG,SAAS;AAAA,EAC7B,KAAK,EAAE,UAAU,GAAG,SAAS;AAAA,EAC7B,MAAM,EAAE,UAAU,GAAG,SAAS;AAAA,EAC9B,MAAM,EAAE,UAAU,GAAG,UAAU,GAAG,SAAS;AAAA,EAC3C,KAAK,EAAE,UAAU,GAAG,SAAS;AAAA,EAC7B,KAAK,EAAE,UAAU,GAAG,SAAS;AAAA,EAC7B,MAAM,EAAE,UAAU,GAAG,SAAS;AAAA,EAC9B,MAAM,EAAE,UAAU,GAAG,SAAS;AAAA,EAC9B,SAAS,EAAE,YAAY;AAAA,EACvB,UAAU,EAAE,YAAY;AAAA,EACxB,SAAS,EAAE,YAAY,GAAG,SAAS;AAAA,EACnC,SAAS,EAAE,YAAY,GAAG,SAAS;AAAA,EACnC,SAAS,EAAE,YAAY,GAAG,SAAS;AAAA,EACnC,SAAS,EAAE,YAAY,GAAG,SAAS;AAAA,EACnC,UAAU,EAAE,YAAY,GAAG,SAAS;AAAA,EACpC,SAAS,EAAE,YAAY,GAAG,SAAS;AAAA,EACnC,SAAS,EAAE,YAAY,GAAG,SAAS;AAAA,EACnC,UAAU,EAAE,YAAY,GAAG,SAAS;AAAA,EACpC,UAAU,EAAE,YAAY,GAAG,SAAS;AAAA,EACpC,KAAK,EAAE,YAAY,GAAG,SAAS;AAAA,EAC/B,KAAK,EAAE,YAAY,GAAG,SAAS;AAAA,EAC/B,KAAK,EAAE,YAAY,GAAG,SAAS;AAAA,EAC/B,KAAK,EAAE,UAAU,GAAG,SAAS;AAAA,EAC7B,KAAK,EAAE,UAAU,GAAG,SAAS;AAAA,EAC7B,KAAK,EAAE,YAAY,GAAG,SAAS;AAAA,EAC/B,MAAM,EAAE,YAAY,GAAG,SAAS;AAAA,EAChC,OAAO,EAAE,UAAU,GAAG,UAAU,GAAG,SAAS;AAAA,EAC5C,OAAO,EAAE,YAAY,GAAG,SAAS;AAAA,EACjC,MAAM,EAAE,YAAY,GAAG,SAAS;AAAA,EAChC,MAAM,EAAE,YAAY,GAAG,SAAS;AAAA,EAChC,MAAM,EAAE,YAAY,GAAG,SAAS;AAAA,EAChC,OAAO,EAAE,YAAY,GAAG,SAAS;AAAA,EACjC,KAAK,EAAE,UAAU;AAAA,EACjB,IAAI,EAAE,UAAU;AAAA,EAChB,KAAK,EAAE,YAAY;AAAA,EACnB,KAAK,EAAE,YAAY,GAAG,SAAS;AAAA,EAC/B,KAAK,EAAE,YAAY,GAAG,SAAS;AAAA,EAC/B,KAAK,EAAE,YAAY,GAAG,SAAS;AAAA,EAC/B,KAAK,EAAE,YAAY,GAAG,SAAS;AAAA,EAC/B,MAAM,EAAE,YAAY,GAAG,SAAS;AAAA,EAChC,MAAM,EAAE,YAAY,GAAG,SAAS;AAAA,EAChC,OAAO,EAAE,YAAY,GAAG,SAAS;AAAA,EACjC,QAAQ,EAAE,YAAY,GAAG,SAAS,WAAW,SAAS,CAAC;AAAA,EACvD,SAAS,EAAE,YAAY,GAAG,SAAS,WAAW,SAAS,CAAC;AAAA,EACxD,QAAQ,EAAE,YAAY,GAAG,SAAS,WAAW,SAAS,CAAC;AAAA,EACvD,QAAQ,EAAE,YAAY,GAAG,SAAS,WAAW,SAAS,CAAC;AAAA,EACvD,SAAS,EAAE,YAAY,GAAG,SAAS,WAAW,SAAS,CAAC;AAAA,EACxD,SAAS,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EACpC,QAAQ,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EACnC,SAAS,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EACpC,QAAQ,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EACnC,QAAQ,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EACnC,SAAS,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EACpC,QAAQ,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EACnC,SAAS,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EACpC,SAAS,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EACpC,QAAQ,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EACnC,WAAW,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EACtC,KAAK,EAAE,UAAU,GAAG,SAAS;AAAA,EAC7B,KAAK,EAAE,YAAY,GAAG,SAAS;AAAA,EAC/B,KAAK,EAAE,YAAY,GAAG,SAAS;AAAA,EAC/B,KAAK,EAAE,YAAY,GAAG,SAAS;AAAA,EAC/B,MAAM,EAAE,YAAY,GAAG,SAAS;AAAA,EAChC,MAAM,EAAE,YAAY,GAAG,SAAS;AAAA,EAChC,MAAM,EAAE,YAAY,GAAG,SAAS;AAAA,EAChC,MAAM,EAAE,YAAY,GAAG,SAAS;AAAA,EAChC,MAAM,EAAE,YAAY,GAAG,SAAS;AAAA,EAChC,MAAM,EAAE,YAAY,GAAG,SAAS;AAAA,EAChC,KAAK,EAAE,SAAS,CAAC;AAAA,EACjB,MAAM,EAAE,SAAS,CAAC;AAAA,EAClB,KAAK,EAAE,YAAY,GAAG,QAAQ,CAAC,CAAC,OAAO,OAAO,UAAU,SAAS,CAAC;AAAA,EAClE,UAAU;AAAA,IACR,YAAY;AAAA,IACZ,QAAQ,CAAC,CAAC,OAAO;AAAA,IACjB,SAAS,CAAC,OAAO;AAAA;AAAA,EAEnB,UAAU,EAAE,YAAY,GAAG,QAAQ,CAAC,CAAC,OAAO,SAAS,SAAS,CAAC;AAAA,EAC/D,UAAU,EAAE,YAAY,GAAG,QAAQ,CAAC,CAAC,OAAO,UAAU,SAAS,CAAC;AAAA,EAChE,WAAW,EAAE,YAAY,GAAG,QAAQ,CAAC,OAAO,QAAQ,SAAS,CAAC;AAAA,EAC9D,KAAK;AAAA,IACH,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO,CAAC,OAAO;AAAA,IACxB,SAAS,CAAC;AAAA;AAAA,EAEZ,UAAU;AAAA,IACR,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO,OAAO,CAAC,OAAO;AAAA,IAC/B,SAAS,CAAC,OAAO;AAAA;AAAA,EAEnB,MAAM,EAAE,SAAS,CAAC;AAAA,EAClB,YAAY,EAAE,SAAS,CAAC;AAAA,EACxB,KAAK,EAAE,UAAU,GAAG,SAAS,CAAC;AAAA,EAC9B,KAAK,EAAE,UAAU,GAAG,SAAS,CAAC;AAAA,EAC9B,QAAQ,EAAE,UAAU,GAAG,UAAU;AAAA,EACjC,YAAY,EAAE,UAAU,GAAG,UAAU;AAAA,EACrC,QAAQ;AAAA,IACN,UAAU;AAAA,IACV,QAAQ,CAAC,OAAO,CAAC,OAAO,QAAQ;AAAA,IAChC,SAAS,CAAC,OAAO,OAAO;AAAA;AAAA,EAE1B,QAAQ;AAAA,IACN,UAAU;AAAA,IACV,QAAQ,CAAC,OAAO,CAAC,OAAO,QAAQ;AAAA,IAChC,SAAS,CAAC,OAAO,OAAO;AAAA;AAAA,EAE1B,MAAM,EAAE,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC,OAAO,QAAQ;AAAA,EACrD,OAAO;AAAA,IACL,UAAU;AAAA,IACV,QAAQ,CAAC,OAAO,CAAC,OAAO,QAAQ;AAAA,IAChC,SAAS,CAAC;AAAA;AAAA,EAEZ,QAAQ,EAAE,UAAU,GAAG,QAAQ,CAAC,OAAO;AAAA,EACvC,OAAO,EAAE,UAAU,GAAG,QAAQ,CAAC,OAAO;AAAA,EACtC,KAAK,EAAE,SAAS,CAAC;AAAA,EACjB,MAAM,EAAE,SAAS,CAAC;AAAA,EAClB,MAAM,EAAE,UAAU,GAAG,SAAS,MAAM,SAAS,CAAC;AAAA,EAC9C,YAAY,EAAE,UAAU,GAAG,SAAS,MAAM,SAAS,CAAC;AAAA,EACpD,KAAK,EAAE,UAAU;AAAA,EACjB,MAAM,EAAE,UAAU;AAAA,EAClB,OAAO,EAAE,UAAU;AAAA,EACnB,MAAM;AAAA,IACJ,YAAY;AAAA,IACZ,QAAQ;AAAA,MACN,CAAC,OAAO;AAAA,MACR,CAAC,OAAO;AAAA;AAAA,IAEV,SAAS,CAAC,OAAO;AAAA;AAAA,EAEnB,OAAO;AAAA,IACL,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO,OAAO;AAAA,IACvB,SAAS,CAAC;AAAA;AAAA,EAEZ,MAAM;AAAA,IACJ,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO;AAAA,IAChB,SAAS,CAAC;AAAA;AAAA,EAEZ,MAAM;AAAA,IACJ,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO;AAAA,IAChB,SAAS,CAAC;AAAA;AAAA,EAEZ,QAAQ;AAAA,IACN,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO,OAAO;AAAA,IACvB,SAAS,CAAC;AAAA;AAAA,EAEZ,QAAQ;AAAA,IACN,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO;AAAA,IAChB,SAAS,CAAC;AAAA;AAAA,EAEZ,SAAS;AAAA,IACP,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO;AAAA,IAChB,SAAS,CAAC;AAAA;AAAA,EAEZ,MAAM;AAAA,IACJ,UAAU;AAAA,IACV,UAAU;AAAA,IACV,QAAQ,CAAC,CAAC,OAAO,QAAQ,OAAO;AAAA,IAChC,SAAS,CAAC,OAAO;AAAA;AAAA,EAEnB,MAAM;AAAA,IACJ,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO,CAAC,OAAO;AAAA,IACxB,SAAS,CAAC,OAAO;AAAA;AAAA,EAEnB,OAAO;AAAA,IACL,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO,CAAC,OAAO;AAAA,IACxB,SAAS,CAAC,OAAO;AAAA;AAAA,EAEnB,MAAM;AAAA,IACJ,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO,CAAC,OAAO;AAAA,IACxB,SAAS,CAAC,OAAO;AAAA;AAAA,EAEnB,MAAM;AAAA,IACJ,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO,OAAO,CAAC,OAAO;AAAA,IAC/B,SAAS,CAAC,OAAO;AAAA;AAAA,EAEnB,SAAS,EAAE,YAAY,GAAG,QAAQ,CAAC,CAAC,OAAO,SAAS,SAAS,CAAC,OAAO;AAAA,EACrE,SAAS;AAAA,IACP,YAAY;AAAA,IACZ,QAAQ,CAAC;AAAA,IACT,SAAS,CAAC;AAAA;AAAA,EAEZ,SAAS;AAAA,IACP,YAAY;AAAA,IACZ,QAAQ,CAAC;AAAA,IACT,SAAS,CAAC;AAAA;AAAA,EAEZ,QAAQ;AAAA,IACN,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO;AAAA,IAChB,SAAS,CAAC;AAAA;AAAA,EAEZ,MAAM;AAAA,IACJ,YAAY;AAAA,IACZ,QAAQ,CAAC,CAAC,OAAO;AAAA,IACjB,SAAS,CAAC;AAAA;AAAA,EAEZ,WAAW;AAAA,IACT,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO,CAAC,OAAO,QAAQ;AAAA,IAChC,SAAS,CAAC;AAAA;AAAA,EAEZ,UAAU;AAAA,IACR,SAAS,CAAC;AAAA;AAAA,EAEZ,YAAY;AAAA,IACV,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO,CAAC,OAAO,QAAQ;AAAA,IAChC,SAAS,CAAC;AAAA;AAAA,EAEZ,WAAW;AAAA,IACT,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO,CAAC,OAAO,QAAQ;AAAA,IAChC,SAAS,CAAC;AAAA;AAAA,EAEZ,OAAO;AAAA,IACL,YAAY;AAAA,IACZ,QAAQ,CAAC,CAAC,OAAO;AAAA,IACjB,SAAS,CAAC;AAAA;AAAA,EAEZ,MAAM,EAAE,YAAY,GAAG,QAAQ,CAAC;AAAA,EAChC,MAAM,EAAE,YAAY,GAAG,QAAQ,CAAC;AAAA,EAChC,IAAI,EAAE,UAAU;AAAA,EAChB,KAAK,EAAE,UAAU;AAAA,EACjB,OAAO,EAAE,UAAU,GAAG,UAAU,GAAG,SAAS,WAAW,SAAS,CAAC;AAAA,EACjE,UAAU;AAAA,IACR,YAAY;AAAA,IACZ,QAAQ,CAAC,CAAC,OAAO,OAAO;AAAA,IACxB,SAAS,CAAC;AAAA;AAAA,EAEZ,OAAO,EAAE,YAAY,GAAG,QAAQ,CAAC,OAAO,QAAQ,SAAS,CAAC;AAAA,EAC1D,MAAM;AAAA,IACJ,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO,CAAC,OAAO,QAAQ;AAAA,IAChC,SAAS,CAAC;AAAA;AAAA,EAEZ,SAAS;AAAA,IACP,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO,OAAO;AAAA,IACvB,SAAS,CAAC;AAAA;AAAA,EAEZ,UAAU;AAAA,IACR,YAAY;AAAA,IACZ,QAAQ,CAAC,OAAO,OAAO;AAAA,IACvB,SAAS,CAAC;AAAA;AAAA,EAEZ,WAAW,EAAE,YAAY,GAAG,QAAQ,CAAC,OAAO,QAAQ,SAAS,CAAC;AAAA,EAC9D,SAAS,EAAE,YAAY,GAAG,QAAQ,CAAC,OAAO,QAAQ,SAAS,CAAC;AAAA,EAC5D,cAAc,EAAE,YAAY,GAAG,QAAQ,CAAC,QAAQ,SAAS,CAAC;AAAA,EAC1D,cAAc,EAAE,YAAY,GAAG,QAAQ,CAAC,QAAQ,SAAS,CAAC;AAAA,EAC1D,MAAM,EAAE,YAAY,GAAG,QAAQ,CAAC,QAAQ,SAAS,CAAC;AAAA,EAClD,cAAc,EAAE,YAAY,GAAG,QAAQ,CAAC,QAAQ,SAAS,CAAC;AAAA,EAC1D,YAAY,EAAE,YAAY,GAAG,QAAQ,CAAC,QAAQ,SAAS,CAAC;AAAA,EACxD,QAAQ,EAAE,YAAY,GAAG,QAAQ,CAAC,OAAO,QAAQ,SAAS,CAAC;AAAA,EAC3D,aAAa;AAAA,IACX,UAAU;AAAA,IACV,UAAU;AAAA,IACV,QAAQ,CAAC,CAAC,OAAO,QAAQ;AAAA,IACzB,SAAS,CAAC,OAAO,OAAO;AAAA;AAAA,EAE1B,MAAM,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EACjC,SAAS,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EACpC,OAAO,EAAE,UAAU,GAAG,UAAU,GAAG,QAAQ,CAAC,SAAS,SAAS,CAAC;AAAA,EAC/D,SAAS,EAAE,YAAY,GAAG,SAAS,CAAC;AAAA,EACpC,MAAM,EAAE,YAAY,GAAG,QAAQ,CAAC;AAAA,EAChC,OAAO,EAAE,YAAY,GAAG,QAAQ,CAAC,CAAC,OAAO,UAAU,SAAS,CAAC;AAAA,EAC7D,OAAO,EAAE,YAAY;AAAA,EACrB,OAAO;AAAA;AAGF,MAAM,WAAW;AAAA,EACtB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAGK,MAAM,YAAY;AAAA,EACvB,MAAM;AAAA,EACN,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AAAA,EACN,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AAAA,EACN,MAAM;AAAA,EACN,KAAK;AAAA,EACL,MAAM;AAAA,EACN,KAAK;AAAA;AAGA,MAAM,oBAAoB,CAAC,OAA4B;;;ACtbb;AACjD;AAEO,MAAM,QAAQ,CAAC,QACpB,IAAI,MAAM,SAAS,IAAI,IAAI,IAAI,MAAM;AAEhC,oBAAoB,IAAY,MAAc,QAAgB;AACnE,QAAM,EAAE,YAAY,UAAU,aAAa,SAAG,CAAC;AAC/C,QAAM,OAAO,CAAC,KAAa,WAAmB;AAAA,IAC/B;AAAA,MACX,GAAG;AAAA,MACH,GAAG,GAAG,YAAY,eAAe,WAAW,IAAI,MAAM,WAAW;AAAA,MACjE;AAAA;AAAA;AAGJ,MAAI,eAAe,QAAW;AAC5B,QAAI,SAAS,YAAY;AACvB,aAAO,KAAK,WAAW,cAAc;AAAA;AAAA,SAElC;AACL,QAAI,YAAY,CAAC,YAAY,OAAO,UAAU;AAC5C,aAAO,KAAK,YAAY,YAAY;AAAA,eAC3B,CAAC,YAAY,YAAY,OAAO,UAAU;AACnD,aAAO,KAAK,WAAW,YAAY;AAAA,eAC1B,YAAY,YAAa,QAAO,YAAY,OAAO,WAAW;AACvE,aAAO,KAAK,WAAW,gBAAgB,YAAY;AAAA;AAAA;AAAA;AAKlD,mBACL,IACA,MACA,QACA,aAAa,OACc;AAC3B,QAAM,EAAE,QAAQ,OAAO,SAAS,YAAY,SAAG,CAAC;AAChD,QAAM,OAAO,GAAG,CAAC;AACjB,MAAI,SAAS;AACX,UAAM,eAAe,KAAK,UACxB,OACE,CAAC,CAAC,GAAG,CAAC,MAAO,cAAa,CAAC,EAAE,KAAK,OAAK,MAAM,SAAS,EAAE,OAAO;AAEnE,QAAI,iBAAiB,IAAI;AACvB;AAAA;AAEF,UAAM,QAAQ,KAAK,cAAe,IAAI,OAAK,SAAS,CAAC,IAAI,KAAK;AAC9D,WAAO;AAAA,MACL,QAAQ,GAAG,wCAAwC,SAAS;AAAA;AAAA;AAGhE,MAAI,CAAC,OAAO;AACV;AAAA;AAEF,QAAM,iBAAiB,MACpB,IAAI,CAAC,MAAM,MAAM;AAChB,QAAI,KAAK,QAAQ,CAAC,KAAK,MAAM,SAAS,OAAO;AAC3C,aAAO;AAAA;AAET,UAAM,WAAW,KAAK;AACtB,QAAI,OAAO,CAAC,OAAO;AACjB,UACE,aACI,CAAC,GAAG,CAAC,aAAa,SAAS,KAAK,OAAK,GAAG,CAAC,MAAM,MAC/C,GAAG,CAAC,cAAc,KAAK,GAAG,CAAC,MAAM,SAAS,KAC9C;AACA,eAAO;AAAA;AAET,YAAM,QAAQ,SAAS,IAAI,OAAK,SAAS,CAAC;AAC1C,YAAM,QAAQ,KAAK,IAAI,OAAK,SAAS,CAAC,IAAI,KAAK;AAC/C,aAAO,YAAY,IAAI,qBAAqB,cAAc;AAAA,WACrD;AACL,UACE,aACI,CAAC,GAAG,CAAC,aAAa,GAAG,CAAC,UAAU,QAChC,GAAG,CAAC,cAAc,KAAK,SAAS,SAAS,IAC7C;AACA,eAAO;AAAA;AAET,YAAM,QAAQ,SAAS,IAAI,OAAK,SAAS,CAAC;AAC1C,aAAO,YAAY,IAAI,aAAa,SAAS,CAAC,cAAc;AAAA;AAAA,KAG/D,OAAO,OAAK,CAAC,CAAC;AACjB,SAAO,GAAG,CAAC,kBACP,eAAe,IAAI,OAAK,QAAgB,GAAG,WAC3C;AAAA;AAGC,MAAM,UAAU,CAAC,GAAW,WAAiC;AAAA,EAClE,GAAG;AAAA,EACH;AAAA,EACA;AAAA;AAGK,kBAAkB,QAAgB,OAAkC;AACzE,QAAM,QAAQ,MAAM,IAAI,OAAK,SAAS,CAAC,IAAI,KAAK;AAChD,SAAO;AAAA,IACL,QACE,2EAA2E,SAC3E;AAAA;AAAA;AAKC,kBAAkB,QAAgB,OAAkC;AACzE,QAAM,QAAQ,MAAM,IAAI,OAAK,SAAS,CAAC,IAAI,KAAK;AAChD,SAAO;AAAA,IACL,QACE,mEAAmE,SACnE;AAAA;AAAA;;;AC9GN;AAKO,qBACL,MACA,aACA,WACA,MACS;AACT,QAAM,WAAsB;AAC5B,QAAM,SAAgB;AACtB,QAAM,aAAuB;AAC7B,WAAS,IAAI,GAAG,MAAM,GAAG,CAAC,OAAO,IAAI,KAAK,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK;AACjB,QAAI,UAAU;AACd,QAAI,IAAI,QAAQ,OAAO;AAErB,eAAS,KAAK;AACd,YAAM,eAAsB;AAC5B,YAAM,iBAA4B;AAClC,eAAS,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,MAAM,QAAQ,EAAE,GAAG;AAChD,cAAM,OAAO,KAAK,IAAI,IAAI;AAC1B,cAAM,WAAU,KAAK,QAAQ,SAAS,GAAG,CAAC,aAAa,KAAK;AAC5D,iBAAS,KAAK;AACd,uBAAe,KAAK,CAAC,YAAW,IAAI,MAAM,SAAS;AACnD,YAAI,UAAS;AACX,iBAAO,KAAK,IAAI,MAAM,OAAO;AAAA,eACxB;AACL,cAAI,IAAI,MAAM,SAAS,IAAI;AACzB,yBAAa,KAAK,IAAI,MAAM,OAAO;AAAA;AAAA;AAAA;AAIzC,UAAI,MAAM,SAAS;AACnB,UAAI,MAAM,WAAW;AACrB,WAAK,IAAI,MAAM;AACf;AAAA,eACS,IAAI,QAAQ,SAAS,IAAI,QAAQ,OAAO;AACjD,iBAAW,KAAK,IAAI;AAAA,eACX,WAAW,YAAY,KAAK,IAAI,MAAM,OAAO,KAAK,IAAI,KAAK;AACpE,aAAO,KAAK;AACZ,gBAAU;AAAA;AAEZ,aAAS,KAAK;AAAA;AAEhB,SAAO,EAAE,MAAM,QAAQ,GAAG,CAAC,OAAO,UAAU;AAAA;AAKvC,uBACL,EAAE,MAAM,QAAQ,UAAU,UAC1B,MACA,SACM;AACN,MAAI,CAAC,GAAG,CAAC,UAAU;AACjB,WAAO,EAAE,MAAM,KAAK;AAAA;AAEtB,QAAM,MAAa;AACnB,QAAM,UAAU,OAAO,IAAI,OAAK,EAAE;AAClC,WAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,QAAI,SAAS,IAAI;AACf,UAAI,KAAK;AAAA,QACP,KAAK;AAAA,QACL,OAAO,QAAQ;AAAA,QACf,QAAQ,QAAQ;AAAA;AAAA,WAEb;AACL,UAAI,KAAK,KAAK;AAAA;AAAA;AAGlB,SAAO,EAAE,MAAM;AAAA;AAMjB,oBAAoB,YAAsB,MAAW,MAAmB;AACtE,QAAM,WACJ,QAAQ,KAAK,QAAQ,SAAS,KAAK,MAAM,MAAM,SAAS,KAAK,QAAQ;AACvE,SACE,YACC,KAAK,QAAQ,SAAS,CAAC,GAAG,CAAC,YAAY,KAAK,SAC5C,KAAK,QAAQ,SAAS,CAAC,GAAG,CAAC,YAAY,KAAK;AAAA;;;ACrFoB;AAC7B;AACL;AACnC,MAAM,EAAE,GAAG,aAAE,IAAI,cAAE,IAAI,cAAE,KAAK,eAAE,MAAM,mBAAK,0BAAE;AAC7C,MAAM,EAAE,IAAI,cAAE,MAAM,gBAAE,GAAG,aAAE,MAAM,gBAAE,MAAM,gBAAE,MAAM,mBAAK,0BAAE;AACxD,MAAM,EAAE,KAAK,eAAE,GAAG,aAAE,KAAK,kBAAK,0BAAE;AAChC;AACA;AASA,MAAM,UAAe,EAAE,GAAG,QAAQ,GAAG;AACrC,MAAM,WAAgB,EAAE,GAAG,QAAQ,GAAG;AAKtC,MAAM,UAAU,CAAC,SACf,CAAC,CAAC,QAAQ,YAAY;AACxB,MAAM,QAAQ,CAAC,MAAY,MAAM,MAAM;AACrC,MAAI,QAAQ,OAAO;AACjB,WAAO;AAAA;AAET,QAAM,MAAM,KAAK;AACjB,SAAQ,QAAQ,QAAQ,SAAG,CAAC,CAAC,OAAO,QAAQ,IAAI,QAAQ,IAAI,QAAS;AAAA;AAEvE,MAAM,YAAY,CAAC,EAAE,KAAK,WACxB,QAAQ,QAAQ,IAAI,UAAU;AAChC,kBAAkB,OAAuB;AACvC,QAAM,OAAO,MAAM,OAAO;AAC1B,QAAM,YAAY,SAAG,CAAC,CAAC,KAAK,MAAM;AAClC,MAAI,WAAW;AACb,YAAQ,WAAK,CAAC,OAAO;AAAA;AAEvB,SAAO,GAAG,YAAY,OAAO,MAAM,MAChC,IAAI,OAAM,QAAQ,KAAK,UAAU,KAAK,SAAS,IAC/C,KAAK;AAAA;AAIV,MAAM,aAAa,CAAC,gBAA4C;AAC9D,MAAI,SAAG,CAAC,iBAAiB,GAAG;AAC1B,WAAO,UAAI,CAAC;AAAA;AAEd,QAAM,UAAU,YAAY,SAAG,CAAC,eAAe;AAC/C,QAAM,gBAAgB,WAAK,CAAC,aAAa,GAAG,SAAG,CAAC,eAAe;AAC/D,QAAM,SAAoB;AAAA,IACxB,KAAK;AAAA,IACL,OAAO,SAAG,CAAC;AAAA,IACX,QAAQ,QAAQ,GAAG;AAAA;AAErB,SAAO,UAAI,CAAC,CAAC,GAAG,eAAe,CAAC,SAAS;AAAA;AAGpC,kBACL,MACA,UACA,eAAe,MACf,eAAe,OACf;AACA,QAAM,SAAkB;AACxB,QAAM,UAAU,CAAC,OAAe,SAAG,CAAC,cAAc;AAClD,MAAI,CAAC,UAAU,MAAM,KAAK,cAAc,CAAC,OAAO,GAAG,GAAG,CAAC,GAAG;AAC1D,MAAI,CAAC,UAAU,UAAU,SAAS,CAAC,OAAO,OAAO;AACjD,WAAS,IAAI,GAAG,IAAI,UAAI,CAAC,OAAO,IAAI,GAAG,EAAE,GAAG;AAC1C,UAAM,IAAI,YAAM,CAAC,MAAM,IACrB,SAAS,IAAI,MAAM,IAAI,YAAM,CAAC,MAAM,IAAI,KAAK;AAC/C,MAAE;AACF,QAAI,MAAM,QAAQ,UAAU;AAC1B,aAAO,SAAG,CAAC,UAAU,GAAG,QAAQ,eAC5B,EAAE,GAAG,MAAM,GAAG,KAAM,GAAG,MAAM,KAAK,MAAM,WACvC,YAAW,OAAO,OAAO,KAAK,YAC/B,KAAK;AACT,QAAE;AACF,QAAE;AACF;AAAA;AAEF,UAAM,SAAiB,EAAE,UAAU,MAAM;AACzC,QAAI,MAAM,KAAK;AACb,UAAK,WAAW,CAAC,UAAW;AAC1B,qBAAa,CAAC,MAAM;AACpB,eAAO,KAAK,EAAE,KAAK,OAAO,MAAM,IAAI;AAAA;AAEtC,iBAAW,WAAW;AACtB;AAAA;AAEF,UAAM,UAAU,SAAG,CAAC,WAAY;AAChC,QAAI,CAAC,YAAY,SAAS;AACxB,iBAAW;AACX,8BAAa,MAAM;AACnB,UAAI,MAAM,MAAM;AACd,UAAE;AACF,cAAM;AAAA;AAER;AAAA;AAEF,QAAI,CAAC,YAAY,MAAM,KAAK;AAC1B,YAAM,KAAK,YAAM,CAAC,YAAM,CAAC,MAAM,EAAE,IAAI;AACrC,YAAM,OAAO,YAAM,CAAC,MAAM,GAAG,KAAK,IAAI,KAAK,IAAI;AAC/C,WAAK,UAAI,CAAC;AACV,QAAE;AACF,YAAM;AACN,UAAI,cAAc;AAChB,eAAO,KAAK,EAAE,KAAK,OAAO,MAAM;AAAA;AAElC;AAAA;AAEF,UAAM,UAAU,SAAG,CAAC,UAAU;AAE9B,QAAI,YAAY,CAAC,QAAQ,IAAI;AAC3B,YAAM,WAAW,MAAM,OAAO,OAAO,SAAG,CAAC,UAAU,GAAG,SAAS;AAC/D,cAAQ,SAAS;AACjB,iBACG,MAAM,OAAO,OAAO,SAAG,CAAC,UAAU,GAAG,SAAS,OAC9C,MAAM,OAAO,CAAC,SAAG,CAAC,OAAO,SAAG,CAAC,UAAU,GAAG,MAAM,QAChD,SAAU,aAAY,SAAG,CAAC,gBAAgB;AAC7C,UAAI,CAAC,YAAY,CAAC,WAAW,CAAC,SAAS;AACrC,mBAAW;AACX,eAAO,SAAG,CAAC,UAAU,GAAG,MAAM;AAAA;AAAA;AAIlC,QAAI,YAAY,SAAS;AACvB,iBAAW;AAAA;AAGb,QAAI,CAAC,YAAY,CAAC,YAAY,CAAC,UAAU;AACvC,UAAI,SAAS;AACX,cAAM,OAAO,YAAM,CAAC,OAAO,OAAO,KAAK,MAAM;AAC7C,eAAO,KAAK,EAAE,KAAK,MAAM,MAAM,eAAe,OAAO,GAAG;AACxD,YAAI,gBAAiB,OAAM,OAAO,MAAM,MAAM;AAC5C,iBAAO,KAAK,EAAE,KAAK,OAAO,MAAM,MAAM,MAAM,QAAQ,QAAQ;AAAA;AAE9D;AAAA;AAEF,iBACE,QAAQ,MACP,MAAM,OAAO,QAAQ,WACrB,MAAM,OAAQ,SAAQ,WAAW,WAAW;AAC/C,cAAQ,WAAW,CAAC;AACpB,YAAM,MAAoB,WAAW,QAAQ;AAC7C,aAAO,KAAK,EAAE,KAAK,MAAM,IAAI;AAAA;AAE/B,WAAO,SAAG,CAAC,UAAU,GAAG,QAAQ;AAAA;AAElC,SAAO,EAAE,QAAQ,aAAa,WAAW,aAAa;AAAA;AAIxD,iBAAiB,QAAyB;AACxC,QAAM,QAAgB;AACtB,QAAM,WAAW,CAAC,YAA0B;AAC1C,QAAI;AACJ,QAAI,QAAO,GAAG,QAAQ,SAAS,SAAG,CAAC,MAAM,QAAO,GAAG,OAAO;AACxD,eAAS,QAAO;AAAA;AAElB,UAAM,QAAQ,QAAO;AACrB,QAAI,MAAM,QAAQ,OAAO,MAAM,QAAQ,KAAK;AAC1C,aAAO;AAAA;AAET,UAAM,SAAgB,SAAS,CAAC,UAAU;AAC1C,WAAO,QAAO,GAAG,QAAQ,KAAK;AAC5B,aAAM,KAAK,SAAS;AAAA;AAEtB,YAAO;AACP,WAAO;AAAA;AAET,SAAO,SAAG,CAAC,SAAS;AAClB,UAAM,KAAK,SAAS;AAAA;AAEtB,SAAO;AAAA;AAMT,sBACE,OACuE;AACvE,QAAM,QAAyC;AAC/C,QAAM,UAAkB;AACxB,QAAM,QAAQ,UAAQ;AACpB,QAAI,CAAC,QAAQ,SAAS,QAAQ,KAAK,OAAO,MAAM,UAAU,YAAY;AACpE,YAAM,OAAO,MAAM,MAAM;AACzB,UAAI,CAAC,MAAM;AACT,cAAM,KAAK,EAAE,KAAK,qBAAqB,QAAQ,KAAK,GAAG;AAAA,iBAC9C,SAAG,CAAC,QAAQ,GAAG;AACxB,cAAM,KAAK,EAAE,KAAK,uBAAuB,QAAQ,KAAK,GAAG;AAAA;AAE3D,YAAM,KAAK,EAAE,MAAM,OAAO,WAAK,CAAC,MAAM;AAAA,WACjC;AACL,cAAQ,KAAK;AAAA;AAAA;AAGjB,MAAI,SAAG,CAAC,UAAU;AAChB,UAAM,KAAK,EAAE,MAAM,SAAS,OAAO;AAAA;AAErC,SAAO;AAAA;AAGT,MAAM,YAAY,CAAC,MAAY,WAC7B,QAAQ,QAAQ,SAAS,MAAM,UAAU,UAAU,MAAM;AAE3D,mBACE,OACA,QACA,eAAe,MACF;AACb,MAAI,CAAC,SAAG,CAAC,QAAQ;AACf,WAAO;AAAA;AAET,QAAM,aAAa,CAAC,SAAe,UAAU,MAAM;AACnD,MAAI,YAAY,MAAM;AACtB,MAAI,OAAO,WAAW;AACtB,QAAM,EAAE,WAAW,KAAK;AACxB,MAAI,QAAQ,cAAc,UAAU,QAAQ,OAAO;AAEjD,QAAI,UAAU,QAAQ,SAAG,EAAE;AACzB,YAAM,EAAE,YAAY,aAAa,SAAG,CAAC,UAAU;AAC/C,YAAM,IAAI,cAAc;AACxB,UAAI,KAAK,MAAM,KAAK,SAAG,CAAC,SAAS,MAAM,GAAG;AACxC,cAAM,QAAQ;AACd,oBAAY,EAAE,KAAK,OAAO,MAAM,KAAK,QAAQ,UAAU;AAAA;AAAA;AAG3D,QAAI,SAAG,CAAC,CAAC,OAAO,QAAQ,UAAU,SAAS,SAAG,CAAC,UAAU,SAAG,CAAC,SAAS,GAAG;AACvE,YAAM,QAAQ;AACd,YAAM,KAAK,EAAE,KAAK,OAAO,MAAM,KAAK,QAAQ,UAAU;AACtD,kBAAY,EAAE,KAAK,OAAO,MAAM,KAAK,QAAQ,UAAU;AAAA;AAEzD,UAAM,EAAE,MAAM,IAAI,oBAAW;AAC7B,UAAM,MAAM,CAAC,GAAW,OAAO,YAAW;AAAA,MAC7B,EAAE,KAAK,OAAO,OAAO,GAAG,QAAQ;AAAA;AAG7C,QAAI,SAAG,CAAC,CAAC,MAAM,OAAO,QAAQ,UAAU,UAAU,OAAO,CAAC,SAAG,CAAC,QAAQ;AACpE,aAAO,IAAI;AAAA,eACF,SAAG,CAAC,CAAC,MAAM,QAAQ,KAAK;AACjC,UAAI,SAAG,CAAC,WAAW,GAAG;AACpB,eAAO,IAAI;AAAA,iBACF,SAAG,CAAC,SAAS,GAAG;AACzB,eAAO,IAAI,oCAAoC,SAAG,CAAC;AAAA;AAErD,YAAM,SAAS,MAAM,IAAI;AACzB,YAAM,CAAC,MAAM,WAAW;AACxB,UAAI,UAAU,OAAO;AACrB,YAAM,MAAM,OAAO,SAAS;AAAA,QACrB,EAAE,KAAK,OAAO,OAAO,EAAE,GAAG,QAAQ,GAAG,OAAO;AAAA,QAC5C,EAAE,KAAK,OAAO,OAAO,GAAG;AAAA;AAE/B,UAAI,CAAC,SAAS;AACZ,kBAAU,CAAC,EAAE,KAAK,OAAO,OAAO,SAAS;AAAA;AAE3C,aAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAI,OAAO;AAAA,QACX,EAAE,KAAK,MAAM,OAAO,SAAG,CAAC,WAAW,GAAG;AAAA,QACtC,GAAG;AAAA,QACH,EAAE,KAAK,OAAO,OAAO,SAAG,CAAC,UAAU;AAAA,QACnC,GAAG;AAAA;AAAA,eAEI,OAAO,UAAU,OAAO,UAAU;AAC3C,UAAI,SAAG,CAAC,WAAW,GAAG;AACpB,eAAO,IAAI;AAAA;AAEb,YAAM,SAAS,MAAM,IAAI;AACzB,YAAM,CAAC,MAAM,QAAQ,CAAC,OAAO,IAAI,WAAK,CAAC,QAAQ;AAC/C,YAAM,UAAU,WAAW;AAC3B,aAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAI,OAAO,WACP;AAAA,UACO,EAAE,KAAK,OAAO,OAAO,EAAE,GAAG,QAAQ,GAAG;AAAA,UACrC,EAAE,KAAK,OAAO,OAAO;AAAA,YAE5B;AAAA,QACJ,EAAE,KAAK,MAAM,OAAO,SAAG,CAAC,WAAW,GAAG;AAAA,QACtC,GAAG;AAAA,QACH,EAAE,KAAK,OAAO,OAAO,GAAG;AAAA,QACxB,EAAE,KAAK,OAAO,OAAO,SAAS;AAAA;AAAA,eAEvB,OAAO,SAAS;AACzB,YAAM,SAAS,MAAM,IAAI;AACzB,YAAM,CAAC,MAAM,SAAQ,CAAC,OAAO,IAAI,WAAK,CAAC,QAAQ;AAC/C,YAAM,YAAyB,SAAG,CAAC,SAAQ,IAAI,MAAK,QAAS;AAC7D,UAAI,CAAC,SAAG,CAAC,QAAO;AACd,eAAO,IAAI;AAAA;AAEb,YAAM,UAAU,SAAG,CAAC;AACpB,UAAI,WACF,MAAK,OAAO,CAAC,KAAK,MAAM,MAAM,SAAG,CAAC,IAAI,KACrC,WAAU,UAAU,KACrB,SAAG,CAAC;AACN,YAAM,OAAmB;AACzB,aAAO,SAAG,CAAC,SAAQ,GAAG;AACpB,cAAM,CAAC,GAAG,QAAQ,CAAC,MAAK,SAAU,MAAK;AACvC,kBAAI,CAAC,MAAK;AACV,aAAI,KAAK,EAAE,KAAK,OAAO,OAAO,SAAG,CAAC,QAAQ,GAAG;AAC7C,kBAAI,CAAC,MAAK;AACV,oBAAY,SAAG,CAAC,KAAK,SAAG,CAAC,QAAQ;AACjC,aAAI,KAAK,EAAE,KAAK,OAAO,OAAO,UAAU;AAAA;AAE1C,UAAI,SAAG,CAAC,YAAY;AAClB,kBAAI,CAAC,MAAK;AAAA,aACL;AACL,aAAI,KAAK,EAAE,KAAK,OAAO,OAAO,GAAG;AACjC,aAAI,KAAK,EAAE,KAAK,OAAO,OAAO,UAAU;AAAA;AAE1C,aAAO;AAAA,eACE,OAAO,SAAS;AACzB,UAAI,SAAG,CAAC,SAAS,GAAG;AAClB,eAAO,IAAI;AAAA;AAEb,YAAM,OAAO,WAAW,MAAM;AAC9B,YAAM,OAAO,UAAI,CAAC,MAAM,IAAI;AAC5B,aAAO,CAAC,GAAG,MAAM,EAAE,KAAK,OAAO,OAAO,SAAG,CAAC,OAAO,mBAAU,GAAG;AAAA,eACrD,OAAO,SAAS,OAAO,QAAQ,OAAO,SAAS;AACxD,YAAM,QAAO,MAAM,IAAI;AACvB,UAAI,SAAG,CAAC,SAAQ,GAAG;AACjB,eAAO,IAAI;AAAA;AAEb,YAAM,OAAmB;AACzB,UAAI,OAAO,SAAS;AAClB,cAAM,CAAC,OAAM,QAAQ,CAAC,MAAK,IAAI,WAAK,CAAC,OAAM;AAC3C,cAAM,WAAW,WAAW;AAC5B,cAAM,QAAQ,SAAG,CAAC,YAAY;AAC9B,cAAM,SAAS,CAAE,UAAG,CAAC,SAAQ,SAAG,CAAC,YAAY;AAC7C,aAAI,KAAK,EAAE,KAAK,OAAO,OAAO,SAAS;AACvC,kBAAI,CAAC,MAAK;AACV,aAAI,KAAK,EAAE,KAAK,MAAM,OAAO,OAAO;AACpC,aAAI,KAAK,EAAE,KAAK,OAAO,OAAO,GAAG;AACjC,kBAAI,CAAC,MAAK;AACV,aAAI,KAAK,EAAE,KAAK,OAAO,OAAO,QAAQ;AACtC,eAAO;AAAA;AAET,UAAI,WAAW,MAAK,OAAO,CAAC,KAAK,MAAM,MAAM,SAAG,CAAC,IAAI;AACrD,kBAAY,SAAG,CAAC;AAChB,kBAAY,WAAK,CAAC,OAAO;AACzB,YAAM,OAAM,OAAO,QAAQ,OAAO;AAClC,eAAS,IAAI,GAAG,IAAI,SAAG,CAAC,QAAO,EAAE,GAAG;AAClC,kBAAI,CAAC,MAAK,MAAK;AACf,oBAAY,SAAG,CAAC,MAAK;AACrB,aAAI,KAAK,EAAE,WAAK,OAAO,UAAU;AACjC,UAAE;AAAA;AAEJ,UAAI,OAAO,OAAO;AAChB,kBAAI,CAAC,MAAK;AAAA,UACR,EAAE,KAAK,OAAO,OAAY,EAAE,GAAG,QAAQ,GAAG,QAAQ;AAAA,UAClD,EAAE,KAAK,OAAO,OAAO,GAAG;AAAA;AAAA;AAG5B,WAAI,KAAK,EAAE,KAAK,OAAO,OAAO,UAAU;AACxC,aAAO;AAAA,eACE,OAAO,QAAQ;AACxB,UAAI,SAAG,CAAC,SAAS,GAAG;AAClB,eAAO,IAAI;AAAA;AAEb,YAAM,SAAS,MAAM,IAAI;AACzB,YAAM,UAAU,MAAM;AACtB,YAAM,OAAO,WAAW,WAAK,CAAC,QAAQ;AACtC,UAAI,CAAC,QAAQ,UAAU;AACrB,eAAO,IAAI;AAAA;AAGb,YAAM,OAAmB;AAAA,QACvB,EAAE,KAAK,OAAO,OAAO,EAAE,GAAG,OAAO,GAAG,KAAK;AAAA,QACzC,EAAE,KAAK,OAAO,OAAO,QAAQ,MAAM;AAAA,QACnC,GAAG,OAAO;AAAA,QACV,EAAE,KAAK,OAAO,OAAO,QAAQ,OAAO,UAAU;AAAA,QAC9C,EAAE,KAAK,OAAO,OAAO,GAAG;AAAA,QACxB,GAAG;AAAA,QACH,EAAE,KAAK,OAAO,OAAO,QAAQ,MAAM;AAAA,QACnC,EAAE,KAAK,OAAO,OAAO,EAAE,GAAG,QAAQ,GAAG,SAAS;AAAA,QAC9C,EAAE,KAAK,OAAO,OAAO,GAAG;AAAA,QACxB,EAAE,KAAK,OAAO,OAAO,QAAQ,MAAM;AAAA,QACnC,EAAE,KAAK,OAAO,OAAO,QAAQ,OAAO,UAAU;AAAA,QAC9C,EAAE,KAAK,OAAO,OAAO,EAAE,GAAG,QAAQ,GAAG,OAAO;AAAA,QAC5C,EAAE,KAAK,OAAO,OAAO,GAAG;AAAA,QACxB,EAAE,KAAK,MAAM,OAAO,GAAG;AAAA,QACvB,EAAE,KAAK,OAAO,OAAO,GAAG;AAAA,QACxB,EAAE,KAAK,OAAO,OAAO,CAAE,UAAG,CAAC,QAAQ,KAAK;AAAA;AAE1C,aAAO;AAAA,eACE,OAAO,SAAS,OAAO,OAAO;AACvC,YAAM,OAAO,MAAM,OAAO,CAAC,GAAG,MAAM,CAAE,KAAI;AAC1C,YAAM,OAAO,MAAM,OAAO,CAAC,GAAG,MAAM,CAAC,CAAE,KAAI;AAC3C,UAAI,CAAC,SAAG,CAAC,OAAO;AACd,eAAO,IAAI;AAAA,iBACF,SAAG,CAAC,QAAQ,SAAG,CAAC,OAAO;AAChC,eAAO,IAAI;AAAA;AAEb,YAAM,OAAmB;AACzB,YAAM,YAAY,GAAG;AACrB,eAAS,IAAI,GAAG,MAAM,SAAG,CAAC,OAAO,IAAI,KAAK,EAAE,GAAG;AAC7C,kBAAI,CAAC,MAAK,WAAW,KAAK;AAC1B,cAAM,MAAM,KAAK;AACjB,YAAI,QAAQ,MAAM;AAChB,gBAAM,SAAS,UAAU,KAAK,IAAI;AAClC,cAAI,SAAG,CAAC,UAAU,KAAK,OAAO,GAAG,QAAQ,OAAO;AAC9C,mBAAO,IAAI,WAAW,OAAO,GAAG;AAAA;AAElC,eAAI,KAAK,EAAE,KAAK,IAAI,OAAO,OAAO,GAAG,OAAO;AAAA,eACvC;AACL,gBAAM,EAAE,OAAO,WAAW,YAAY,CAAC,MAAM;AAC7C,cAAI,SAAG,CAAC,SAAS;AACf,mBAAO;AAAA;AAET,cAAI,CAAC,SAAG,CAAC,QAAQ;AACf,mBAAO,IAAI;AAAA;AAEb,gBAAM,OAAM,OAAO,QAAQ,QAAQ;AACnC,eAAI,KAAK,EAAE,WAAK,OAAO,OAAO;AAAA;AAAA;AAGlC,aAAO;AAAA,eACE,OAAO,UAAU,OAAO,QAAQ;AAEzC,UAAI,SAAG,CAAC,SAAS,GAAG;AAClB,eAAO,IAAI;AAAA;AAEb,YAAM,SAAS,MAAM,IAAI;AACzB,YAAM,CAAC,KAAK,MAAM,SAAQ,CAAC,OAAO,GAAG,IAAI,OAAO,IAAI,WAAK,CAAC,QAAQ;AAClE,UAAI,IAAI,QAAQ,OAAO;AACrB,eAAO,IAAI,mCAAmC,IAAI;AAAA;AAEpD,YAAM,OAAa,CAAC,EAAE,KAAK,OAAO,OAAO,IAAI,OAAO;AACpD,gBAAI,CAAC,MAAK,CAAC,GAAG,UAAI,CAAC,QAAO,GAAG;AAC7B,WAAI,KAAK,EAAE,KAAK,OAAO,OAAO,SAAG,CAAC,SAAQ,GAAG;AAC7C,YAAM,OAAM,OAAO,SAAS,QAAQ;AACpC,WAAI,KAAK,EAAE,WAAK,OAAO,IAAI,OAAO;AAClC,aAAO;AAAA,eACE,OAAO,OAAO,OAAO,OAAO,OAAO,MAAM;AAClD,YAAM,OAAoB;AAC1B,YAAM,OAAO,SAAS,CAAC,WAAW,GAAG;AACrC,YAAM,YAAsB;AAC5B,YAAM,cAAc,WAAK,CAAC,QAAQ,IAAI,OAAK,EAAE;AAC7C,UAAI,aAAa;AACjB,UAAI,OAAO,MAAM;AACf,cAAM,eAAe,YAAY,OAAO;AACxC,kBAAI,CACF,WACA,aAAa,MAAM,IAAI,OAAK,EAAE;AAEhC,kBAAI,CAAC,QAAQ,aAAa;AAC1B,kBAAI,CAAC,MAAM,aAAa;AACxB,YAAI,CAAC,SAAG,CAAC,QAAQ;AACf,iBAAO,IAAI;AAAA;AAEb,qBAAa,SAAG,CAAC,WAAW;AAC5B,cAAM,QAAQ,EAAE,KAAK,OAAO,MAAM,MAAM;AAAA;AAG1C,UAAI,OAAO,KAAK;AACd,cAAM,WAAW,MAAM,OAAO;AAC9B,YAAI,SAAG,CAAC,QAAQ,EAAE,WAAW;AAC3B,gBAAM,EAAE,oBAAW,MAAM;AACzB,iBAAO,IACL,IAAI,mDACJ;AAAA;AAGJ,gBAAQ;AAAA,UACN,EAAE,KAAK,OAAO,MAAM,OAAO;AAAA,UAC3B,GAAG;AAAA,UACH,EAAE,KAAK,OAAO,MAAM,QAAQ;AAAA;AAAA;AAGhC,gBAAI,CAAC,MAAM,UAAU,OAAO,QAAQ,OAAO;AAC3C,YAAM,OAAc,KAAK,OAAO,OAAK,EAAE,QAAQ;AAC/C,YAAM,SAAS,KAAK,OAAO,OAAK,EAAE,QAAQ;AAC1C,UAAI,SAAG,CAAC,SAAS;AACf,eAAO;AAAA;AAGT,UAAI,YAAY;AACd,aAAK;AACL,aAAK;AAAA;AAEP,YAAM,QAAQ,WAAW,CAAC,MAAM,aAAa,WAAW;AACxD,aAAO,CAAC,EAAE,KAAK,OAAO,OAAO,mBAAU,GAAG;AAAA,eACjC,OAAO,MAAM;AACtB,YAAM,WAAW,MAAM,OAAO,CAAC,KAAK,SAAS,CAAC,MAAM;AACpD,YAAM,SAAS,UAAU,UAAU;AACnC,aAAO;AAAA;AAIT,QAAI,SAAG,CAAC,OAAO,cAAc;AAC3B,YAAM,SAAS,UAAU,CAAC,IAAI,SAAG,CAAC,QAAQ;AAC1C,YAAM,OAAM,CAAC,OAAe,OAAO,YAAW;AAAA,QACjC,EAAE,KAAK,OAAO,OAAO,QAAQ;AAAA;AAE1C,gBAAI,CAAC,MAAM,QAAQ,IAAI,OAAK,KAAI,EAAE,GAAG,OAAO;AAC5C,UAAI,CAAC,QAAQ;AAEX,YAAI,SAAG,CAAC,WAAW,KAAK,SAAG,CAAC,OAAO,OAAO;AACxC,iBAAO,WAAW,EAAE,KAAK,OAAO,MAAM,OAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAM3D,QAAM,OAAO,MAAM,IAAI;AACvB,QAAM,MAAmB,UAAI,CAAC;AAC9B,MAAI,MAAM,CAAC,gBAAgB,UAAU;AACnC,WAAO,CAAC,GAAG,KAAK,EAAE,KAAK,OAAO,OAAO,CAAC,CAAC,SAAG,CAAC,OAAO;AAAA,aACzC,SAAG,CAAC,UAAU,KAAK,KAAK,GAAG,QAAQ,OAAO;AAEnD,UAAM,EAAE,OAAO,GAAG,oBAAW,KAAK;AAClC,SAAK,KAAK,EAAE,KAAK,OAAO,OAAO,EAAE,GAAG,OAAO,KAAK;AAAA;AAElD,YAAI,CAAC,KAAK;AACV,QAAM,MAAM,SAAG,CAAC,QAAQ,KAAK,SAAG,CAAC,CAAC,OAAO,QAAQ,KAAK,GAAG,OAAO,QAAQ;AACxE,SAAO,CAAC,GAAG,KAAK,EAAE,KAAK,OAAO,SAAG,CAAC,OAAO;AAAA;AAG3C,kBAAkB,MAAY,QAAkC;AAC9D,MAAI,QAAQ,OAAO;AACjB,UAAM,EAAE,WAAW;AACnB,QAAI,KAAK,QAAQ,OAAO;AACtB,aAAO,CAAC,EAAE,KAAK,OAAO,OAAO,EAAE,GAAG,OAAO,GAAG,KAAK,QAAQ;AAAA,eAChD,KAAK,QAAQ,OAAO;AAC7B,aAAO,CAAC,EAAE,KAAK,OAAO,OAAO,EAAE,GAAG,OAAO,GAAG,WAAK,CAAC,KAAK,SAAS;AAAA,eACvD,KAAK,QAAQ,OAAO;AAC7B,YAAM,EAAE,SAAS;AACjB,YAAM,aAAa,OAAO,IAAI,CAAC,EAAE,WAAW;AAC5C,UAAI,SAAS,UAAU,SAAS,SAAS;AACvC,eAAO;AAAA,UACL,EAAE,KAAK,OAAO,OAAY,EAAE,GAAG,QAAQ,GAAG,SAAS,UAAU;AAAA;AAAA,iBAEtD,SAAS,QAAQ;AAC1B,eAAO,CAAC,EAAE,KAAK,OAAO,OAAO,SAAS;AAAA,iBAC7B,SAAS,KAAK;AACvB,eAAO,CAAC,EAAE,KAAK,OAAO,OAAO,EAAE,GAAG,QAAQ,GAAG,UAAa;AAAA,iBACjD,YAAM,CAAC,MAAM,MAAM;AAC5B,eAAO,CAAC,EAAE,KAAK,OAAO,OAAY,EAAE,GAAG,OAAO,GAAG,QAAQ;AAAA,iBAEzD,SAAS,OACR,YAAM,CAAC,MAAM,QAAQ,WAAK,CAAC,YAAM,CAAC,MAAM,KACzC;AACA,cAAM,QAAQ,SAAS,MAAM,IAAI,WAAK,CAAC,YAAM,CAAC,MAAM;AACpD,YAAI,QAAQ,GAAG;AACb,iBAAO,CAAC,EAAE,KAAK,OAAO,OAAO,SAAS;AAAA;AAExC,eAAO,CAAC,EAAE,KAAK,OAAO,OAAO,MAAM;AAAA,iBAC1B,SAAG,CAAC,YAAY,OAAO;AAChC,cAAM,QAAQ,OAAO,KAAK,CAAC,EAAE,WAAW,SAAS;AACjD,YAAI,SAAG,CAAC,MAAM,cAAc,GAAG;AAC7B,iBAAO,CAAC,EAAE,KAAK,OAAO,OAAO,MAAM,SAAS,IAAI,MAAM;AAAA;AAExD,eAAO,CAAC,EAAE,KAAK,OAAO,OAAO,MAAM,UAAU;AAAA,iBACpC,SAAS,QAAQ;AAC1B,eAAO,CAAC,EAAE,KAAK,OAAO,OAAO,IAAI,MAAM,QAAQ;AAAA,iBACtC,SAAS,QAAQ,SAAS,KAAK;AACxC,cAAM,IAAI,SAAS,OAAO,oBAAoB;AAC9C,eAAO,CAAC,EAAE,KAAK,OAAO,OAAO,EAAE,GAAG,OAAO,KAAK;AAAA,iBACrC,SAAG,CAAC,OAAO;AACpB,eAAO,CAAC,EAAE,KAAK,OAAO,OAAY,EAAE,GAAG,QAAQ,GAAG,QAAQ;AAAA;AAE5D,aAAO,CAAC,EAAE,KAAK,OAAO,OAAO,MAAM;AAAA;AAErC,WAAO;AAAA,aACE,CAAC,SAAG,CAAC,OAAO;AACrB,WAAO;AAAA;AAET,SAAO,UAAU,MAAM;AAAA;AAYzB,qBACE,OACA,aACA,WAAqB,IACwB;AAC7C,QAAM,QAAqB,IACzB,OAAoB;AACtB,MAAI,IAAI;AACR,SACE,SAAG,CAAC,SAAU,eAAc,IAAI,MAC/B,SAAQ,MAAM,OAAO,MAAM,MAAM,QAAQ,QAC1C;AACA,UAAM,QAAQ,MAAM;AACpB,QAAI,CAAC,QAAQ,QAAQ;AACnB,YAAM;AACN,YAAM,SAAS,YAAY,OAAO,MAAM,CAAC,GAAG,UAAU;AACtD,gBAAI,CAAC,OAAO,OAAO;AACnB,gBAAI,CAAC,MAAM,OAAO;AAAA,WACb;AACL,YAAM,EAAE,KAAK,WAAW;AACxB,UAAI,QAAQ,OAAO;AACjB,cAAM,KAAK,EAAE,MAAM,MAAM,MAAM,UAAU,CAAC,GAAG,UAAU;AAAA,aAClD;AACL,aAAK,KAAK,EAAE,KAAK,OAAO,OAAO,0BAA0B;AAAA;AAAA;AAG7D,MAAE;AAAA;AAEJ,SAAO,EAAE,OAAO,QAAQ;AAAA;AAG1B,qBAAqB,EAAE,MAAM,SAAyC;AACpE,QAAM,EAAE,OAAO,QAAQ,WAAW,YAAY,OAAO;AACrD,QAAM,MAAM,CAAC,GAAG,QAAQ,GAAG,UAAI,CAAC,MAAM,IAAI,UAAQ,SAAS,MAAM;AACjE,WAAS,IAAI,GAAG,MAAM,SAAG,CAAC,MAAM,IAAI,KAAK,KAAK;AAC5C,UAAM,EAAE,KAAK,OAAO,WAAW,IAAI;AACnC,QAAI,QAAQ,OAAO;AACjB,aAAoB,EAAE,GAAG,SAAS,GAAG,OAAO;AAAA;AAAA;AAGhD,SAAO,EAAE,MAAM;AAAA;AAGjB,4BACE,QACA,MACA,MACkB;AAGlB,QAAM,WAAW,QAAQ;AACzB,QAAM,CAAC,GAAG,KAAK,CAAC,WAAW,MAAM,KAAK,WAAW,MAAM;AACvD,QAAM,YAAY,WAAW,IAAI;AACjC,WACM,MAAM,SAAG,CAAC,SAAS,IAAI,WAAW,IAAI,MAAM,GAAG,QAAQ,GAC3D,WAAW,IAAI,MAAM,KAAK,GAC1B,KAAK,WACL;AACA,UAAM;AAAA,MACJ;AAAA,MACA,QAAQ,EAAE,MAAM;AAAA,QACd,OAAO;AACX,aAAS,WAAK,CAAC,QAAQ,KAAK,WAAK,CAAC,QAAQ;AAC1C,QAAI,QAAQ,GAAG;AACb,aAAO,CAAC,MAAM;AAAA;AAAA;AAGlB,SAAO,CAAC,GAAG;AAAA;AAGb,0BAA0B,aAAmC,QAAiB;AAC5E,QAAM,WAAW,SAAG,CAAC,UAAU,OAAO,GAAG,OAAO,WAAW;AAC3D,QAAM,SAAwB;AAC9B,QAAM,MAAM,CAAC,GAAW,WACtB,OAAO,KAAK,EAAE,GAAG,SAAS,GAAG;AAG/B,MAAI,aAAa;AACf,UAAM,CAAC,MAAM,OAAO;AACpB,QAAI,oCAAoC,EAAE,UAAU,MAAM;AAC1D,WAAO;AAAA;AAIT,QAAM,WAAW,CAAC,MAChB,SAAG,CAAC,OAAO,OAAO,CAAC,EAAE,UAAU,QAAQ;AACzC,QAAM,CAAC,MAAM,QAAQ,CAAC,SAAS,MAAM,SAAS;AAC9C;AACE,UAAM,CAAC,MAAM,OAAO,mBAAmB,QAAQ,MAAM;AACrD,QAAI,OAAO,KAAK;AACd,UAAI,yBAAyB,EAAE,UAAoB,MAAM;AAAA;AAAA;AAK7D,MAAI;AACJ,WAAS,IAAI,GAAG,WAAW,OAAO,IAAI,SAAG,CAAC,SAAS,EAAE,GAAG;AACtD,UAAM,QAAQ,OAAO;AAErB,QAAI,MAAM,QAAQ,SAAS,MAAM,SAAS,OAAO,MAAM,SAAS,KAAK;AACnE;AAAA;AAEF,QAAI,YAAY,MAAM,QAAQ,KAAK;AACjC,kBAAY;AACZ;AAAA;AAEF,eAAW,MAAM,QAAQ;AAAA;AAE3B,MAAI,WAAW;AACb,QAAI,8BAA8B,UAAU;AAAA;AAG9C,SAAO;AAAA;AAIT,wBAAwB,MAAwC;AAK9D,QAAM,QAAoB;AAC1B,WAAS,IAAI,GAAG,MAAM,SAAG,CAAC,OAAO,IAAI,KAAK,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK;AACjB,YAAQ,IAAI;AAAA,WACL;AACH,cAAM,KAAK,EAAE,OAAO,CAAC,IAAI,MAAM,IAAI,KAAK,IAAI;AAC5C;AAAA,WACG;AAAA,WACA,OAAO;AACV,cAAM,OAAO,MAAM;AACnB,cAAM,OAAO,YAAM,CAAC,OAAO,SAAG,CAAC,SAAS,IAAI,OAAO,IAAI;AACvD,cAAM,WAAW,CAAC,YAChB,KAAK,UACH,CAAC,EAAE,YAAY,SAAS,CAAC,QAAQ,KAAK,OAAK,SAAG,CAAC,OAAO;AAE1D,cAAM,SAAS,CAAC,MACd,KAAK,MACD,KAAK,IAAI,MAAM,IACf,KAAK,SAAS,SAAG,CAAC,KAAK,WAAW,KAAK,KAAK,MAAM,OAAO;AAC/D,YAAI,KAAK,OAAO,KAAK,IAAI,MAAM,QAAQ;AACrC,cAAI,KAAK,IAAI,MAAM,SAAS;AAC1B,wBAAM,CAAC,OAAO,SAAG,CAAC,SAAS,IAAI,OAAO,IAAI;AAC1C;AAAA;AAEF,gBAAM,SAAS,SAAS,CACtB,KAAK,IAAI,GACT,KAAK,IAAI,OAAK,EAAE,SAAS,KACzB,IAAI,QACJ;AAEF,cAAI,QAAQ;AACV,mBAAO;AAAA;AAET,gBAAM,EAAE,SAAS,SAAS,YAAY,SAAG,CAAC,KAAK,IAAI;AACnD,gBAAM,KACJ,WAAW,YAAY,YACnB,EAAE,OAAO,CAAC,WACV,EAAE,OAAO;AAAA,mBAEN,OAAO,QAAQ;AACxB,gBAAM,SAAS,SAAS,CAAC,OAAO,QAAQ;AACxC,cAAI,WAAW,IAAI;AACjB,mBAAO,QAAQ,CAAC,IAAI,QAAQ,KAAK,QAAQ;AAAA;AAE3C,gBAAM,KAAK;AAAA,mBACF,OAAO,QAAQ;AACxB,gBAAM,SAAS,SAAS,CAAC,QAAQ;AACjC,cAAI,WAAW,IAAI;AACjB,mBAAO,QAAQ,CAAC,IAAI,QAAQ,KAAK,QAAQ;AAAA;AAE3C,gBAAM,KAAK;AAAA,mBACF,OAAO,UAAU,OAAO,SAAS;AAC1C,gBAAM,KAAK;AAAA,mBACF,CAAC,KAAK,SAAS,CAAC,KAAK,KAAK;AACnC,gBAAM,KAAK;AAAA;AAEb;AAAA;AAAA,WAEG;AACH,cAAM;AACN,cAAM,KAAK;AACX,aAAK,IAAI;AACT;AAAA,WACG;AAAA,WACA;AAAA,WACA;AAAA,WACA;AAAA,WACA;AAAA,WACA;AAAA,WACA;AACH;AAAA,WACG,OAAO;AACV,cAAM,SAAS,eAAe,WAAK,CAAC,MAAM,IAAI,GAAG,IAAI,IAAI,MAAM;AAC/D,YAAI,QAAQ;AACV,iBAAO;AAAA;AAET,cAAM,KAAK;AAAA;AAAA,WAER;AAAA,WACA;AAAA,WACA;AAAA,WACA;AACH,cAAM,KAAK;AACX;AAAA,WACG,MAAM;AACT,cAAM;AACN,cAAM,KAAK;AACX,cAAM,QAAQ,WAAK,CAAC,MAAM,IAAI,GAAG,IAAI,QAAQ;AAC7C,cAAM,SAAS,eAAe;AAC9B,YAAI,QAAQ;AACV,iBAAO;AAAA;AAET,aAAK,IAAI,QAAQ;AACjB;AAAA;AAAA,WAEG,OAAO;AACV,cAAM;AACN,cAAM;AACN,aAAK,IAAI;AACT,aAAK,KAAK,GAAG;AACb,cAAM,KAAK;AACX;AAAA;AAAA,WAEG;AACH,oBAAM,CAAC,OAAO,SAAG,CAAC,SAAS,IAAI,OAAO,IAAI;AAC1C;AAAA,WACG;AACH,YAAI,IAAI,OAAO;AACb,gBAAM;AAAA;AAER;AAAA;AAEA,yBAAiB,CAAC;AAAA;AAAA;AAAA;AAKnB,eACL,MACA,UACyC;AACzC,QAAM,EAAE,QAAQ,gBAAgB,SAAS,MAAM;AAC/C,QAAM,cAAc,iBAAiB,aAAa;AAClD,MAAI,SAAG,CAAC,cAAc;AACpB,WAAO,EAAE,QAAQ,aAAa,OAAO;AAAA;AAEvC,QAAM,UAAkB,IACtB,SAAwB;AAC1B,QAAM,OAAO,QAAQ,WAAK,CAAC;AAC3B,QAAM,YAAY,aAAa;AAC/B,QAAM,aAA2B;AACjC,YAAU,QAAQ,eAAa;AAC7B,QAAI,SAAS,WAAW;AACtB,aAAO,KAAK,EAAE,GAAG,SAAS,GAAG,UAAU,KAAK,QAAQ,UAAU;AAAA,WACzD;AACL,iBAAW,KAAK,EAAE,MAAM,UAAU,MAAM,OAAO,UAAU;AAAA;AAAA;AAG7D,aAAW,IAAI,aAAa,QAAQ,SAAO;AACzC,QAAI,OAAO,KAAK;AACd,aAAO,KAAK;AAAA,WACP;AACL,cAAQ,KAAK;AAAA;AAAA;AAGjB,YAAI,CAAC,QAAQ,UAAI,CAAC,QAAQ,IAAI,OAAK,eAAe,EAAE,QAAQ;AAC5D,QAAM,QAAe;AACrB,UAAQ,QAAQ,UAAS,MAAM,KAAK,QAAQ,MAAM;AAClD,SAAO,EAAE,QAAQ;AAAA;;;ACn1BwD;AAK3E,aAAa,OAAc,KAAuB;AAChD,MAAI,CAAC,MAAM,KAAK,IAAI,MAAM;AACxB,WAAO,EAAE,MAAM,OAAO,KAAK,IAAI;AAAA;AAEjC,SAAO,EAAE,MAAM,OAAO,OAAO,MAAM,KAAK,IAAI;AAAA;AAG9C,aAAa,OAAc,KAAa,KAA8B;AACpE,QAAM,KAAK,IAAI,KAAK;AACpB,SAAO;AAAA;AAGT,aAAa,OAAc,MAAc,MAAuB;AAC9D,QAAM,UAAe,EAAE,GAAG,QAAQ,GAAG;AACrC,UAAQ;AAAA,SACD;AACH,YAAM,UAAU,KAAK,GAAG,IAAI;AAC5B;AAAA;AAEA,aAAO,EAAE,MAAM,OAAO,KAAK,cAAc;AAAA;AAE7C,SAAO,EAAE,MAAM,OAAO,OAAO;AAAA;AAG/B,MAAM,QAKA;AAAA,EAEJ,EAAE,MAAM,iBAAiB,MAAM,mBAAmB,KAAK;AAAA,EACvD;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA,IAEN,KAAK;AAAA;AAAA;AAAA,EAEP,EAAE,MAAM,aAAa,MAAM,WAAW,KAAK;AAAA,EAC3C,EAAE,MAAM,iBAAiB,MAAM,WAAW,KAAK;AAAA,EAC/C,EAAE,MAAM,qBAAqB,MAAM,yBAAyB,KAAK;AAAA,EACjE,EAAE,MAAM,oBAAoB,MAAM,0BAA0B,KAAK;AAAA,EACjE;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA;AAAA,IAIN,KAAK;AAAA;AAAA,EAEP,EAAE,MAAM,oBAAoB,MAAM,+BAA+B,KAAK;AAAA,EACtE;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP,EAAE,MAAM,mBAAmB,MAAM,eAAe,KAAK;AAAA,EACrD,EAAE,MAAM,mBAAmB,MAAM,qBAAqB,KAAK;AAAA,EAC3D;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA,IAKN,KAAK;AAAA;AAAA,EAEP,EAAE,MAAM,uBAAuB,MAAM,eAAe,KAAK;AAAA,EACzD,EAAE,MAAM,kBAAkB,MAAM,qBAAqB,KAAK;AAAA,EAC1D,EAAE,MAAM,sBAAsB,MAAM,qBAAqB,KAAK;AAAA,EAC9D,EAAE,MAAM,uBAAuB,MAAM,qBAAqB,KAAK;AAAA,EAC/D;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP,EAAE,MAAM,mBAAmB,MAAM,4BAA4B,KAAK;AAAA,EAClE;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP,EAAE,MAAM,uBAAuB,MAAM,WAAW,KAAK;AAAA,EACrD,EAAE,MAAM,kBAAkB,MAAM,0BAA0B,KAAK;AAAA,EAC/D;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA,IAEN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA;AAAA,IAIN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA,IAGN,KAAK;AAAA;AAAA,EAGP,EAAE,MAAM,uBAAuB,MAAM;AAAA,EACrC;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA,IAGN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA,IAEN,KAAK;AAAA;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA,IAEN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA;AAAA,EAEP,EAAE,MAAM,oBAAoB,MAAM,gCAAgC,KAAK;AAAA,EACvE;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA;AAAA,IAIN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA;AAAA,IAIN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA,IAGN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA,IAGN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA,IAGN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAON,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA;AAAA,IAIN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,EAEP;AAAA,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","sources":["webpack://insitux/./node_modules/ansi-regex/index.js","webpack://insitux/./node_modules/cross-fetch/dist/node-ponyfill.js","webpack://insitux/./node_modules/git-clone/private/impl.js","webpack://insitux/./node_modules/git-clone/private/util.js","webpack://insitux/./node_modules/git-clone/promise.js","webpack://insitux/./node_modules/prompt-sync/index.js","webpack://insitux/./node_modules/strip-ansi/index.js","webpack://insitux/./node_modules/tr46/index.js","webpack://insitux/./node_modules/webidl-conversions/lib/index.js","webpack://insitux/./node_modules/whatwg-url/lib/URL-impl.js","webpack://insitux/./node_modules/whatwg-url/lib/URL.js","webpack://insitux/./node_modules/whatwg-url/lib/public-api.js","webpack://insitux/./node_modules/whatwg-url/lib/url-state-machine.js","webpack://insitux/./node_modules/whatwg-url/lib/utils.js","webpack://insitux/external node-commonjs \"child_process\"","webpack://insitux/external node-commonjs \"fs\"","webpack://insitux/external node-commonjs \"punycode\"","webpack://insitux/external node-commonjs \"readline\"","webpack://insitux/external node-commonjs \"stream\"","webpack://insitux/external node-commonjs \"http\"","webpack://insitux/external node-commonjs \"url\"","webpack://insitux/external node-commonjs \"https\"","webpack://insitux/external node-commonjs \"zlib\"","webpack://insitux/./node_modules/node-fetch/lib/index.mjs","webpack://insitux/webpack/bootstrap","webpack://insitux/webpack/runtime/compat get default export","webpack://insitux/webpack/runtime/define property getters","webpack://insitux/webpack/runtime/hasOwnProperty shorthand","webpack://insitux/webpack/runtime/make namespace object","webpack://insitux/./src/poly-fills.ts","webpack://insitux/./src/types.ts","webpack://insitux/./src/checks.ts","webpack://insitux/./src/closure.ts","webpack://insitux/./src/parse.ts","webpack://insitux/./src/test.ts","webpack://insitux/./src/val.ts","webpack://insitux/./src/index.ts","webpack://insitux/external node-commonjs \"path\"","webpack://insitux/./src/invoker.ts","webpack://insitux/external node-commonjs \"process\"","webpack://insitux/./src/repl.ts"],"sourcesContent":["'use strict';\n\nmodule.exports = options => {\n\toptions = Object.assign({\n\t\tonlyFirst: false\n\t}, options);\n\n\tconst pattern = [\n\t\t'[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, options.onlyFirst ? undefined : 'g');\n};\n","const nodeFetch = require('node-fetch')\nconst realFetch = nodeFetch.default || nodeFetch\n\nconst fetch = function (url, options) {\n  // Support schemaless URIs on the server for parity with the browser.\n  // Ex: //github.com/ -> https://github.com/\n  if (/^\\/\\//.test(url)) {\n    url = 'https:' + url\n  }\n  return realFetch.call(this, url, options)\n}\n\nfetch.ponyfill = true\n\nmodule.exports = exports = fetch\nexports.fetch = fetch\nexports.Headers = nodeFetch.Headers\nexports.Request = nodeFetch.Request\nexports.Response = nodeFetch.Response\n\n// Needed for TypeScript consumers without esModuleInterop.\nexports.default = fetch\n","const {\n    buildCloneCommand,\n    buildCheckoutCommand\n} = require('./util');\n\nconst spawn = require('child_process').spawn;\n\nmodule.exports = function clone(repo, targetPath, opts, onSuccess, onError) {\n\tconst [cmd, args] = buildCloneCommand(repo, targetPath, opts);\n    const proc = spawn(cmd, args);\n    proc.on('close', (status) => {\n        if (status == 0) {\n            if (opts.checkout) {\n                _checkout();\n            } else {\n            \tonSuccess();   \n            }\n        } else {\n            onError(new Error(\"'git clone' failed with status \" + status));\n        }\n    });\n\n    function _checkout() {\n        const [cmd, args] = buildCheckoutCommand(opts.checkout, opts);\n        const proc = spawn(cmd, args, { cwd: targetPath });\n        proc.on('close', function(status) {\n            if (status == 0) {\n                onSuccess();\n            } else {\n                onError(new Error(\"'git checkout' failed with status \" + status));\n            }\n        });\n    }\n}\n","function git(opts) {\n\treturn opts.git || 'git';\n}\n\nexports.buildCloneCommand = function(repo, targetPath, opts) {\n\tlet args = ['clone'];\n\tconst userArgs = opts.args || [];\n\n\tif (opts.shallow) {\n\t\tif (userArgs.indexOf('--depth') >= 0) {\n\t\t\tthrow new Error(\"'--depth' cannot be specified when shallow is set to 'true'\");\n\t\t}\n\t\targs.push('--depth', '1');\n\t}\n\n\targs = args.concat(userArgs);\n\targs.push('--', repo, targetPath);\n\n\treturn [git(opts), args];\n}\n\nexports.buildCheckoutCommand = function(ref, opts) {\n\treturn [git(opts), ['checkout', ref]];\n}\n","const impl = require('./private/impl');\n\nmodule.exports = function(repo, targetPath, opts) {\n    return new Promise((yes, no) => {\n        impl(repo, targetPath, opts || {}, yes, no);\n    });\n}\n","'use strict'\n\nvar fs = require('fs');\nvar stripAnsi = require('strip-ansi');\nvar term = 13; // carriage return\n\n/**\n * create -- sync function for reading user input from stdin\n * @param   {Object} config {\n *   sigint: {Boolean} exit on ^C\n *   autocomplete: {StringArray} function({String})\n *   history: {String} a history control object (see `prompt-sync-history`)\n * }\n * @returns {Function} prompt function\n */\n\n // for ANSI escape codes reference see https://en.wikipedia.org/wiki/ANSI_escape_code\n\nfunction create(config) {\n\n  config = config || {};\n  var sigint = config.sigint;\n  var eot = config.eot;\n  var autocomplete = config.autocomplete =\n    config.autocomplete || function(){return []};\n  var history = config.history;\n  prompt.history = history || {save: function(){}};\n  prompt.hide = function (ask) { return prompt(ask, {echo: ''}) };\n\n  return prompt;\n\n\n  /**\n   * prompt -- sync function for reading user input from stdin\n   *  @param {String} ask opening question/statement to prompt for\n   *  @param {String} value initial value for the prompt\n   *  @param   {Object} opts {\n   *   echo: set to a character to be echoed, default is '*'. Use '' for no echo\n   *   value: {String} initial value for the prompt\n   *   ask: {String} opening question/statement to prompt for, does not override ask param\n   *   autocomplete: {StringArray} function({String})\n   * }\n   *\n   * @returns {string} Returns the string input or (if sigint === false)\n   *                   null if user terminates with a ^C\n   */\n\n\n  function prompt(ask, value, opts) {\n    var insert = 0, savedinsert = 0, res, i, savedstr;\n    opts = opts || {};\n\n    if (Object(ask) === ask) {\n      opts = ask;\n      ask = opts.ask;\n    } else if (Object(value) === value) {\n      opts = value;\n      value = opts.value;\n    }\n    ask = ask || '';\n    var echo = opts.echo;\n    var masked = 'echo' in opts;\n    autocomplete = opts.autocomplete || autocomplete;\n\n    var fd = (process.platform === 'win32') ?\n      process.stdin.fd :\n      fs.openSync('/dev/tty', 'rs');\n\n    var wasRaw = process.stdin.isRaw;\n    if (!wasRaw) { process.stdin.setRawMode && process.stdin.setRawMode(true); }\n\n    var buf = Buffer.alloc(3);\n    var str = '', character, read;\n\n    savedstr = '';\n\n    if (ask) {\n      process.stdout.write(ask);\n    }\n\n    var cycle = 0;\n    var prevComplete;\n\n    while (true) {\n      read = fs.readSync(fd, buf, 0, 3);\n      if (read > 1) { // received a control sequence\n        switch(buf.toString()) {\n          case '\\u001b[A':  //up arrow\n            if (masked) break;\n            if (!history) break;\n            if (history.atStart()) break;\n\n            if (history.atEnd()) {\n              savedstr = str;\n              savedinsert = insert;\n            }\n            str = history.prev();\n            insert = str.length;\n            process.stdout.write('\\u001b[2K\\u001b[0G' + ask + str);\n            break;\n          case '\\u001b[B':  //down arrow\n            if (masked) break;\n            if (!history) break;\n            if (history.pastEnd()) break;\n\n            if (history.atPenultimate()) {\n              str = savedstr;\n              insert = savedinsert;\n              history.next();\n            } else {\n              str = history.next();\n              insert = str.length;\n            }\n            process.stdout.write('\\u001b[2K\\u001b[0G'+ ask + str + '\\u001b['+(insert+ask.length+1)+'G');\n            break;\n          case '\\u001b[D': //left arrow\n            if (masked) break;\n            var before = insert;\n            insert = (--insert < 0) ? 0 : insert;\n            if (before - insert)\n              process.stdout.write('\\u001b[1D');\n            break;\n          case '\\u001b[C': //right arrow\n            if (masked) break;\n            insert = (++insert > str.length) ? str.length : insert;\n            process.stdout.write('\\u001b[' + (insert+ask.length+1) + 'G');\n            break;\n          default:\n            if (buf.toString()) {\n              str = str + buf.toString();\n              str = str.replace(/\\0/g, '');\n              insert = str.length;\n              promptPrint(masked, ask, echo, str, insert);\n              process.stdout.write('\\u001b[' + (insert+ask.length+1) + 'G');\n              buf = Buffer.alloc(3);\n            }\n        }\n        continue; // any other 3 character sequence is ignored\n      }\n\n      // if it is not a control character seq, assume only one character is read\n      character = buf[read-1];\n\n      // catch a ^C and return null\n      if (character == 3){\n        process.stdout.write('^C\\n');\n        fs.closeSync(fd);\n\n        if (sigint) process.exit(130);\n\n        process.stdin.setRawMode && process.stdin.setRawMode(wasRaw);\n\n        return null;\n      }\n\n      // catch a ^D and exit\n      if (character == 4) {\n        if (str.length == 0 && eot) {\n          process.stdout.write('exit\\n');\n          process.exit(0);\n        }\n      }\n\n      // catch the terminating character\n      if (character == term) {\n        fs.closeSync(fd);\n        if (!history) break;\n        if (!masked && str.length) history.push(str);\n        history.reset();\n        break;\n      }\n\n      // catch a TAB and implement autocomplete\n      if (character == 9) { // TAB\n        res = autocomplete(str);\n\n        if (str == res[0]) {\n          res = autocomplete('');\n        } else {\n          prevComplete = res.length;\n        }\n\n        if (res.length == 0) {\n          process.stdout.write('\\t');\n          continue;\n        }\n\n        var item = res[cycle++] || res[cycle = 0, cycle++];\n\n        if (item) {\n          process.stdout.write('\\r\\u001b[K' + ask + item);\n          str = item;\n          insert = item.length;\n        }\n      }\n\n      if (character == 127 || (process.platform == 'win32' && character == 8)) { //backspace\n        if (!insert) continue;\n        str = str.slice(0, insert-1) + str.slice(insert);\n        insert--;\n        process.stdout.write('\\u001b[2D');\n      } else {\n        if ((character < 32 ) || (character > 126))\n            continue;\n        str = str.slice(0, insert) + String.fromCharCode(character) + str.slice(insert);\n        insert++;\n      };\n\n      promptPrint(masked, ask, echo, str, insert);\n\n    }\n\n    process.stdout.write('\\n')\n\n    process.stdin.setRawMode && process.stdin.setRawMode(wasRaw);\n\n    return str || value || '';\n  };\n\n\n  function promptPrint(masked, ask, echo, str, insert) {\n    if (masked) {\n        process.stdout.write('\\u001b[2K\\u001b[0G' + ask + Array(str.length+1).join(echo));\n    } else {\n      process.stdout.write('\\u001b[s');\n      if (insert == str.length) {\n          process.stdout.write('\\u001b[2K\\u001b[0G'+ ask + str);\n      } else {\n        if (ask) {\n          process.stdout.write('\\u001b[2K\\u001b[0G'+ ask + str);\n        } else {\n          process.stdout.write('\\u001b[2K\\u001b[0G'+ str + '\\u001b[' + (str.length - insert) + 'D');\n        }\n      }\n\n      // Reposition the cursor to the right of the insertion point\n      var askLength = stripAnsi(ask).length;\n      process.stdout.write(`\\u001b[${askLength+1+(echo==''? 0:insert)}G`);\n    }\n  }\n};\n\nmodule.exports = create;\n","'use strict';\nconst ansiRegex = require('ansi-regex');\n\nconst stripAnsi = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;\n\nmodule.exports = stripAnsi;\nmodule.exports.default = stripAnsi;\n","\"use strict\";\n\nvar punycode = require(\"punycode\");\nvar mappingTable = require(\"./lib/mappingTable.json\");\n\nvar PROCESSING_OPTIONS = {\n  TRANSITIONAL: 0,\n  NONTRANSITIONAL: 1\n};\n\nfunction normalize(str) { // fix bug in v8\n  return str.split('\\u0000').map(function (s) { return s.normalize('NFC'); }).join('\\u0000');\n}\n\nfunction findStatus(val) {\n  var start = 0;\n  var end = mappingTable.length - 1;\n\n  while (start <= end) {\n    var mid = Math.floor((start + end) / 2);\n\n    var target = mappingTable[mid];\n    if (target[0][0] <= val && target[0][1] >= val) {\n      return target;\n    } else if (target[0][0] > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n\n  return null;\n}\n\nvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\nfunction countSymbols(string) {\n  return string\n    // replace every surrogate pair with a BMP symbol\n    .replace(regexAstralSymbols, '_')\n    // then get the length\n    .length;\n}\n\nfunction mapChars(domain_name, useSTD3, processing_option) {\n  var hasError = false;\n  var processed = \"\";\n\n  var len = countSymbols(domain_name);\n  for (var i = 0; i < len; ++i) {\n    var codePoint = domain_name.codePointAt(i);\n    var status = findStatus(codePoint);\n\n    switch (status[1]) {\n      case \"disallowed\":\n        hasError = true;\n        processed += String.fromCodePoint(codePoint);\n        break;\n      case \"ignored\":\n        break;\n      case \"mapped\":\n        processed += String.fromCodePoint.apply(String, status[2]);\n        break;\n      case \"deviation\":\n        if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {\n          processed += String.fromCodePoint.apply(String, status[2]);\n        } else {\n          processed += String.fromCodePoint(codePoint);\n        }\n        break;\n      case \"valid\":\n        processed += String.fromCodePoint(codePoint);\n        break;\n      case \"disallowed_STD3_mapped\":\n        if (useSTD3) {\n          hasError = true;\n          processed += String.fromCodePoint(codePoint);\n        } else {\n          processed += String.fromCodePoint.apply(String, status[2]);\n        }\n        break;\n      case \"disallowed_STD3_valid\":\n        if (useSTD3) {\n          hasError = true;\n        }\n\n        processed += String.fromCodePoint(codePoint);\n        break;\n    }\n  }\n\n  return {\n    string: processed,\n    error: hasError\n  };\n}\n\nvar combiningMarksRegex = /[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E4-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C00-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D01-\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1AB0-\\u1ABE\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF5\\u1DFC-\\u1DFF\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9E5\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2D]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD804[\\uDC00-\\uDC02\\uDC38-\\uDC46\\uDC7F-\\uDC82\\uDCB0-\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD34\\uDD73\\uDD80-\\uDD82\\uDDB3-\\uDDC0\\uDE2C-\\uDE37\\uDEDF-\\uDEEA\\uDF01-\\uDF03\\uDF3C\\uDF3E-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF62\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDCB0-\\uDCC3\\uDDAF-\\uDDB5\\uDDB8-\\uDDC0\\uDE30-\\uDE40\\uDEAB-\\uDEB7]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF51-\\uDF7E\\uDF8F-\\uDF92]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD83A[\\uDCD0-\\uDCD6]|\\uDB40[\\uDD00-\\uDDEF]/;\n\nfunction validateLabel(label, processing_option) {\n  if (label.substr(0, 4) === \"xn--\") {\n    label = punycode.toUnicode(label);\n    processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;\n  }\n\n  var error = false;\n\n  if (normalize(label) !== label ||\n      (label[3] === \"-\" && label[4] === \"-\") ||\n      label[0] === \"-\" || label[label.length - 1] === \"-\" ||\n      label.indexOf(\".\") !== -1 ||\n      label.search(combiningMarksRegex) === 0) {\n    error = true;\n  }\n\n  var len = countSymbols(label);\n  for (var i = 0; i < len; ++i) {\n    var status = findStatus(label.codePointAt(i));\n    if ((processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== \"valid\") ||\n        (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&\n         status[1] !== \"valid\" && status[1] !== \"deviation\")) {\n      error = true;\n      break;\n    }\n  }\n\n  return {\n    label: label,\n    error: error\n  };\n}\n\nfunction processing(domain_name, useSTD3, processing_option) {\n  var result = mapChars(domain_name, useSTD3, processing_option);\n  result.string = normalize(result.string);\n\n  var labels = result.string.split(\".\");\n  for (var i = 0; i < labels.length; ++i) {\n    try {\n      var validation = validateLabel(labels[i]);\n      labels[i] = validation.label;\n      result.error = result.error || validation.error;\n    } catch(e) {\n      result.error = true;\n    }\n  }\n\n  return {\n    string: labels.join(\".\"),\n    error: result.error\n  };\n}\n\nmodule.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {\n  var result = processing(domain_name, useSTD3, processing_option);\n  var labels = result.string.split(\".\");\n  labels = labels.map(function(l) {\n    try {\n      return punycode.toASCII(l);\n    } catch(e) {\n      result.error = true;\n      return l;\n    }\n  });\n\n  if (verifyDnsLength) {\n    var total = labels.slice(0, labels.length - 1).join(\".\").length;\n    if (total.length > 253 || total.length === 0) {\n      result.error = true;\n    }\n\n    for (var i=0; i < labels.length; ++i) {\n      if (labels.length > 63 || labels.length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n\n  if (result.error) return null;\n  return labels.join(\".\");\n};\n\nmodule.exports.toUnicode = function(domain_name, useSTD3) {\n  var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);\n\n  return {\n    domain: result.string,\n    error: result.error\n  };\n};\n\nmodule.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;\n","\"use strict\";\n\nvar conversions = {};\nmodule.exports = conversions;\n\nfunction sign(x) {\n    return x < 0 ? -1 : 1;\n}\n\nfunction evenRound(x) {\n    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\n    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)\n        return Math.floor(x);\n    } else {\n        return Math.round(x);\n    }\n}\n\nfunction createNumberConversion(bitLength, typeOpts) {\n    if (!typeOpts.unsigned) {\n        --bitLength;\n    }\n    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);\n    const upperBound = Math.pow(2, bitLength) - 1;\n\n    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);\n    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);\n\n    return function(V, opts) {\n        if (!opts) opts = {};\n\n        let x = +V;\n\n        if (opts.enforceRange) {\n            if (!Number.isFinite(x)) {\n                throw new TypeError(\"Argument is not a finite number\");\n            }\n\n            x = sign(x) * Math.floor(Math.abs(x));\n            if (x < lowerBound || x > upperBound) {\n                throw new TypeError(\"Argument is not in byte range\");\n            }\n\n            return x;\n        }\n\n        if (!isNaN(x) && opts.clamp) {\n            x = evenRound(x);\n\n            if (x < lowerBound) x = lowerBound;\n            if (x > upperBound) x = upperBound;\n            return x;\n        }\n\n        if (!Number.isFinite(x) || x === 0) {\n            return 0;\n        }\n\n        x = sign(x) * Math.floor(Math.abs(x));\n        x = x % moduloVal;\n\n        if (!typeOpts.unsigned && x >= moduloBound) {\n            return x - moduloVal;\n        } else if (typeOpts.unsigned) {\n            if (x < 0) {\n              x += moduloVal;\n            } else if (x === -0) { // don't return negative zero\n              return 0;\n            }\n        }\n\n        return x;\n    }\n}\n\nconversions[\"void\"] = function () {\n    return undefined;\n};\n\nconversions[\"boolean\"] = function (val) {\n    return !!val;\n};\n\nconversions[\"byte\"] = createNumberConversion(8, { unsigned: false });\nconversions[\"octet\"] = createNumberConversion(8, { unsigned: true });\n\nconversions[\"short\"] = createNumberConversion(16, { unsigned: false });\nconversions[\"unsigned short\"] = createNumberConversion(16, { unsigned: true });\n\nconversions[\"long\"] = createNumberConversion(32, { unsigned: false });\nconversions[\"unsigned long\"] = createNumberConversion(32, { unsigned: true });\n\nconversions[\"long long\"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });\nconversions[\"unsigned long long\"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });\n\nconversions[\"double\"] = function (V) {\n    const x = +V;\n\n    if (!Number.isFinite(x)) {\n        throw new TypeError(\"Argument is not a finite floating-point value\");\n    }\n\n    return x;\n};\n\nconversions[\"unrestricted double\"] = function (V) {\n    const x = +V;\n\n    if (isNaN(x)) {\n        throw new TypeError(\"Argument is NaN\");\n    }\n\n    return x;\n};\n\n// not quite valid, but good enough for JS\nconversions[\"float\"] = conversions[\"double\"];\nconversions[\"unrestricted float\"] = conversions[\"unrestricted double\"];\n\nconversions[\"DOMString\"] = function (V, opts) {\n    if (!opts) opts = {};\n\n    if (opts.treatNullAsEmptyString && V === null) {\n        return \"\";\n    }\n\n    return String(V);\n};\n\nconversions[\"ByteString\"] = function (V, opts) {\n    const x = String(V);\n    let c = undefined;\n    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\n        if (c > 255) {\n            throw new TypeError(\"Argument is not a valid bytestring\");\n        }\n    }\n\n    return x;\n};\n\nconversions[\"USVString\"] = function (V) {\n    const S = String(V);\n    const n = S.length;\n    const U = [];\n    for (let i = 0; i < n; ++i) {\n        const c = S.charCodeAt(i);\n        if (c < 0xD800 || c > 0xDFFF) {\n            U.push(String.fromCodePoint(c));\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\n            U.push(String.fromCodePoint(0xFFFD));\n        } else {\n            if (i === n - 1) {\n                U.push(String.fromCodePoint(0xFFFD));\n            } else {\n                const d = S.charCodeAt(i + 1);\n                if (0xDC00 <= d && d <= 0xDFFF) {\n                    const a = c & 0x3FF;\n                    const b = d & 0x3FF;\n                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\n                    ++i;\n                } else {\n                    U.push(String.fromCodePoint(0xFFFD));\n                }\n            }\n        }\n    }\n\n    return U.join('');\n};\n\nconversions[\"Date\"] = function (V, opts) {\n    if (!(V instanceof Date)) {\n        throw new TypeError(\"Argument is not a Date object\");\n    }\n    if (isNaN(V)) {\n        return undefined;\n    }\n\n    return V;\n};\n\nconversions[\"RegExp\"] = function (V, opts) {\n    if (!(V instanceof RegExp)) {\n        V = new RegExp(V);\n    }\n\n    return V;\n};\n","\"use strict\";\nconst usm = require(\"./url-state-machine\");\n\nexports.implementation = class URLImpl {\n  constructor(constructorArgs) {\n    const url = constructorArgs[0];\n    const base = constructorArgs[1];\n\n    let parsedBase = null;\n    if (base !== undefined) {\n      parsedBase = usm.basicURLParse(base);\n      if (parsedBase === \"failure\") {\n        throw new TypeError(\"Invalid base URL\");\n      }\n    }\n\n    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });\n    if (parsedURL === \"failure\") {\n      throw new TypeError(\"Invalid URL\");\n    }\n\n    this._url = parsedURL;\n\n    // TODO: query stuff\n  }\n\n  get href() {\n    return usm.serializeURL(this._url);\n  }\n\n  set href(v) {\n    const parsedURL = usm.basicURLParse(v);\n    if (parsedURL === \"failure\") {\n      throw new TypeError(\"Invalid URL\");\n    }\n\n    this._url = parsedURL;\n  }\n\n  get origin() {\n    return usm.serializeURLOrigin(this._url);\n  }\n\n  get protocol() {\n    return this._url.scheme + \":\";\n  }\n\n  set protocol(v) {\n    usm.basicURLParse(v + \":\", { url: this._url, stateOverride: \"scheme start\" });\n  }\n\n  get username() {\n    return this._url.username;\n  }\n\n  set username(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    usm.setTheUsername(this._url, v);\n  }\n\n  get password() {\n    return this._url.password;\n  }\n\n  set password(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    usm.setThePassword(this._url, v);\n  }\n\n  get host() {\n    const url = this._url;\n\n    if (url.host === null) {\n      return \"\";\n    }\n\n    if (url.port === null) {\n      return usm.serializeHost(url.host);\n    }\n\n    return usm.serializeHost(url.host) + \":\" + usm.serializeInteger(url.port);\n  }\n\n  set host(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"host\" });\n  }\n\n  get hostname() {\n    if (this._url.host === null) {\n      return \"\";\n    }\n\n    return usm.serializeHost(this._url.host);\n  }\n\n  set hostname(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"hostname\" });\n  }\n\n  get port() {\n    if (this._url.port === null) {\n      return \"\";\n    }\n\n    return usm.serializeInteger(this._url.port);\n  }\n\n  set port(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    if (v === \"\") {\n      this._url.port = null;\n    } else {\n      usm.basicURLParse(v, { url: this._url, stateOverride: \"port\" });\n    }\n  }\n\n  get pathname() {\n    if (this._url.cannotBeABaseURL) {\n      return this._url.path[0];\n    }\n\n    if (this._url.path.length === 0) {\n      return \"\";\n    }\n\n    return \"/\" + this._url.path.join(\"/\");\n  }\n\n  set pathname(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    this._url.path = [];\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"path start\" });\n  }\n\n  get search() {\n    if (this._url.query === null || this._url.query === \"\") {\n      return \"\";\n    }\n\n    return \"?\" + this._url.query;\n  }\n\n  set search(v) {\n    // TODO: query stuff\n\n    const url = this._url;\n\n    if (v === \"\") {\n      url.query = null;\n      return;\n    }\n\n    const input = v[0] === \"?\" ? v.substring(1) : v;\n    url.query = \"\";\n    usm.basicURLParse(input, { url, stateOverride: \"query\" });\n  }\n\n  get hash() {\n    if (this._url.fragment === null || this._url.fragment === \"\") {\n      return \"\";\n    }\n\n    return \"#\" + this._url.fragment;\n  }\n\n  set hash(v) {\n    if (v === \"\") {\n      this._url.fragment = null;\n      return;\n    }\n\n    const input = v[0] === \"#\" ? v.substring(1) : v;\n    this._url.fragment = \"\";\n    usm.basicURLParse(input, { url: this._url, stateOverride: \"fragment\" });\n  }\n\n  toJSON() {\n    return this.href;\n  }\n};\n","\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Impl = require(\".//URL-impl.js\");\n\nconst impl = utils.implSymbol;\n\nfunction URL(url) {\n  if (!this || this[impl] || !(this instanceof URL)) {\n    throw new TypeError(\"Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'URL': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = arguments[i];\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"USVString\"](args[1]);\n  }\n\n  module.exports.setup(this, args);\n}\n\nURL.prototype.toJSON = function toJSON() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = arguments[i];\n  }\n  return this[impl].toJSON.apply(this[impl], args);\n};\nObject.defineProperty(URL.prototype, \"href\", {\n  get() {\n    return this[impl].href;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].href = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nURL.prototype.toString = function () {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return this.href;\n};\n\nObject.defineProperty(URL.prototype, \"origin\", {\n  get() {\n    return this[impl].origin;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"protocol\", {\n  get() {\n    return this[impl].protocol;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].protocol = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"username\", {\n  get() {\n    return this[impl].username;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].username = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"password\", {\n  get() {\n    return this[impl].password;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].password = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"host\", {\n  get() {\n    return this[impl].host;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].host = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"hostname\", {\n  get() {\n    return this[impl].hostname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hostname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"port\", {\n  get() {\n    return this[impl].port;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].port = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"pathname\", {\n  get() {\n    return this[impl].pathname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].pathname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"search\", {\n  get() {\n    return this[impl].search;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].search = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"hash\", {\n  get() {\n    return this[impl].hash;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hash = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nmodule.exports = {\n  is(obj) {\n    return !!obj && obj[impl] instanceof Impl.implementation;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(URL.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: URL,\n  expose: {\n    Window: { URL: URL },\n    Worker: { URL: URL }\n  }\n};\n\n","\"use strict\";\n\nexports.URL = require(\"./URL\").interface;\nexports.serializeURL = require(\"./url-state-machine\").serializeURL;\nexports.serializeURLOrigin = require(\"./url-state-machine\").serializeURLOrigin;\nexports.basicURLParse = require(\"./url-state-machine\").basicURLParse;\nexports.setTheUsername = require(\"./url-state-machine\").setTheUsername;\nexports.setThePassword = require(\"./url-state-machine\").setThePassword;\nexports.serializeHost = require(\"./url-state-machine\").serializeHost;\nexports.serializeInteger = require(\"./url-state-machine\").serializeInteger;\nexports.parseURL = require(\"./url-state-machine\").parseURL;\n","\"use strict\";\r\nconst punycode = require(\"punycode\");\r\nconst tr46 = require(\"tr46\");\r\n\r\nconst specialSchemes = {\r\n  ftp: 21,\r\n  file: null,\r\n  gopher: 70,\r\n  http: 80,\r\n  https: 443,\r\n  ws: 80,\r\n  wss: 443\r\n};\r\n\r\nconst failure = Symbol(\"failure\");\r\n\r\nfunction countSymbols(str) {\r\n  return punycode.ucs2.decode(str).length;\r\n}\r\n\r\nfunction at(input, idx) {\r\n  const c = input[idx];\r\n  return isNaN(c) ? undefined : String.fromCodePoint(c);\r\n}\r\n\r\nfunction isASCIIDigit(c) {\r\n  return c >= 0x30 && c <= 0x39;\r\n}\r\n\r\nfunction isASCIIAlpha(c) {\r\n  return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);\r\n}\r\n\r\nfunction isASCIIAlphanumeric(c) {\r\n  return isASCIIAlpha(c) || isASCIIDigit(c);\r\n}\r\n\r\nfunction isASCIIHex(c) {\r\n  return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);\r\n}\r\n\r\nfunction isSingleDot(buffer) {\r\n  return buffer === \".\" || buffer.toLowerCase() === \"%2e\";\r\n}\r\n\r\nfunction isDoubleDot(buffer) {\r\n  buffer = buffer.toLowerCase();\r\n  return buffer === \"..\" || buffer === \"%2e.\" || buffer === \".%2e\" || buffer === \"%2e%2e\";\r\n}\r\n\r\nfunction isWindowsDriveLetterCodePoints(cp1, cp2) {\r\n  return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);\r\n}\r\n\r\nfunction isWindowsDriveLetterString(string) {\r\n  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === \":\" || string[1] === \"|\");\r\n}\r\n\r\nfunction isNormalizedWindowsDriveLetterString(string) {\r\n  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === \":\";\r\n}\r\n\r\nfunction containsForbiddenHostCodePoint(string) {\r\n  return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|%|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\r\n}\r\n\r\nfunction containsForbiddenHostCodePointExcludingPercent(string) {\r\n  return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\r\n}\r\n\r\nfunction isSpecialScheme(scheme) {\r\n  return specialSchemes[scheme] !== undefined;\r\n}\r\n\r\nfunction isSpecial(url) {\r\n  return isSpecialScheme(url.scheme);\r\n}\r\n\r\nfunction defaultPort(scheme) {\r\n  return specialSchemes[scheme];\r\n}\r\n\r\nfunction percentEncode(c) {\r\n  let hex = c.toString(16).toUpperCase();\r\n  if (hex.length === 1) {\r\n    hex = \"0\" + hex;\r\n  }\r\n\r\n  return \"%\" + hex;\r\n}\r\n\r\nfunction utf8PercentEncode(c) {\r\n  const buf = new Buffer(c);\r\n\r\n  let str = \"\";\r\n\r\n  for (let i = 0; i < buf.length; ++i) {\r\n    str += percentEncode(buf[i]);\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\nfunction utf8PercentDecode(str) {\r\n  const input = new Buffer(str);\r\n  const output = [];\r\n  for (let i = 0; i < input.length; ++i) {\r\n    if (input[i] !== 37) {\r\n      output.push(input[i]);\r\n    } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {\r\n      output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));\r\n      i += 2;\r\n    } else {\r\n      output.push(input[i]);\r\n    }\r\n  }\r\n  return new Buffer(output).toString();\r\n}\r\n\r\nfunction isC0ControlPercentEncode(c) {\r\n  return c <= 0x1F || c > 0x7E;\r\n}\r\n\r\nconst extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);\r\nfunction isPathPercentEncode(c) {\r\n  return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);\r\n}\r\n\r\nconst extraUserinfoPercentEncodeSet =\r\n  new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);\r\nfunction isUserinfoPercentEncode(c) {\r\n  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);\r\n}\r\n\r\nfunction percentEncodeChar(c, encodeSetPredicate) {\r\n  const cStr = String.fromCodePoint(c);\r\n\r\n  if (encodeSetPredicate(c)) {\r\n    return utf8PercentEncode(cStr);\r\n  }\r\n\r\n  return cStr;\r\n}\r\n\r\nfunction parseIPv4Number(input) {\r\n  let R = 10;\r\n\r\n  if (input.length >= 2 && input.charAt(0) === \"0\" && input.charAt(1).toLowerCase() === \"x\") {\r\n    input = input.substring(2);\r\n    R = 16;\r\n  } else if (input.length >= 2 && input.charAt(0) === \"0\") {\r\n    input = input.substring(1);\r\n    R = 8;\r\n  }\r\n\r\n  if (input === \"\") {\r\n    return 0;\r\n  }\r\n\r\n  const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);\r\n  if (regex.test(input)) {\r\n    return failure;\r\n  }\r\n\r\n  return parseInt(input, R);\r\n}\r\n\r\nfunction parseIPv4(input) {\r\n  const parts = input.split(\".\");\r\n  if (parts[parts.length - 1] === \"\") {\r\n    if (parts.length > 1) {\r\n      parts.pop();\r\n    }\r\n  }\r\n\r\n  if (parts.length > 4) {\r\n    return input;\r\n  }\r\n\r\n  const numbers = [];\r\n  for (const part of parts) {\r\n    if (part === \"\") {\r\n      return input;\r\n    }\r\n    const n = parseIPv4Number(part);\r\n    if (n === failure) {\r\n      return input;\r\n    }\r\n\r\n    numbers.push(n);\r\n  }\r\n\r\n  for (let i = 0; i < numbers.length - 1; ++i) {\r\n    if (numbers[i] > 255) {\r\n      return failure;\r\n    }\r\n  }\r\n  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {\r\n    return failure;\r\n  }\r\n\r\n  let ipv4 = numbers.pop();\r\n  let counter = 0;\r\n\r\n  for (const n of numbers) {\r\n    ipv4 += n * Math.pow(256, 3 - counter);\r\n    ++counter;\r\n  }\r\n\r\n  return ipv4;\r\n}\r\n\r\nfunction serializeIPv4(address) {\r\n  let output = \"\";\r\n  let n = address;\r\n\r\n  for (let i = 1; i <= 4; ++i) {\r\n    output = String(n % 256) + output;\r\n    if (i !== 4) {\r\n      output = \".\" + output;\r\n    }\r\n    n = Math.floor(n / 256);\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction parseIPv6(input) {\r\n  const address = [0, 0, 0, 0, 0, 0, 0, 0];\r\n  let pieceIndex = 0;\r\n  let compress = null;\r\n  let pointer = 0;\r\n\r\n  input = punycode.ucs2.decode(input);\r\n\r\n  if (input[pointer] === 58) {\r\n    if (input[pointer + 1] !== 58) {\r\n      return failure;\r\n    }\r\n\r\n    pointer += 2;\r\n    ++pieceIndex;\r\n    compress = pieceIndex;\r\n  }\r\n\r\n  while (pointer < input.length) {\r\n    if (pieceIndex === 8) {\r\n      return failure;\r\n    }\r\n\r\n    if (input[pointer] === 58) {\r\n      if (compress !== null) {\r\n        return failure;\r\n      }\r\n      ++pointer;\r\n      ++pieceIndex;\r\n      compress = pieceIndex;\r\n      continue;\r\n    }\r\n\r\n    let value = 0;\r\n    let length = 0;\r\n\r\n    while (length < 4 && isASCIIHex(input[pointer])) {\r\n      value = value * 0x10 + parseInt(at(input, pointer), 16);\r\n      ++pointer;\r\n      ++length;\r\n    }\r\n\r\n    if (input[pointer] === 46) {\r\n      if (length === 0) {\r\n        return failure;\r\n      }\r\n\r\n      pointer -= length;\r\n\r\n      if (pieceIndex > 6) {\r\n        return failure;\r\n      }\r\n\r\n      let numbersSeen = 0;\r\n\r\n      while (input[pointer] !== undefined) {\r\n        let ipv4Piece = null;\r\n\r\n        if (numbersSeen > 0) {\r\n          if (input[pointer] === 46 && numbersSeen < 4) {\r\n            ++pointer;\r\n          } else {\r\n            return failure;\r\n          }\r\n        }\r\n\r\n        if (!isASCIIDigit(input[pointer])) {\r\n          return failure;\r\n        }\r\n\r\n        while (isASCIIDigit(input[pointer])) {\r\n          const number = parseInt(at(input, pointer));\r\n          if (ipv4Piece === null) {\r\n            ipv4Piece = number;\r\n          } else if (ipv4Piece === 0) {\r\n            return failure;\r\n          } else {\r\n            ipv4Piece = ipv4Piece * 10 + number;\r\n          }\r\n          if (ipv4Piece > 255) {\r\n            return failure;\r\n          }\r\n          ++pointer;\r\n        }\r\n\r\n        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;\r\n\r\n        ++numbersSeen;\r\n\r\n        if (numbersSeen === 2 || numbersSeen === 4) {\r\n          ++pieceIndex;\r\n        }\r\n      }\r\n\r\n      if (numbersSeen !== 4) {\r\n        return failure;\r\n      }\r\n\r\n      break;\r\n    } else if (input[pointer] === 58) {\r\n      ++pointer;\r\n      if (input[pointer] === undefined) {\r\n        return failure;\r\n      }\r\n    } else if (input[pointer] !== undefined) {\r\n      return failure;\r\n    }\r\n\r\n    address[pieceIndex] = value;\r\n    ++pieceIndex;\r\n  }\r\n\r\n  if (compress !== null) {\r\n    let swaps = pieceIndex - compress;\r\n    pieceIndex = 7;\r\n    while (pieceIndex !== 0 && swaps > 0) {\r\n      const temp = address[compress + swaps - 1];\r\n      address[compress + swaps - 1] = address[pieceIndex];\r\n      address[pieceIndex] = temp;\r\n      --pieceIndex;\r\n      --swaps;\r\n    }\r\n  } else if (compress === null && pieceIndex !== 8) {\r\n    return failure;\r\n  }\r\n\r\n  return address;\r\n}\r\n\r\nfunction serializeIPv6(address) {\r\n  let output = \"\";\r\n  const seqResult = findLongestZeroSequence(address);\r\n  const compress = seqResult.idx;\r\n  let ignore0 = false;\r\n\r\n  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {\r\n    if (ignore0 && address[pieceIndex] === 0) {\r\n      continue;\r\n    } else if (ignore0) {\r\n      ignore0 = false;\r\n    }\r\n\r\n    if (compress === pieceIndex) {\r\n      const separator = pieceIndex === 0 ? \"::\" : \":\";\r\n      output += separator;\r\n      ignore0 = true;\r\n      continue;\r\n    }\r\n\r\n    output += address[pieceIndex].toString(16);\r\n\r\n    if (pieceIndex !== 7) {\r\n      output += \":\";\r\n    }\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction parseHost(input, isSpecialArg) {\r\n  if (input[0] === \"[\") {\r\n    if (input[input.length - 1] !== \"]\") {\r\n      return failure;\r\n    }\r\n\r\n    return parseIPv6(input.substring(1, input.length - 1));\r\n  }\r\n\r\n  if (!isSpecialArg) {\r\n    return parseOpaqueHost(input);\r\n  }\r\n\r\n  const domain = utf8PercentDecode(input);\r\n  const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);\r\n  if (asciiDomain === null) {\r\n    return failure;\r\n  }\r\n\r\n  if (containsForbiddenHostCodePoint(asciiDomain)) {\r\n    return failure;\r\n  }\r\n\r\n  const ipv4Host = parseIPv4(asciiDomain);\r\n  if (typeof ipv4Host === \"number\" || ipv4Host === failure) {\r\n    return ipv4Host;\r\n  }\r\n\r\n  return asciiDomain;\r\n}\r\n\r\nfunction parseOpaqueHost(input) {\r\n  if (containsForbiddenHostCodePointExcludingPercent(input)) {\r\n    return failure;\r\n  }\r\n\r\n  let output = \"\";\r\n  const decoded = punycode.ucs2.decode(input);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);\r\n  }\r\n  return output;\r\n}\r\n\r\nfunction findLongestZeroSequence(arr) {\r\n  let maxIdx = null;\r\n  let maxLen = 1; // only find elements > 1\r\n  let currStart = null;\r\n  let currLen = 0;\r\n\r\n  for (let i = 0; i < arr.length; ++i) {\r\n    if (arr[i] !== 0) {\r\n      if (currLen > maxLen) {\r\n        maxIdx = currStart;\r\n        maxLen = currLen;\r\n      }\r\n\r\n      currStart = null;\r\n      currLen = 0;\r\n    } else {\r\n      if (currStart === null) {\r\n        currStart = i;\r\n      }\r\n      ++currLen;\r\n    }\r\n  }\r\n\r\n  // if trailing zeros\r\n  if (currLen > maxLen) {\r\n    maxIdx = currStart;\r\n    maxLen = currLen;\r\n  }\r\n\r\n  return {\r\n    idx: maxIdx,\r\n    len: maxLen\r\n  };\r\n}\r\n\r\nfunction serializeHost(host) {\r\n  if (typeof host === \"number\") {\r\n    return serializeIPv4(host);\r\n  }\r\n\r\n  // IPv6 serializer\r\n  if (host instanceof Array) {\r\n    return \"[\" + serializeIPv6(host) + \"]\";\r\n  }\r\n\r\n  return host;\r\n}\r\n\r\nfunction trimControlChars(url) {\r\n  return url.replace(/^[\\u0000-\\u001F\\u0020]+|[\\u0000-\\u001F\\u0020]+$/g, \"\");\r\n}\r\n\r\nfunction trimTabAndNewline(url) {\r\n  return url.replace(/\\u0009|\\u000A|\\u000D/g, \"\");\r\n}\r\n\r\nfunction shortenPath(url) {\r\n  const path = url.path;\r\n  if (path.length === 0) {\r\n    return;\r\n  }\r\n  if (url.scheme === \"file\" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {\r\n    return;\r\n  }\r\n\r\n  path.pop();\r\n}\r\n\r\nfunction includesCredentials(url) {\r\n  return url.username !== \"\" || url.password !== \"\";\r\n}\r\n\r\nfunction cannotHaveAUsernamePasswordPort(url) {\r\n  return url.host === null || url.host === \"\" || url.cannotBeABaseURL || url.scheme === \"file\";\r\n}\r\n\r\nfunction isNormalizedWindowsDriveLetter(string) {\r\n  return /^[A-Za-z]:$/.test(string);\r\n}\r\n\r\nfunction URLStateMachine(input, base, encodingOverride, url, stateOverride) {\r\n  this.pointer = 0;\r\n  this.input = input;\r\n  this.base = base || null;\r\n  this.encodingOverride = encodingOverride || \"utf-8\";\r\n  this.stateOverride = stateOverride;\r\n  this.url = url;\r\n  this.failure = false;\r\n  this.parseError = false;\r\n\r\n  if (!this.url) {\r\n    this.url = {\r\n      scheme: \"\",\r\n      username: \"\",\r\n      password: \"\",\r\n      host: null,\r\n      port: null,\r\n      path: [],\r\n      query: null,\r\n      fragment: null,\r\n\r\n      cannotBeABaseURL: false\r\n    };\r\n\r\n    const res = trimControlChars(this.input);\r\n    if (res !== this.input) {\r\n      this.parseError = true;\r\n    }\r\n    this.input = res;\r\n  }\r\n\r\n  const res = trimTabAndNewline(this.input);\r\n  if (res !== this.input) {\r\n    this.parseError = true;\r\n  }\r\n  this.input = res;\r\n\r\n  this.state = stateOverride || \"scheme start\";\r\n\r\n  this.buffer = \"\";\r\n  this.atFlag = false;\r\n  this.arrFlag = false;\r\n  this.passwordTokenSeenFlag = false;\r\n\r\n  this.input = punycode.ucs2.decode(this.input);\r\n\r\n  for (; this.pointer <= this.input.length; ++this.pointer) {\r\n    const c = this.input[this.pointer];\r\n    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);\r\n\r\n    // exec state machine\r\n    const ret = this[\"parse \" + this.state](c, cStr);\r\n    if (!ret) {\r\n      break; // terminate algorithm\r\n    } else if (ret === failure) {\r\n      this.failure = true;\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\nURLStateMachine.prototype[\"parse scheme start\"] = function parseSchemeStart(c, cStr) {\r\n  if (isASCIIAlpha(c)) {\r\n    this.buffer += cStr.toLowerCase();\r\n    this.state = \"scheme\";\r\n  } else if (!this.stateOverride) {\r\n    this.state = \"no scheme\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse scheme\"] = function parseScheme(c, cStr) {\r\n  if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {\r\n    this.buffer += cStr.toLowerCase();\r\n  } else if (c === 58) {\r\n    if (this.stateOverride) {\r\n      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {\r\n        return false;\r\n      }\r\n\r\n      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {\r\n        return false;\r\n      }\r\n\r\n      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === \"file\") {\r\n        return false;\r\n      }\r\n\r\n      if (this.url.scheme === \"file\" && (this.url.host === \"\" || this.url.host === null)) {\r\n        return false;\r\n      }\r\n    }\r\n    this.url.scheme = this.buffer;\r\n    this.buffer = \"\";\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n    if (this.url.scheme === \"file\") {\r\n      if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {\r\n        this.parseError = true;\r\n      }\r\n      this.state = \"file\";\r\n    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {\r\n      this.state = \"special relative or authority\";\r\n    } else if (isSpecial(this.url)) {\r\n      this.state = \"special authority slashes\";\r\n    } else if (this.input[this.pointer + 1] === 47) {\r\n      this.state = \"path or authority\";\r\n      ++this.pointer;\r\n    } else {\r\n      this.url.cannotBeABaseURL = true;\r\n      this.url.path.push(\"\");\r\n      this.state = \"cannot-be-a-base-URL path\";\r\n    }\r\n  } else if (!this.stateOverride) {\r\n    this.buffer = \"\";\r\n    this.state = \"no scheme\";\r\n    this.pointer = -1;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse no scheme\"] = function parseNoScheme(c) {\r\n  if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) {\r\n    return failure;\r\n  } else if (this.base.cannotBeABaseURL && c === 35) {\r\n    this.url.scheme = this.base.scheme;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n    this.url.fragment = \"\";\r\n    this.url.cannotBeABaseURL = true;\r\n    this.state = \"fragment\";\r\n  } else if (this.base.scheme === \"file\") {\r\n    this.state = \"file\";\r\n    --this.pointer;\r\n  } else {\r\n    this.state = \"relative\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special relative or authority\"] = function parseSpecialRelativeOrAuthority(c) {\r\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\r\n    this.state = \"special authority ignore slashes\";\r\n    ++this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    this.state = \"relative\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path or authority\"] = function parsePathOrAuthority(c) {\r\n  if (c === 47) {\r\n    this.state = \"authority\";\r\n  } else {\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse relative\"] = function parseRelative(c) {\r\n  this.url.scheme = this.base.scheme;\r\n  if (isNaN(c)) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n  } else if (c === 47) {\r\n    this.state = \"relative slash\";\r\n  } else if (c === 63) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (c === 35) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else if (isSpecial(this.url) && c === 92) {\r\n    this.parseError = true;\r\n    this.state = \"relative slash\";\r\n  } else {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice(0, this.base.path.length - 1);\r\n\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse relative slash\"] = function parseRelativeSlash(c) {\r\n  if (isSpecial(this.url) && (c === 47 || c === 92)) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"special authority ignore slashes\";\r\n  } else if (c === 47) {\r\n    this.state = \"authority\";\r\n  } else {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special authority slashes\"] = function parseSpecialAuthoritySlashes(c) {\r\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\r\n    this.state = \"special authority ignore slashes\";\r\n    ++this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    this.state = \"special authority ignore slashes\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special authority ignore slashes\"] = function parseSpecialAuthorityIgnoreSlashes(c) {\r\n  if (c !== 47 && c !== 92) {\r\n    this.state = \"authority\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse authority\"] = function parseAuthority(c, cStr) {\r\n  if (c === 64) {\r\n    this.parseError = true;\r\n    if (this.atFlag) {\r\n      this.buffer = \"%40\" + this.buffer;\r\n    }\r\n    this.atFlag = true;\r\n\r\n    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars\r\n    const len = countSymbols(this.buffer);\r\n    for (let pointer = 0; pointer < len; ++pointer) {\r\n      const codePoint = this.buffer.codePointAt(pointer);\r\n\r\n      if (codePoint === 58 && !this.passwordTokenSeenFlag) {\r\n        this.passwordTokenSeenFlag = true;\r\n        continue;\r\n      }\r\n      const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);\r\n      if (this.passwordTokenSeenFlag) {\r\n        this.url.password += encodedCodePoints;\r\n      } else {\r\n        this.url.username += encodedCodePoints;\r\n      }\r\n    }\r\n    this.buffer = \"\";\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92)) {\r\n    if (this.atFlag && this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    }\r\n    this.pointer -= countSymbols(this.buffer) + 1;\r\n    this.buffer = \"\";\r\n    this.state = \"host\";\r\n  } else {\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse hostname\"] =\r\nURLStateMachine.prototype[\"parse host\"] = function parseHostName(c, cStr) {\r\n  if (this.stateOverride && this.url.scheme === \"file\") {\r\n    --this.pointer;\r\n    this.state = \"file host\";\r\n  } else if (c === 58 && !this.arrFlag) {\r\n    if (this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    }\r\n\r\n    const host = parseHost(this.buffer, isSpecial(this.url));\r\n    if (host === failure) {\r\n      return failure;\r\n    }\r\n\r\n    this.url.host = host;\r\n    this.buffer = \"\";\r\n    this.state = \"port\";\r\n    if (this.stateOverride === \"hostname\") {\r\n      return false;\r\n    }\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92)) {\r\n    --this.pointer;\r\n    if (isSpecial(this.url) && this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    } else if (this.stateOverride && this.buffer === \"\" &&\r\n               (includesCredentials(this.url) || this.url.port !== null)) {\r\n      this.parseError = true;\r\n      return false;\r\n    }\r\n\r\n    const host = parseHost(this.buffer, isSpecial(this.url));\r\n    if (host === failure) {\r\n      return failure;\r\n    }\r\n\r\n    this.url.host = host;\r\n    this.buffer = \"\";\r\n    this.state = \"path start\";\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n  } else {\r\n    if (c === 91) {\r\n      this.arrFlag = true;\r\n    } else if (c === 93) {\r\n      this.arrFlag = false;\r\n    }\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse port\"] = function parsePort(c, cStr) {\r\n  if (isASCIIDigit(c)) {\r\n    this.buffer += cStr;\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92) ||\r\n             this.stateOverride) {\r\n    if (this.buffer !== \"\") {\r\n      const port = parseInt(this.buffer);\r\n      if (port > Math.pow(2, 16) - 1) {\r\n        this.parseError = true;\r\n        return failure;\r\n      }\r\n      this.url.port = port === defaultPort(this.url.scheme) ? null : port;\r\n      this.buffer = \"\";\r\n    }\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n    this.state = \"path start\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);\r\n\r\nURLStateMachine.prototype[\"parse file\"] = function parseFile(c) {\r\n  this.url.scheme = \"file\";\r\n\r\n  if (c === 47 || c === 92) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"file slash\";\r\n  } else if (this.base !== null && this.base.scheme === \"file\") {\r\n    if (isNaN(c)) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = this.base.query;\r\n    } else if (c === 63) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = \"\";\r\n      this.state = \"query\";\r\n    } else if (c === 35) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = this.base.query;\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    } else {\r\n      if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points\r\n          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||\r\n          (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points\r\n           !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) {\r\n        this.url.host = this.base.host;\r\n        this.url.path = this.base.path.slice();\r\n        shortenPath(this.url);\r\n      } else {\r\n        this.parseError = true;\r\n      }\r\n\r\n      this.state = \"path\";\r\n      --this.pointer;\r\n    }\r\n  } else {\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse file slash\"] = function parseFileSlash(c) {\r\n  if (c === 47 || c === 92) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"file host\";\r\n  } else {\r\n    if (this.base !== null && this.base.scheme === \"file\") {\r\n      if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {\r\n        this.url.path.push(this.base.path[0]);\r\n      } else {\r\n        this.url.host = this.base.host;\r\n      }\r\n    }\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse file host\"] = function parseFileHost(c, cStr) {\r\n  if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {\r\n    --this.pointer;\r\n    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {\r\n      this.parseError = true;\r\n      this.state = \"path\";\r\n    } else if (this.buffer === \"\") {\r\n      this.url.host = \"\";\r\n      if (this.stateOverride) {\r\n        return false;\r\n      }\r\n      this.state = \"path start\";\r\n    } else {\r\n      let host = parseHost(this.buffer, isSpecial(this.url));\r\n      if (host === failure) {\r\n        return failure;\r\n      }\r\n      if (host === \"localhost\") {\r\n        host = \"\";\r\n      }\r\n      this.url.host = host;\r\n\r\n      if (this.stateOverride) {\r\n        return false;\r\n      }\r\n\r\n      this.buffer = \"\";\r\n      this.state = \"path start\";\r\n    }\r\n  } else {\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path start\"] = function parsePathStart(c) {\r\n  if (isSpecial(this.url)) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"path\";\r\n\r\n    if (c !== 47 && c !== 92) {\r\n      --this.pointer;\r\n    }\r\n  } else if (!this.stateOverride && c === 63) {\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (!this.stateOverride && c === 35) {\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else if (c !== undefined) {\r\n    this.state = \"path\";\r\n    if (c !== 47) {\r\n      --this.pointer;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path\"] = function parsePath(c) {\r\n  if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||\r\n      (!this.stateOverride && (c === 63 || c === 35))) {\r\n    if (isSpecial(this.url) && c === 92) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (isDoubleDot(this.buffer)) {\r\n      shortenPath(this.url);\r\n      if (c !== 47 && !(isSpecial(this.url) && c === 92)) {\r\n        this.url.path.push(\"\");\r\n      }\r\n    } else if (isSingleDot(this.buffer) && c !== 47 &&\r\n               !(isSpecial(this.url) && c === 92)) {\r\n      this.url.path.push(\"\");\r\n    } else if (!isSingleDot(this.buffer)) {\r\n      if (this.url.scheme === \"file\" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {\r\n        if (this.url.host !== \"\" && this.url.host !== null) {\r\n          this.parseError = true;\r\n          this.url.host = \"\";\r\n        }\r\n        this.buffer = this.buffer[0] + \":\";\r\n      }\r\n      this.url.path.push(this.buffer);\r\n    }\r\n    this.buffer = \"\";\r\n    if (this.url.scheme === \"file\" && (c === undefined || c === 63 || c === 35)) {\r\n      while (this.url.path.length > 1 && this.url.path[0] === \"\") {\r\n        this.parseError = true;\r\n        this.url.path.shift();\r\n      }\r\n    }\r\n    if (c === 63) {\r\n      this.url.query = \"\";\r\n      this.state = \"query\";\r\n    }\r\n    if (c === 35) {\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    }\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.buffer += percentEncodeChar(c, isPathPercentEncode);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse cannot-be-a-base-URL path\"] = function parseCannotBeABaseURLPath(c) {\r\n  if (c === 63) {\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (c === 35) {\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else {\r\n    // TODO: Add: not a URL code point\r\n    if (!isNaN(c) && c !== 37) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (c === 37 &&\r\n        (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n         !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (!isNaN(c)) {\r\n      this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse query\"] = function parseQuery(c, cStr) {\r\n  if (isNaN(c) || (!this.stateOverride && c === 35)) {\r\n    if (!isSpecial(this.url) || this.url.scheme === \"ws\" || this.url.scheme === \"wss\") {\r\n      this.encodingOverride = \"utf-8\";\r\n    }\r\n\r\n    const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead\r\n    for (let i = 0; i < buffer.length; ++i) {\r\n      if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||\r\n          buffer[i] === 0x3C || buffer[i] === 0x3E) {\r\n        this.url.query += percentEncode(buffer[i]);\r\n      } else {\r\n        this.url.query += String.fromCodePoint(buffer[i]);\r\n      }\r\n    }\r\n\r\n    this.buffer = \"\";\r\n    if (c === 35) {\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    }\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse fragment\"] = function parseFragment(c) {\r\n  if (isNaN(c)) { // do nothing\r\n  } else if (c === 0x0) {\r\n    this.parseError = true;\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nfunction serializeURL(url, excludeFragment) {\r\n  let output = url.scheme + \":\";\r\n  if (url.host !== null) {\r\n    output += \"//\";\r\n\r\n    if (url.username !== \"\" || url.password !== \"\") {\r\n      output += url.username;\r\n      if (url.password !== \"\") {\r\n        output += \":\" + url.password;\r\n      }\r\n      output += \"@\";\r\n    }\r\n\r\n    output += serializeHost(url.host);\r\n\r\n    if (url.port !== null) {\r\n      output += \":\" + url.port;\r\n    }\r\n  } else if (url.host === null && url.scheme === \"file\") {\r\n    output += \"//\";\r\n  }\r\n\r\n  if (url.cannotBeABaseURL) {\r\n    output += url.path[0];\r\n  } else {\r\n    for (const string of url.path) {\r\n      output += \"/\" + string;\r\n    }\r\n  }\r\n\r\n  if (url.query !== null) {\r\n    output += \"?\" + url.query;\r\n  }\r\n\r\n  if (!excludeFragment && url.fragment !== null) {\r\n    output += \"#\" + url.fragment;\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction serializeOrigin(tuple) {\r\n  let result = tuple.scheme + \"://\";\r\n  result += serializeHost(tuple.host);\r\n\r\n  if (tuple.port !== null) {\r\n    result += \":\" + tuple.port;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports.serializeURL = serializeURL;\r\n\r\nmodule.exports.serializeURLOrigin = function (url) {\r\n  // https://url.spec.whatwg.org/#concept-url-origin\r\n  switch (url.scheme) {\r\n    case \"blob\":\r\n      try {\r\n        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));\r\n      } catch (e) {\r\n        // serializing an opaque origin returns \"null\"\r\n        return \"null\";\r\n      }\r\n    case \"ftp\":\r\n    case \"gopher\":\r\n    case \"http\":\r\n    case \"https\":\r\n    case \"ws\":\r\n    case \"wss\":\r\n      return serializeOrigin({\r\n        scheme: url.scheme,\r\n        host: url.host,\r\n        port: url.port\r\n      });\r\n    case \"file\":\r\n      // spec says \"exercise to the reader\", chrome says \"file://\"\r\n      return \"file://\";\r\n    default:\r\n      // serializing an opaque origin returns \"null\"\r\n      return \"null\";\r\n  }\r\n};\r\n\r\nmodule.exports.basicURLParse = function (input, options) {\r\n  if (options === undefined) {\r\n    options = {};\r\n  }\r\n\r\n  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);\r\n  if (usm.failure) {\r\n    return \"failure\";\r\n  }\r\n\r\n  return usm.url;\r\n};\r\n\r\nmodule.exports.setTheUsername = function (url, username) {\r\n  url.username = \"\";\r\n  const decoded = punycode.ucs2.decode(username);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\r\n  }\r\n};\r\n\r\nmodule.exports.setThePassword = function (url, password) {\r\n  url.password = \"\";\r\n  const decoded = punycode.ucs2.decode(password);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\r\n  }\r\n};\r\n\r\nmodule.exports.serializeHost = serializeHost;\r\n\r\nmodule.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;\r\n\r\nmodule.exports.serializeInteger = function (integer) {\r\n  return String(integer);\r\n};\r\n\r\nmodule.exports.parseURL = function (input, options) {\r\n  if (options === undefined) {\r\n    options = {};\r\n  }\r\n\r\n  // We don't handle blobs, so this just delegates:\r\n  return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });\r\n};\r\n","\"use strict\";\n\nmodule.exports.mixin = function mixin(target, source) {\n  const keys = Object.getOwnPropertyNames(source);\n  for (let i = 0; i < keys.length; ++i) {\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n};\n\nmodule.exports.wrapperSymbol = Symbol(\"wrapper\");\nmodule.exports.implSymbol = Symbol(\"impl\");\n\nmodule.exports.wrapperForImpl = function (impl) {\n  return impl[module.exports.wrapperSymbol];\n};\n\nmodule.exports.implForWrapper = function (wrapper) {\n  return wrapper[module.exports.implSymbol];\n};\n\n","module.exports = require(\"child_process\");","module.exports = require(\"fs\");","module.exports = require(\"punycode\");","module.exports = require(\"readline\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"stream\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"http\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"url\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"https\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"zlib\");","import Stream from 'stream';\nimport http from 'http';\nimport Url from 'url';\nimport whatwgUrl from 'whatwg-url';\nimport https from 'https';\nimport zlib from 'zlib';\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\nconst URL = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\n/**\n * Wrapper around `new URL` to handle arbitrary URLs\n *\n * @param  {string} urlStr\n * @return {void}\n */\nfunction parseURL(urlStr) {\n\t/*\n \tCheck whether the URL is absolute or not\n \t\tScheme: https://tools.ietf.org/html/rfc3986#section-3.1\n \tAbsolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n */\n\tif (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.exec(urlStr)) {\n\t\turlStr = new URL(urlStr).toString();\n\t}\n\n\t// Fallback to old implementation for arbitrary URLs\n\treturn parse_url(urlStr);\n}\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parseURL(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parseURL(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parseURL(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\nconst URL$1 = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\n\nconst isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {\n\tconst orig = new URL$1(original).hostname;\n\tconst dest = new URL$1(destination).hostname;\n\n\treturn orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);\n};\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\t\t\tfinalize();\n\t\t});\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tlet locationURL = null;\n\t\t\t\ttry {\n\t\t\t\t\tlocationURL = location === null ? null : new URL$1(location, request.url).toString();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// error here can only be invalid URL in Location: header\n\t\t\t\t\t// do not throw when options.redirect == manual\n\t\t\t\t\t// let the user extract the errorneous redirect URL\n\t\t\t\t\tif (request.redirect !== 'manual') {\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (!isDomainOrSubdomain(request.url, locationURL)) {\n\t\t\t\t\t\t\tfor (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {\n\t\t\t\t\t\t\t\trequestOpts.headers.delete(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nexport default fetch;\nexport { Headers, Request, Response, FetchError };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const toNum = (x: unknown): number => Number(x); //Should also support 0b and 0x\r\nexport const slice = <T>(arr: T[], start?: number, end?: number): T[] =>\r\n  arr.slice(start, end);\r\nexport const splice = <T>(arr: T[], start: number, numDel?: number): T[] =>\r\n  arr.splice(start, numDel);\r\nexport const len = <T>(arr: T[]): number => arr.length;\r\nexport const slen = (str: string): number => str.length;\r\nexport const isNum = (x: unknown): x is number =>\r\n  x !== \"\" && !Number.isNaN(Number(x));\r\nexport const isArray = <T>(x: unknown): x is T[] => Array.isArray(x);\r\nexport const substr = (str: string, start: number, length?: number): string =>\r\n  str.substring(start, start + (length ?? str.length));\r\nexport const strIdx = (str: string, idx: number): string => str[idx];\r\nexport const sub = (x: string, s: string): boolean => x.includes(s);\r\nexport const subIdx = (x: string, s: string) => x.indexOf(s);\r\nexport const has = <T>(x: T[], y: T): boolean => x.includes(y);\r\nexport const starts = (str: string, prefix: string): boolean =>\r\n  str.startsWith(prefix);\r\nexport const ends = (str: string, x: string): boolean => str.endsWith(x);\r\nexport const replace = (str: string, what: string, to: string): string =>\r\n  str.split(what).join(to);\r\nexport const rreplace = (str: string, what: string, to: string) =>\r\n  str.replace(new RegExp(what, \"g\"), to);\r\nexport const flat = <T>(arr: T[][]): T[] => arr.flat(); //e.g. [[0], [1], []] => [0, 1]\r\nexport const concat = <T>(a: T[], b: T[]): T[] => a.concat(b);\r\nexport const push = <T>(arr: T[], add: T[]) => arr.push(...add);\r\nexport const sortBy = <T>(arr: T[], by: (a: T, b: T) => number) => arr.sort(by);\r\nexport const reverse = <T>(arr: T[]) => arr.reverse();\r\nexport const lowerCase = (str: string) => str.toLowerCase();\r\nexport const upperCase = (str: string) => str.toUpperCase();\r\nexport const trim = (str: string) => str.trim();\r\nexport const trimStart = (str: string) => str.trimStart();\r\nexport const trimEnd = (str: string) => str.trimEnd();\r\nexport const padEnd = (str: string, by: number) => str.padEnd(by);\r\nexport const charCode = (str: string): number => str.charCodeAt(0);\r\nexport const codeChar = (num: number): string => String.fromCharCode(num);\r\nexport const randNum = (a: number, b: number) => a + Math.random() * (b - a);\r\nexport const randInt = (a: number, b: number) => Math.floor(randNum(a, b));\r\nexport const range = (len: number) => [...Array(len).keys()];\r\nexport const objKeys = (x: object) => Object.keys(x);\r\nexport const getTimeMs = () => new Date().getTime();\r\nexport const abs = Math.abs;\r\nexport const min = Math.min;\r\nexport const max = Math.max;\r\nexport const sin = Math.sin;\r\nexport const cos = Math.cos;\r\nexport const tan = Math.tan;\r\nexport const sinh = Math.sinh;\r\nexport const cosh = Math.cosh;\r\nexport const tanh = Math.tanh;\r\nexport const asin = Math.asin;\r\nexport const acos = Math.acos;\r\nexport const atan = Math.atan;\r\nexport const sqrt = Math.sqrt;\r\nexport const round = Math.round;\r\nexport const floor = Math.floor;\r\nexport const ceil = Math.ceil;\r\nexport const sign = Math.sign;\r\nexport const logn = Math.log;\r\nexport const log2 = Math.log2;\r\nexport const log10 = Math.log10;\r\n","export type Val =\r\n  | { t: \"vec\"; v: Val[] }\r\n  | { t: \"str\" | \"func\" | \"key\" | \"ref\"; v: string }\r\n  | { t: \"null\"; v: undefined }\r\n  | { t: \"wild\"; v: undefined }\r\n  | { t: \"bool\"; v: boolean }\r\n  | { t: \"num\"; v: number }\r\n  | { t: \"clo\"; v: Func }\r\n  | { t: \"dict\"; v: Dict }\r\n  | { t: \"ext\"; v: unknown };\r\n\r\nexport type ErrCtx = { invokeId: string; line: number; col: number };\r\nexport type InvokeError = { e: string; m: string; errCtx: ErrCtx };\r\nexport type ValOrErr =\r\n  | { kind: \"val\"; value: Val }\r\n  | { kind: \"err\"; err: string };\r\n/**\r\n * @summary \"empty\" occurs when there was only function declaration;\r\n *          \"val\" occurs when there were no errors and there is a final value;\r\n *          \"errors\" occurs when there were any errors.\r\n */\r\nexport type InvokeResult =\r\n  | { kind: \"empty\" }\r\n  | { kind: \"val\"; value: Val }\r\n  | { kind: \"errors\"; errors: InvokeError[] };\r\n\r\nexport type Dict = {\r\n  keys: Val[];\r\n  vals: Val[];\r\n};\r\n\r\nexport type Func = {\r\n  name?: string;\r\n  ins: Ins[];\r\n};\r\nexport type Funcs = { [key: string]: Func };\r\nexport type Env = {\r\n  funcs: Funcs;\r\n  vars: { [key: string]: Val };\r\n};\r\n\r\n/** A context supplied with an Insitux invocation to provide its environment. */\r\nexport type Ctx = {\r\n  /** Called to set an external variable, returning nothing or an error. */\r\n  set?: (key: string, val: Val) => undefined | string;\r\n  /** Called to retrieve an external variable,\r\n   * returning the value or an error. */\r\n  get?: (key: string) => ValOrErr;\r\n  /** Called to print data out of Insitux. */\r\n  print: (str: string, withNewline: boolean) => void;\r\n  /** Extra function definitions to make available within this invocation */\r\n  functions: ExternalFunctions;\r\n  /** Called when Insitux cannot find a function definition otherwise.\r\n   * You should return an error if unknown externally too. */\r\n  exe?: (name: string, args: Val[]) => ValOrErr;\r\n  /** Function and variable definitions, retained by you for each invocation. */\r\n  env: Env;\r\n  /** The number of loops an invocation is permitted. */\r\n  loopBudget: number;\r\n  /** The total length of all `range` calls permitted. */\r\n  rangeBudget: number;\r\n  /** The total number of function calls permitted. */\r\n  callBudget: number;\r\n  /** The total number of explicit recursions permitted.\r\n   * Explicit recursions are unlikely to cause a stack-overflow,\r\n   * rather this effectively limits the time an Insitux program may hang for. */\r\n  recurBudget: number;\r\n};\r\n\r\nexport const defaultCtx = {\r\n  env: { funcs: {}, vars: {} },\r\n  loopBudget: 1e7,\r\n  rangeBudget: 1e6,\r\n  callBudget: 1e8,\r\n  recurBudget: 1e4,\r\n};\r\n\r\nexport type ParamsShape = { name: string; position: number[] }[];\r\nexport type Closure = {\r\n  readonly name: string;\r\n  readonly length: number;\r\n  captures: boolean[];\r\n  derefs: Ins[];\r\n};\r\n\r\nexport type Ins = { errCtx: ErrCtx } & (\r\n  | { typ: \"npa\" | \"upa\"; value: number; text: string } //Named and Unnamed parameters\r\n  | { typ: \"dpa\"; value: number[] } //Destructuring parameters\r\n  | { typ: \"var\" | \"let\" | \"ref\"; value: string }\r\n  | { typ: \"dva\" | \"dle\"; value: ParamsShape } //Destructuring var/let\r\n  | { typ: \"exe\"; value: number } //Execute last stack value, number of args\r\n  | { typ: \"exa\"; value: number } //Execute last stack value, number of args, with arity check\r\n  | { typ: \"or\" | \"if\" | \"jmp\" | \"loo\" | \"cat\" | \"mat\"; value: number } //Number of instructions\r\n  | { typ: \"ret\"; value: boolean } //Return, with value?\r\n  | { typ: \"pop\"; value: number } //Truncate stack, by number of values\r\n  | { typ: \"clo\"; value: Closure } //Closure/partial\r\n  | { typ: \"val\"; value: Val }\r\n);\r\n\r\n/** Definition of an operation in Insitux,\r\n * with guarantees made for arity (number of parameters) and parameter types.\r\n * Return type is specified to inform the parse-time type-checker. */\r\nexport type Operation = {\r\n  minArity?: number;\r\n  maxArity?: number;\r\n  exactArity?: number;\r\n  numeric?: true | \"in only\";\r\n  params?: (\"any\" | Val[\"t\"] | Val[\"t\"][])[];\r\n  returns?: Val[\"t\"][];\r\n};\r\nexport type ExternalHandler = (params: Val[]) => ValOrErr;\r\nexport type ExternalFunction = {\r\n  definition: Operation;\r\n  handler: ExternalHandler;\r\n};\r\nexport type ExternalFunctions = { [name: string]: ExternalFunction };\r\n\r\nexport const ops: {\r\n  [name: string]: Operation & { external?: boolean };\r\n} = {\r\n  print: { returns: [\"null\"] },\r\n  \"print-str\": { returns: [\"null\"] },\r\n  \"!\": { exactArity: 1, returns: [\"bool\"] },\r\n  \"=\": { minArity: 2, returns: [\"bool\"] },\r\n  \"!=\": { minArity: 2, returns: [\"bool\"] },\r\n  \"+\": { minArity: 2, numeric: true },\r\n  \"-\": { minArity: 2, numeric: true },\r\n  \"*\": { minArity: 2, numeric: true },\r\n  \"/\": { minArity: 2, numeric: true },\r\n  \"//\": { minArity: 2, numeric: true },\r\n  \"**\": { minArity: 1, maxArity: 2, numeric: true },\r\n  \"<\": { minArity: 2, numeric: true },\r\n  \">\": { minArity: 2, numeric: true },\r\n  \"<=\": { minArity: 2, numeric: true },\r\n  \">=\": { minArity: 2, numeric: true },\r\n  \"fast=\": { exactArity: 2 },\r\n  \"fast!=\": { exactArity: 2 },\r\n  \"fast+\": { exactArity: 2, numeric: true },\r\n  \"fast-\": { exactArity: 2, numeric: true },\r\n  \"fast*\": { exactArity: 2, numeric: true },\r\n  \"fast/\": { exactArity: 2, numeric: true },\r\n  \"fast//\": { exactArity: 2, numeric: true },\r\n  \"fast<\": { exactArity: 2, numeric: true },\r\n  \"fast>\": { exactArity: 2, numeric: true },\r\n  \"fast<=\": { exactArity: 2, numeric: true },\r\n  \"fast>=\": { exactArity: 2, numeric: true },\r\n  neg: { exactArity: 1, numeric: true },\r\n  inc: { exactArity: 1, numeric: true },\r\n  dec: { exactArity: 1, numeric: true },\r\n  min: { minArity: 2, numeric: true },\r\n  max: { minArity: 2, numeric: true },\r\n  abs: { exactArity: 1, numeric: true },\r\n  sqrt: { exactArity: 1, numeric: true },\r\n  round: { minArity: 1, maxArity: 2, numeric: true },\r\n  floor: { exactArity: 1, numeric: true },\r\n  ceil: { exactArity: 1, numeric: true },\r\n  logn: { exactArity: 1, numeric: true },\r\n  log2: { exactArity: 1, numeric: true },\r\n  log10: { exactArity: 1, numeric: true },\r\n  and: { minArity: 1 },\r\n  or: { minArity: 1 },\r\n  xor: { exactArity: 2 },\r\n  \"&\": { exactArity: 2, numeric: true },\r\n  \"|\": { exactArity: 2, numeric: true },\r\n  \"^\": { exactArity: 2, numeric: true },\r\n  \"~\": { exactArity: 1, numeric: true },\r\n  \"<<\": { exactArity: 2, numeric: true },\r\n  \">>\": { exactArity: 2, numeric: true },\r\n  \">>>\": { exactArity: 2, numeric: true },\r\n  \"odd?\": { exactArity: 1, numeric: \"in only\", returns: [\"bool\"] },\r\n  \"even?\": { exactArity: 1, numeric: \"in only\", returns: [\"bool\"] },\r\n  \"pos?\": { exactArity: 1, numeric: \"in only\", returns: [\"bool\"] },\r\n  \"neg?\": { exactArity: 1, numeric: \"in only\", returns: [\"bool\"] },\r\n  \"zero?\": { exactArity: 1, numeric: \"in only\", returns: [\"bool\"] },\r\n  \"null?\": { exactArity: 1, returns: [\"bool\"] },\r\n  \"num?\": { exactArity: 1, returns: [\"bool\"] },\r\n  \"bool?\": { exactArity: 1, returns: [\"bool\"] },\r\n  \"str?\": { exactArity: 1, returns: [\"bool\"] },\r\n  \"vec?\": { exactArity: 1, returns: [\"bool\"] },\r\n  \"dict?\": { exactArity: 1, returns: [\"bool\"] },\r\n  \"key?\": { exactArity: 1, returns: [\"bool\"] },\r\n  \"func?\": { exactArity: 1, returns: [\"bool\"] },\r\n  \"wild?\": { exactArity: 1, returns: [\"bool\"] },\r\n  \"ext?\": { exactArity: 1, returns: [\"bool\"] },\r\n  \"type-of\": { exactArity: 1, returns: [\"str\"] },\r\n  rem: { minArity: 2, numeric: true },\r\n  sin: { exactArity: 1, numeric: true },\r\n  cos: { exactArity: 1, numeric: true },\r\n  tan: { exactArity: 1, numeric: true },\r\n  asin: { exactArity: 1, numeric: true },\r\n  acos: { exactArity: 1, numeric: true },\r\n  atan: { exactArity: 1, numeric: true },\r\n  sinh: { exactArity: 1, numeric: true },\r\n  cosh: { exactArity: 1, numeric: true },\r\n  tanh: { exactArity: 1, numeric: true },\r\n  vec: { returns: [\"vec\"] },\r\n  dict: { returns: [\"dict\"] },\r\n  len: { exactArity: 1, params: [[\"str\", \"vec\", \"dict\"]], returns: [\"num\"] },\r\n  \"to-num\": {\r\n    exactArity: 1,\r\n    params: [[\"str\", \"num\"]],\r\n    returns: [\"num\", \"null\"],\r\n  },\r\n  \"to-key\": { exactArity: 1, params: [[\"str\", \"num\"]], returns: [\"key\"] },\r\n  \"to-vec\": { exactArity: 1, params: [[\"str\", \"dict\"]], returns: [\"vec\"] },\r\n  \"substr?\": { exactArity: 2, params: [\"str\", \"str\"], returns: [\"bool\"] },\r\n  idx: {\r\n    exactArity: 2,\r\n    params: [\"any\", [\"str\", \"vec\"]],\r\n    returns: [\"num\"],\r\n  },\r\n  \"set-at\": {\r\n    exactArity: 3,\r\n    params: [\"vec\", \"any\", [\"vec\", \"dict\"]],\r\n    returns: [\"vec\", \"dict\"],\r\n  },\r\n  juxt: { returns: [\"clo\"] },\r\n  \"pos-juxt\": { returns: [\"clo\"] },\r\n  map: { minArity: 2, returns: [\"vec\"] },\r\n  for: { minArity: 2, returns: [\"vec\"] },\r\n  reduce: { minArity: 2, maxArity: 3 },\r\n  reductions: { minArity: 2, maxArity: 3 },\r\n  filter: {\r\n    minArity: 2,\r\n    params: [\"any\", [\"vec\", \"dict\", \"str\"]],\r\n    returns: [\"vec\", \"str\", \"dict\"],\r\n  },\r\n  remove: {\r\n    minArity: 2,\r\n    params: [\"any\", [\"vec\", \"dict\", \"str\"]],\r\n    returns: [\"vec\", \"str\", \"dict\"],\r\n  },\r\n  find: { minArity: 2, params: [\"any\", [\"vec\", \"dict\", \"str\"]] },\r\n  count: {\r\n    minArity: 2,\r\n    params: [\"any\", [\"vec\", \"dict\", \"str\"]],\r\n    returns: [\"num\"],\r\n  },\r\n  repeat: { minArity: 2, params: [\"any\", \"num\"] },\r\n  times: { minArity: 2, params: [\"num\", \"any\"] },\r\n  str: { returns: [\"str\"] },\r\n  strn: { returns: [\"str\"] },\r\n  rand: { maxArity: 2, numeric: true, returns: [\"num\"] },\r\n  \"rand-int\": { maxArity: 2, numeric: true, returns: [\"num\"] },\r\n  \".\": { minArity: 1 },\r\n  \"..\": { minArity: 2 },\r\n  \"...\": { minArity: 2 },\r\n  into: {\r\n    exactArity: 2,\r\n    params: [\r\n      [\"vec\", \"dict\"],\r\n      [\"vec\", \"dict\"],\r\n    ],\r\n    returns: [\"vec\", \"dict\"],\r\n  },\r\n  assoc: {\r\n    exactArity: 3,\r\n    params: [\"any\", \"any\", \"dict\"],\r\n    returns: [\"dict\"],\r\n  },\r\n  omit: {\r\n    exactArity: 2,\r\n    params: [\"any\", \"dict\"],\r\n    returns: [\"dict\"],\r\n  },\r\n  drop: {\r\n    exactArity: 2,\r\n    params: [\"num\", \"vec\"],\r\n    returns: [\"vec\"],\r\n  },\r\n  insert: {\r\n    exactArity: 3,\r\n    params: [\"any\", \"num\", \"vec\"],\r\n    returns: [\"vec\"],\r\n  },\r\n  append: {\r\n    exactArity: 2,\r\n    params: [\"any\", \"vec\"],\r\n    returns: [\"vec\"],\r\n  },\r\n  prepend: {\r\n    exactArity: 2,\r\n    params: [\"any\", \"vec\"],\r\n    returns: [\"vec\"],\r\n  },\r\n  sect: {\r\n    minArity: 1,\r\n    maxArity: 3,\r\n    params: [[\"vec\", \"str\"], \"num\", \"num\"],\r\n    returns: [\"vec\", \"str\"],\r\n  },\r\n  skip: {\r\n    exactArity: 2,\r\n    params: [\"num\", [\"vec\", \"str\"]],\r\n    returns: [\"vec\", \"str\"],\r\n  },\r\n  first: {\r\n    exactArity: 2,\r\n    params: [\"num\", [\"vec\", \"str\"]],\r\n    returns: [\"vec\", \"str\"],\r\n  },\r\n  last: {\r\n    exactArity: 2,\r\n    params: [\"num\", [\"vec\", \"str\"]],\r\n    returns: [\"vec\", \"str\"],\r\n  },\r\n  crop: {\r\n    exactArity: 3,\r\n    params: [\"num\", \"num\", [\"vec\", \"str\"]],\r\n    returns: [\"vec\", \"str\"],\r\n  },\r\n  reverse: { exactArity: 1, params: [[\"vec\", \"str\"]], returns: [\"vec\", \"str\"] },\r\n  flatten: {\r\n    exactArity: 1,\r\n    params: [\"vec\"],\r\n    returns: [\"vec\"],\r\n  },\r\n  shuffle: {\r\n    exactArity: 1,\r\n    params: [\"vec\"],\r\n    returns: [\"vec\"],\r\n  },\r\n  sample: {\r\n    exactArity: 2,\r\n    params: [\"num\", \"vec\"],\r\n    returns: [\"vec\"],\r\n  },\r\n  sort: {\r\n    exactArity: 1,\r\n    params: [[\"vec\", \"str\"]],\r\n    returns: [\"vec\"],\r\n  },\r\n  \"sort-by\": {\r\n    exactArity: 2,\r\n    params: [\"any\", [\"vec\", \"dict\", \"str\"]],\r\n    returns: [\"vec\"],\r\n  },\r\n  distinct: {\r\n    returns: [\"vec\"],\r\n  },\r\n  \"group-by\": {\r\n    exactArity: 2,\r\n    params: [\"any\", [\"vec\", \"dict\", \"str\"]],\r\n    returns: [\"dict\"],\r\n  },\r\n  \"part-by\": {\r\n    exactArity: 2,\r\n    params: [\"any\", [\"vec\", \"dict\", \"str\"]],\r\n    returns: [\"vec\"],\r\n  },\r\n  freqs: {\r\n    exactArity: 1,\r\n    params: [[\"vec\", \"str\"]],\r\n    returns: [\"dict\"],\r\n  },\r\n  keys: { exactArity: 1, params: [\"dict\"] },\r\n  vals: { exactArity: 1, params: [\"dict\"] },\r\n  do: { minArity: 1 },\r\n  val: { minArity: 1 },\r\n  range: { minArity: 1, maxArity: 3, numeric: \"in only\", returns: [\"vec\"] },\r\n  \"empty?\": {\r\n    exactArity: 1,\r\n    params: [[\"str\", \"vec\", \"dict\"]],\r\n    returns: [\"bool\"],\r\n  },\r\n  split: { exactArity: 2, params: [\"str\", \"str\"], returns: [\"vec\"] },\r\n  join: {\r\n    exactArity: 2,\r\n    params: [\"str\", [\"vec\", \"dict\", \"str\"]],\r\n    returns: [\"str\"],\r\n  },\r\n  replace: {\r\n    exactArity: 3,\r\n    params: [\"str\", \"str\", \"str\"],\r\n    returns: [\"str\"],\r\n  },\r\n  rreplace: {\r\n    exactArity: 3,\r\n    params: [\"str\", \"str\", \"str\"],\r\n    returns: [\"str\"],\r\n  },\r\n  \"starts?\": { exactArity: 2, params: [\"str\", \"str\"], returns: [\"bool\"] },\r\n  \"ends?\": { exactArity: 2, params: [\"str\", \"str\"], returns: [\"bool\"] },\r\n  \"lower-case\": { exactArity: 1, params: [\"str\"], returns: [\"str\"] },\r\n  \"upper-case\": { exactArity: 1, params: [\"str\"], returns: [\"str\"] },\r\n  trim: { exactArity: 1, params: [\"str\"], returns: [\"str\"] },\r\n  \"trim-start\": { exactArity: 1, params: [\"str\"], returns: [\"str\"] },\r\n  \"trim-end\": { exactArity: 1, params: [\"str\"], returns: [\"str\"] },\r\n  \"str*\": { exactArity: 2, params: [\"str\", \"num\"], returns: [\"str\"] },\r\n  \"char-code\": {\r\n    minArity: 1,\r\n    maxArity: 2,\r\n    params: [[\"str\", \"num\"], \"num\"],\r\n    returns: [\"str\", \"num\", \"null\"],\r\n  },\r\n  time: { exactArity: 0, returns: [\"num\"] },\r\n  version: { exactArity: 0, returns: [\"num\"] },\r\n  tests: { minArity: 0, maxArity: 1, params: [\"bool\"], returns: [\"str\"] },\r\n  symbols: { exactArity: 0, returns: [\"vec\"] },\r\n  eval: { exactArity: 1, params: [\"str\"] },\r\n  about: { exactArity: 1, params: [[\"str\", \"func\"]], returns: [\"dict\"] },\r\n  reset: { exactArity: 0 },\r\n  recur: {},\r\n};\r\n\r\nexport const syntaxes = [\r\n  \"function\",\r\n  \"fn\",\r\n  \"var\",\r\n  \"let\",\r\n  \"var!\",\r\n  \"let!\",\r\n  \"return\",\r\n  \"if\",\r\n  \"if!\",\r\n  \"when\",\r\n  \"unless\",\r\n  \"while\",\r\n  \"loop\",\r\n  \"match\",\r\n  \"catch\",\r\n];\r\n\r\nexport const typeNames = {\r\n  null: \"null\",\r\n  str: \"string\",\r\n  num: \"number\",\r\n  bool: \"boolean\",\r\n  key: \"keyword\",\r\n  ref: \"reference\",\r\n  vec: \"vector\",\r\n  dict: \"dictionary\",\r\n  func: \"function\",\r\n  clo: \"closure\",\r\n  wild: \"wildcard\",\r\n  ext: \"external\",\r\n};\r\n\r\nexport const assertUnreachable = (_x: never): never => <never>0;\r\n","import { has, isArray, len } from \"./poly-fills\";\r\nimport { ErrCtx, InvokeError, ops, typeNames, Val } from \"./types\";\r\n\r\nexport const asBoo = (val: Val) =>\r\n  val.t === \"bool\" ? val.v : val.t !== \"null\";\r\n\r\nexport function arityCheck(op: string, nArg: number, errCtx: ErrCtx) {\r\n  const { exactArity, maxArity, minArity } = ops[op];\r\n  const aErr = (msg: string, amount: number) => [\r\n    <InvokeError>{\r\n      e: \"Arity\",\r\n      m: `${op} needs ${msg} argument${amount !== 1 ? \"s\" : \"\"}, not ${nArg}`,\r\n      errCtx,\r\n    },\r\n  ];\r\n  if (exactArity !== undefined) {\r\n    if (nArg !== exactArity) {\r\n      return aErr(`exactly ${exactArity}`, exactArity);\r\n    }\r\n  } else {\r\n    if (minArity && !maxArity && nArg < minArity) {\r\n      return aErr(`at least ${minArity}`, minArity);\r\n    } else if (!minArity && maxArity && nArg > maxArity) {\r\n      return aErr(`at most ${maxArity}`, maxArity);\r\n    } else if (minArity && maxArity && (nArg < minArity || nArg > maxArity)) {\r\n      return aErr(`between ${minArity} and ${maxArity}`, maxArity);\r\n    }\r\n  }\r\n}\r\n\r\nexport function typeCheck(\r\n  op: string,\r\n  args: Val[\"t\"][][],\r\n  errCtx: ErrCtx,\r\n  optimistic = false,\r\n): InvokeError[] | undefined {\r\n  const { params: types, numeric: onlyNum } = ops[op];\r\n  const nArg = len(args);\r\n  if (onlyNum) {\r\n    const nonNumArgIdx = args.findIndex(\r\n      a =>\r\n        !!len(a) && (optimistic ? !a.find(t => t === \"num\") : a[0] !== \"num\"),\r\n    );\r\n    if (nonNumArgIdx === -1) {\r\n      return;\r\n    }\r\n    const names = args[nonNumArgIdx]!.map(t => typeNames[t]).join(\", \");\r\n    return [\r\n      typeErr(`${op} takes numeric arguments only, not ${names}`, errCtx),\r\n    ];\r\n  }\r\n  if (!types) {\r\n    return;\r\n  }\r\n  const typeViolations = types\r\n    .map((need, i) => {\r\n      if (i >= nArg || !args[i] || need === \"any\") {\r\n        return false;\r\n      }\r\n      const argTypes = args[i]!;\r\n      if (isArray(need)) {\r\n        if (\r\n          optimistic\r\n            ? !len(argTypes) || argTypes.some(t => has(need, t))\r\n            : len(argTypes) === 1 && has(need, argTypes[0])\r\n        ) {\r\n          return false;\r\n        }\r\n        const names = argTypes.map(t => typeNames[t]);\r\n        const needs = need.map(t => typeNames[t]).join(\", \");\r\n        return `argument ${i + 1} must be either: ${needs}, not ${names}`;\r\n      } else {\r\n        if (\r\n          optimistic\r\n            ? !len(argTypes) || has(argTypes, need)\r\n            : len(argTypes) === 1 && need === argTypes[0]\r\n        ) {\r\n          return false;\r\n        }\r\n        const names = argTypes.map(t => typeNames[t]);\r\n        return `argument ${i + 1} must be ${typeNames[need]}, not ${names}`;\r\n      }\r\n    })\r\n    .filter(r => !!r);\r\n  return len(typeViolations)\r\n    ? typeViolations.map(v => typeErr(<string>v, errCtx))\r\n    : undefined;\r\n}\r\n\r\nexport const typeErr = (m: string, errCtx: ErrCtx): InvokeError => ({\r\n  e: \"Type\",\r\n  m,\r\n  errCtx,\r\n});\r\n\r\nexport function numOpErr(errCtx: ErrCtx, types: Val[\"t\"][]): InvokeError[] {\r\n  const names = types.map(t => typeNames[t]).join(\", \");\r\n  return [\r\n    typeErr(\r\n      `number as operation argument must be string, vector, or dictionary, not ${names}`,\r\n      errCtx,\r\n    ),\r\n  ];\r\n}\r\n\r\nexport function keyOpErr(errCtx: ErrCtx, types: Val[\"t\"][]): InvokeError[] {\r\n  const names = types.map(t => typeNames[t]).join(\", \");\r\n  return [\r\n    typeErr(\r\n      `keyword as operation argument must be dictionary or vector, not ${names}`,\r\n      errCtx,\r\n    ),\r\n  ];\r\n}\r\n","import { has, len, push, slice } from \"./poly-fills\";\r\nimport { Closure, Func, Ins, Val } from \"./types\";\r\n\r\n/** Declare a closure from instructions and other info, calculating its\r\n * captures ahead-of-time. */\r\nexport function makeClosure(\r\n  name: string,\r\n  outerParams: string[],\r\n  cloParams: string[],\r\n  cins: Ins[],\r\n): Closure {\r\n  const captures: boolean[] = [];\r\n  const derefs: Ins[] = [];\r\n  const exclusions: string[] = cloParams;\r\n  for (let i = 0, lim = len(cins); i < lim; ++i) {\r\n    const cin = cins[i];\r\n    let capture = false;\r\n    if (cin.typ === \"clo\") {\r\n      //Inherit direct sub-closures' outer-parameter captures\r\n      captures.push(false);\r\n      const newSubDerefs: Ins[] = [];\r\n      const newSubCaptures: boolean[] = [];\r\n      for (let j = 0, d = 0; j < cin.value.length; ++j) {\r\n        const ccin = cins[i + 1 + j];\r\n        const capture = ccin.typ === \"npa\" && has(outerParams, ccin.text);\r\n        captures.push(capture);\r\n        newSubCaptures.push(!capture && cin.value.captures[j]);\r\n        if (capture) {\r\n          derefs.push(cin.value.derefs[d++]);\r\n        } else {\r\n          if (cin.value.captures[j]) {\r\n            newSubDerefs.push(cin.value.derefs[d++]);\r\n          }\r\n        }\r\n      }\r\n      cin.value.derefs = newSubDerefs;\r\n      cin.value.captures = newSubCaptures;\r\n      i += cin.value.length;\r\n      continue;\r\n    } else if (cin.typ === \"let\" || cin.typ === \"var\") {\r\n      exclusions.push(cin.value);\r\n    } else if (canCapture(exclusions, cin, i + 1 !== lim && cins[i + 1])) {\r\n      derefs.push(cin);\r\n      capture = true;\r\n    }\r\n    captures.push(capture);\r\n  }\r\n  return { name, length: len(cins), captures, derefs };\r\n}\r\n\r\n/** Create a function representing a parent closure, and its sub-closures with\r\n * all values needing captured at this point having been replaced. */\r\nexport function makeEnclosure(\r\n  { name, length, captures, derefs }: Closure,\r\n  cins: Ins[],\r\n  derefed: Val[],\r\n): Func {\r\n  if (!len(derefed)) {\r\n    return { name, ins: cins };\r\n  }\r\n  const ins: Ins[] = [];\r\n  const errCtxs = derefs.map(i => i.errCtx);\r\n  for (let i = 0; i < length; ++i) {\r\n    if (captures[i]) {\r\n      ins.push({\r\n        typ: \"val\",\r\n        value: derefed.shift()!,\r\n        errCtx: errCtxs.shift()!,\r\n      });\r\n    } else {\r\n      ins.push(cins[i]);\r\n    }\r\n  }\r\n  return { name, ins };\r\n}\r\n\r\n/** Tests whether an Instruction in a particular context can be captured.\r\n * Doesn't attempt to rewrite str Vals because they are mapped and captured\r\n * (or not) within the let/var Ctx in the machine. */\r\nfunction canCapture(exclusions: string[], ins0: Ins, ins1: false | Ins) {\r\n  const isExeVal =\r\n    ins1 && ins0.typ === \"val\" && ins0.value.t === \"str\" && ins1.typ === \"exe\";\r\n  return (\r\n    isExeVal ||\r\n    (ins0.typ === \"npa\" && !has(exclusions, ins0.text)) ||\r\n    (ins0.typ === \"ref\" && !has(exclusions, ins0.value))\r\n  );\r\n}\r\n","import { arityCheck, keyOpErr, numOpErr, typeCheck } from \"./checks\";\r\nimport { makeClosure } from \"./closure\";\r\nimport * as pf from \"./poly-fills\";\r\nconst { has, flat, push, slice, splice } = pf;\r\nconst { slen, starts, sub, substr, strIdx, subIdx } = pf;\r\nconst { isNum, len, toNum } = pf;\r\nimport { ParamsShape, Func, Funcs, Ins, ops, Val, syntaxes } from \"./types\";\r\nimport { assertUnreachable, InvokeError, ErrCtx } from \"./types\";\r\n\r\nexport type Token = {\r\n  typ: \"str\" | \"num\" | \"sym\" | \"rem\" | \"(\" | \")\";\r\n  text: string;\r\n  errCtx: ErrCtx;\r\n};\r\ntype Node = Token | Node[];\r\ntype ParserIns = Ins | { typ: \"err\"; value: string; errCtx: ErrCtx };\r\nconst nullVal: Val = { t: \"null\", v: undefined };\r\nconst falseVal = <Val>{ t: \"bool\", v: false };\r\ntype NamedNodes = {\r\n  name: string;\r\n  nodes: Node[];\r\n};\r\nconst isToken = (node: Node | undefined): node is Token =>\r\n  !!node && \"errCtx\" in node;\r\nconst symAt = (node: Node, pos = 0) => {\r\n  if (isToken(node)) {\r\n    return \"\";\r\n  }\r\n  const arg = node[pos];\r\n  return (isToken(arg) && has([\"sym\", \"str\"], arg.typ) && arg.text) || \"\";\r\n};\r\nconst token2str = ({ typ, text }: Token): string =>\r\n  typ === \"str\" ? `\"${text}\"` : text;\r\nfunction node2str(nodes: Node[]): string {\r\n  const sym0 = symAt(nodes, 0);\r\n  const isClosure = has([\"#\", \"@\"], sym0);\r\n  if (isClosure) {\r\n    nodes = slice(nodes, 1);\r\n  }\r\n  return `${isClosure ? sym0 : \"\"}(${nodes\r\n    .map(n => (isToken(n) ? token2str(n) : node2str(n)))\r\n    .join(\" \")})`;\r\n}\r\n\r\n/** Inserts pop instruction after penultimate body expression */\r\nconst poppedBody = (expressions: ParserIns[][]): ParserIns[] => {\r\n  if (len(expressions) === 1) {\r\n    return flat(expressions);\r\n  }\r\n  const lastExp = expressions[len(expressions) - 1];\r\n  const truncatedExps = slice(expressions, 0, len(expressions) - 1);\r\n  const popIns = <ParserIns>{\r\n    typ: \"pop\",\r\n    value: len(truncatedExps),\r\n    errCtx: lastExp[0].errCtx,\r\n  };\r\n  return flat([...truncatedExps, [popIns], lastExp]);\r\n};\r\n\r\nexport function tokenise(\r\n  code: string,\r\n  invokeId: string,\r\n  doTransforms = true,\r\n  emitComments = false,\r\n) {\r\n  const tokens: Token[] = [];\r\n  const isDigit = (ch: string) => sub(\"0123456789\", ch);\r\n  let [inString, line, col, inStringAt] = [false, 1, 0, [1, 0]];\r\n  let [inSymbol, inNumber, inHex] = [false, false, false];\r\n  for (let i = 0, l = slen(code); i < l; ++i) {\r\n    const c = strIdx(code, i),\r\n      nextCh = i + 1 !== l ? strIdx(code, i + 1) : \"\";\r\n    ++col;\r\n    if (c === \"\\\\\" && inString) {\r\n      tokens[len(tokens) - 1].text += doTransforms\r\n        ? { n: \"\\n\", t: \"\\t\", r: \"\\r\", '\"': '\"' }[nextCh] ||\r\n          (nextCh === \"\\\\\" ? \"\\\\\" : `\\\\${nextCh}`)\r\n        : `\\\\${nextCh}`;\r\n      ++col;\r\n      ++i;\r\n      continue;\r\n    }\r\n    const errCtx: ErrCtx = { invokeId, line, col };\r\n    if (c === '\"') {\r\n      if ((inString = !inString)) {\r\n        inStringAt = [line, col];\r\n        tokens.push({ typ: \"str\", text: \"\", errCtx });\r\n      }\r\n      inNumber = inSymbol = false;\r\n      continue;\r\n    }\r\n    const isWhite = sub(\" \\t\\n\\r,\", c);\r\n    if (!inString && isWhite) {\r\n      inSymbol = false;\r\n      inNumber &&= c === \",\";\r\n      if (c === \"\\n\") {\r\n        ++line;\r\n        col = 0;\r\n      }\r\n      continue;\r\n    }\r\n    if (!inString && c === \";\") {\r\n      const nl = subIdx(substr(code, ++i), \"\\n\");\r\n      const text = substr(code, i, nl > 0 ? nl : l - i);\r\n      i += slen(text);\r\n      ++line;\r\n      col = 0;\r\n      if (emitComments) {\r\n        tokens.push({ typ: \"rem\", text, errCtx });\r\n      }\r\n      continue;\r\n    }\r\n    const isParen = sub(\"()[]{}\", c);\r\n    //Allow one . per number, or hex, or binary, else convert into symbol\r\n    if (inNumber && !isDigit(c)) {\r\n      const hexStart = c === \"x\" && tokens[len(tokens) - 1].text === \"0\";\r\n      inHex = inHex || hexStart;\r\n      inNumber =\r\n        (c === \"b\" && tokens[len(tokens) - 1].text === \"0\") ||\r\n        (c === \".\" && !sub(tokens[len(tokens) - 1].text, \".\")) ||\r\n        (inHex && (hexStart || sub(\"ABCDEFabcdef\", c)));\r\n      if (!inNumber && !isParen && !isWhite) {\r\n        inSymbol = true;\r\n        tokens[len(tokens) - 1].typ = \"sym\";\r\n      }\r\n    }\r\n    //Stop scanning symbol if a paren\r\n    if (inSymbol && isParen) {\r\n      inSymbol = false;\r\n    }\r\n    //If we just finished concatenating a token\r\n    if (!inString && !inSymbol && !inNumber) {\r\n      if (isParen) {\r\n        const text = subIdx(\"[{(\", c) === -1 ? \")\" : \"(\";\r\n        tokens.push({ typ: text, text: doTransforms ? text : c, errCtx });\r\n        if (doTransforms && (c === \"[\" || c === \"{\")) {\r\n          tokens.push({ typ: \"sym\", text: c === \"[\" ? \"vec\" : \"dict\", errCtx });\r\n        }\r\n        continue;\r\n      }\r\n      inNumber =\r\n        isDigit(c) ||\r\n        (c === \".\" && isDigit(nextCh)) ||\r\n        (c === \"-\" && (isDigit(nextCh) || nextCh === \".\"));\r\n      inHex = inSymbol = !inNumber;\r\n      const typ: Token[\"typ\"] = inSymbol ? \"sym\" : \"num\";\r\n      tokens.push({ typ, text: \"\", errCtx });\r\n    }\r\n    tokens[len(tokens) - 1].text += c;\r\n  }\r\n  return { tokens, stringError: inString ? inStringAt : undefined };\r\n}\r\n\r\n/** Parses tokens into a tree where each node is a token or token list. */\r\nfunction treeise(tokens: Token[]): Node[] {\r\n  const nodes: Node[] = [];\r\n  const _treeise = (tokens: Token[]): Node => {\r\n    let prefix: Token | undefined;\r\n    if (tokens[0].typ === \"sym\" && sub(\"@#\", tokens[0].text)) {\r\n      prefix = tokens.shift()!;\r\n    }\r\n    const token = tokens.shift()!;\r\n    if (token.typ !== \"(\" && token.typ !== \")\") {\r\n      return token;\r\n    }\r\n    const nodes: Node[] = prefix ? [prefix] : [];\r\n    while (tokens[0].typ !== \")\") {\r\n      nodes.push(_treeise(tokens));\r\n    }\r\n    tokens.shift();\r\n    return nodes;\r\n  };\r\n  while (len(tokens)) {\r\n    nodes.push(_treeise(tokens));\r\n  }\r\n  return nodes;\r\n}\r\n\r\n/** Separates function nodes and non-function nodes,\r\n * with non-function nodes collected into (function entry ...)\r\n * if there are any.*/\r\nfunction collectFuncs(\r\n  nodes: Node[],\r\n): ({ name: string; nodes: Node[] } | { err: string; errCtx: ErrCtx })[] {\r\n  const funcs: ReturnType<typeof collectFuncs> = [];\r\n  const entries: Node[] = [];\r\n  nodes.forEach(node => {\r\n    if (!isToken(node) && isToken(node[0]) && symAt(node) === \"function\") {\r\n      const name = symAt(node, 1);\r\n      if (!name) {\r\n        funcs.push({ err: \"nameless function\", errCtx: node[0].errCtx });\r\n      } else if (len(node) < 3) {\r\n        funcs.push({ err: \"empty function body\", errCtx: node[0].errCtx });\r\n      }\r\n      funcs.push({ name, nodes: slice(node, 2) });\r\n    } else {\r\n      entries.push(node);\r\n    }\r\n  });\r\n  if (len(entries)) {\r\n    funcs.push({ name: \"entry\", nodes: entries });\r\n  }\r\n  return funcs;\r\n}\r\n\r\nconst parseNode = (node: Node, params: ParamsShape) =>\r\n  isToken(node) ? parseArg(node, params) : parseForm(node, params);\r\n\r\nfunction parseForm(\r\n  nodes: Node[],\r\n  params: ParamsShape,\r\n  doArityCheck = true,\r\n): ParserIns[] {\r\n  if (!len(nodes)) {\r\n    return [];\r\n  }\r\n  const nodeParser = (node: Node) => parseNode(node, params);\r\n  let firstNode = nodes.shift()!;\r\n  let head = nodeParser(firstNode);\r\n  const { errCtx } = head[0];\r\n  if (isToken(firstNode) && firstNode.typ === \"sym\") {\r\n    //1-off arity deficiency rewritten as closure\r\n    if (firstNode.text in ops) {\r\n      const { exactArity, minArity } = ops[firstNode.text];\r\n      const a = exactArity ?? minArity;\r\n      if (a && a !== 1 && len(nodes) + 1 === a) {\r\n        nodes.unshift(firstNode);\r\n        firstNode = { typ: \"sym\", text: \"@\", errCtx: firstNode.errCtx };\r\n      }\r\n    }\r\n    if (has([\"var\", \"let\"], firstNode.text) && len(nodes) && len(nodes) % 2) {\r\n      nodes.unshift(firstNode);\r\n      nodes.push({ typ: \"sym\", text: \"%\", errCtx: firstNode.errCtx });\r\n      firstNode = { typ: \"sym\", text: \"#\", errCtx: firstNode.errCtx };\r\n    }\r\n    const { text: op, errCtx } = firstNode;\r\n    const err = (m: string, eCtx = errCtx) => [\r\n      <ParserIns>{ typ: \"err\", value: m, errCtx: eCtx },\r\n    ];\r\n\r\n    if (has([\"if\", \"if!\", \"when\", \"unless\", \"match\"], op) && !len(nodes)) {\r\n      return err(\"provide a condition\");\r\n    } else if (has([\"if\", \"if!\"], op)) {\r\n      if (len(nodes) === 1) {\r\n        return err(\"provide at least one branch\");\r\n      } else if (len(nodes) > 3) {\r\n        return err(`provide one or two branches, not ${len(nodes)}`);\r\n      }\r\n      const parsed = nodes.map(nodeParser);\r\n      const [cond, branch1] = parsed;\r\n      let branch2 = parsed[2];\r\n      const ifN = op === \"if!\" && [\r\n        <Ins>{ typ: \"val\", value: { t: \"func\", v: \"!\" }, errCtx },\r\n        <Ins>{ typ: \"exe\", value: 1, errCtx },\r\n      ];\r\n      if (!branch2) {\r\n        branch2 = [{ typ: \"val\", value: nullVal, errCtx }];\r\n      }\r\n      return [\r\n        ...cond,\r\n        ...(ifN || []),\r\n        { typ: \"if\", value: len(branch1) + 1, errCtx },\r\n        ...branch1,\r\n        { typ: \"jmp\", value: len(branch2), errCtx },\r\n        ...branch2,\r\n      ];\r\n    } else if (op === \"when\" || op === \"unless\") {\r\n      if (len(nodes) === 1) {\r\n        return err(\"provide a body\");\r\n      }\r\n      const parsed = nodes.map(nodeParser);\r\n      const [cond, body] = [parsed[0], slice(parsed, 1)];\r\n      const bodyIns = poppedBody(body);\r\n      return [\r\n        ...cond,\r\n        ...(op === \"unless\"\r\n          ? [\r\n              <Ins>{ typ: \"val\", value: { t: \"func\", v: \"!\" } },\r\n              <Ins>{ typ: \"exe\", value: 1 },\r\n            ]\r\n          : []),\r\n        { typ: \"if\", value: len(bodyIns) + 1, errCtx },\r\n        ...bodyIns,\r\n        { typ: \"jmp\", value: 1, errCtx },\r\n        { typ: \"val\", value: nullVal, errCtx },\r\n      ];\r\n    } else if (op === \"match\") {\r\n      const parsed = nodes.map(nodeParser);\r\n      const [cond, args] = [parsed[0], slice(parsed, 1)];\r\n      const otherwise: ParserIns[] = len(args) % 2 ? args.pop()! : [];\r\n      if (!len(args)) {\r\n        return err(\"provide at least one case\");\r\n      }\r\n      const elseLen = len(otherwise);\r\n      let insCount =\r\n        args.reduce((acc, a) => acc + len(a), 0) +\r\n        (elseLen ? elseLen : 2) +\r\n        len(args);\r\n      const ins: ParserIns[] = cond;\r\n      while (len(args) > 1) {\r\n        const [a, when] = [args.shift()!, args.shift()!];\r\n        push(ins, a);\r\n        ins.push({ typ: \"mat\", value: len(when) + 1, errCtx });\r\n        push(ins, when);\r\n        insCount -= len(a) + len(when) + 2;\r\n        ins.push({ typ: \"jmp\", value: insCount, errCtx });\r\n      }\r\n      if (len(otherwise)) {\r\n        push(ins, otherwise);\r\n      } else {\r\n        ins.push({ typ: \"pop\", value: 1, errCtx });\r\n        ins.push({ typ: \"val\", value: falseVal, errCtx });\r\n      }\r\n      return ins;\r\n    } else if (op === \"catch\") {\r\n      if (len(nodes) < 2) {\r\n        return err(\"provide at least 2 arguments\");\r\n      }\r\n      const when = nodeParser(nodes.pop()!);\r\n      const body = flat(nodes.map(nodeParser));\r\n      return [...body, { typ: \"cat\", value: len(when), errCtx }, ...when];\r\n    } else if (op === \"and\" || op === \"or\" || op === \"while\") {\r\n      const args = nodes.map(nodeParser);\r\n      if (len(args) < 2) {\r\n        return err(\"provide at least 2 arguments\");\r\n      }\r\n      const ins: ParserIns[] = [];\r\n      if (op === \"while\") {\r\n        const [head, body] = [args[0], slice(args, 1)];\r\n        const flatBody = poppedBody(body);\r\n        const ifJmp = len(flatBody) + 2;\r\n        const looJmp = -(len(head) + len(flatBody) + 3);\r\n        ins.push({ typ: \"val\", value: nullVal, errCtx });\r\n        push(ins, head);\r\n        ins.push({ typ: \"if\", value: ifJmp, errCtx });\r\n        ins.push({ typ: \"pop\", value: 1, errCtx });\r\n        push(ins, flatBody);\r\n        ins.push({ typ: \"loo\", value: looJmp, errCtx });\r\n        return ins;\r\n      }\r\n      let insCount = args.reduce((acc, a) => acc + len(a), 0);\r\n      insCount += len(args); //+1 for each if/or ins\r\n      insCount += toNum(op === \"and\");\r\n      const typ = op === \"and\" ? \"if\" : \"or\";\r\n      for (let a = 0; a < len(args); ++a) {\r\n        push(ins, args[a]);\r\n        insCount -= len(args[a]);\r\n        ins.push({ typ, value: insCount, errCtx });\r\n        --insCount;\r\n      }\r\n      if (op === \"and\") {\r\n        push(ins, [\r\n          { typ: \"val\", value: <Val>{ t: \"bool\", v: true }, errCtx },\r\n          { typ: \"jmp\", value: 1, errCtx },\r\n        ]);\r\n      }\r\n      ins.push({ typ: \"val\", value: falseVal, errCtx });\r\n      return ins;\r\n    } else if (op === \"loop\") {\r\n      if (len(nodes) < 3) {\r\n        return err(\"provide at least 3 arguments\");\r\n      }\r\n      const parsed = nodes.map(nodeParser);\r\n      const symNode = nodes[1];\r\n      const body = poppedBody(slice(parsed, 2));\r\n      if (!isToken(symNode)) {\r\n        return err(\"argument 2 must be symbol\");\r\n      }\r\n      //(let sym 0 sym-limit n) ... body ... (if (< (let sym (inc sym)) sym-limit) <exit> <loo>)\r\n      const ins: ParserIns[] = [\r\n        { typ: \"val\", value: { t: \"num\", v: 0 }, errCtx },\r\n        { typ: \"let\", value: symNode.text, errCtx },\r\n        ...parsed[0],\r\n        { typ: \"let\", value: symNode.text + \"-limit\", errCtx },\r\n        { typ: \"pop\", value: 1, errCtx },\r\n        ...body,\r\n        { typ: \"ref\", value: symNode.text, errCtx },\r\n        { typ: \"val\", value: { t: \"func\", v: \"inc\" }, errCtx },\r\n        { typ: \"exe\", value: 1, errCtx },\r\n        { typ: \"let\", value: symNode.text, errCtx },\r\n        { typ: \"ref\", value: symNode.text + \"-limit\", errCtx },\r\n        { typ: \"val\", value: { t: \"func\", v: \"<\" }, errCtx },\r\n        { typ: \"exe\", value: 2, errCtx },\r\n        { typ: \"if\", value: 2, errCtx },\r\n        { typ: \"pop\", value: 1, errCtx },\r\n        { typ: \"loo\", value: -(len(body) + 10), errCtx },\r\n      ];\r\n      return ins;\r\n    } else if (op === \"var\" || op === \"let\") {\r\n      const defs = nodes.filter((n, i) => !(i % 2));\r\n      const vals = nodes.filter((n, i) => !!(i % 2));\r\n      if (!len(defs)) {\r\n        return err(\"provide at least 1 declaration name and value\");\r\n      } else if (len(defs) > len(vals)) {\r\n        return err(\"provide a value after each declaration name\");\r\n      }\r\n      const ins: ParserIns[] = [];\r\n      const symErrMsg = `${op} name must be a new symbol or destructuring`;\r\n      for (let d = 0, lim = len(defs); d < lim; ++d) {\r\n        push(ins, nodeParser(vals[d]));\r\n        const def = defs[d];\r\n        if (isToken(def)) {\r\n          const defIns = parseNode(defs[d], params);\r\n          if (len(defIns) > 1 || defIns[0].typ !== \"ref\") {\r\n            return err(symErrMsg, defIns[0].errCtx);\r\n          }\r\n          ins.push({ typ: op, value: defIns[0].value, errCtx });\r\n        } else {\r\n          const { shape, errors } = parseParams([def], true);\r\n          if (len(errors)) {\r\n            return errors;\r\n          }\r\n          if (!len(shape)) {\r\n            return err(symErrMsg);\r\n          }\r\n          const typ = op === \"var\" ? \"dva\" : \"dle\";\r\n          ins.push({ typ, value: shape, errCtx });\r\n        }\r\n      }\r\n      return ins;\r\n    } else if (op === \"var!\" || op === \"let!\") {\r\n      //Rewrite e.g. (var! a + 1) -> (var a (+ a 1))\r\n      if (len(nodes) < 2) {\r\n        return err(\"provide 1 declaration name and 1 function\");\r\n      }\r\n      const parsed = nodes.map(nodeParser);\r\n      const [def, func, args] = [parsed[0][0], parsed[1], slice(parsed, 2)];\r\n      if (def.typ !== \"ref\") {\r\n        return err(\"declaration name must be symbol\", def.errCtx);\r\n      }\r\n      const ins: Ins[] = [{ typ: \"ref\", value: def.value, errCtx }];\r\n      push(ins, [...flat(args), ...func]);\r\n      ins.push({ typ: \"exe\", value: len(args) + 1, errCtx });\r\n      const typ = op === \"var!\" ? \"var\" : \"let\";\r\n      ins.push({ typ, value: def.value, errCtx });\r\n      return ins;\r\n    } else if (op === \"#\" || op === \"@\" || op === \"fn\") {\r\n      const pins: ParserIns[] = [];\r\n      const name = node2str([firstNode, ...nodes]);\r\n      const cloParams: string[] = [];\r\n      const outerParams = slice(params).map(p => p.name);\r\n      let monoFnBody = false;\r\n      if (op === \"fn\") {\r\n        const parsedParams = parseParams(nodes, false);\r\n        push(\r\n          cloParams,\r\n          parsedParams.shape.map(p => p.name),\r\n        );\r\n        push(params, parsedParams.shape);\r\n        push(pins, parsedParams.errors);\r\n        if (!len(nodes)) {\r\n          return err(\"provide a body\");\r\n        }\r\n        monoFnBody = len(nodes) === 1;\r\n        nodes.unshift({ typ: \"sym\", text: \"do\", errCtx });\r\n      }\r\n      //Rewrite partial closure to #(... [body] args)\r\n      if (op === \"@\") {\r\n        const firstSym = symAt(nodes, 0);\r\n        if (has(syntaxes, firstSym)) {\r\n          const { errCtx } = nodes[0] as Token;\r\n          return err(\r\n            `\"${firstSym}\" syntax unavailable in partial closure`,\r\n            errCtx,\r\n          );\r\n        }\r\n        nodes = [\r\n          { typ: \"sym\", text: \"...\", errCtx },\r\n          ...nodes,\r\n          { typ: \"sym\", text: \"args\", errCtx },\r\n        ];\r\n      }\r\n      push(pins, parseForm(nodes, params, op !== \"@\"));\r\n      const cins = <Ins[]>pins.filter(i => i.typ !== \"err\");\r\n      const errors = pins.filter(i => i.typ === \"err\");\r\n      if (len(errors)) {\r\n        return errors;\r\n      }\r\n      //Remove do exe when fn body is only one expression\r\n      if (monoFnBody) {\r\n        cins.pop();\r\n        cins.pop();\r\n      }\r\n      const value = makeClosure(name, outerParams, cloParams, cins);\r\n      return [{ typ: \"clo\", value, errCtx }, ...cins];\r\n    } else if (op === \"->\") {\r\n      const newNodes = nodes.reduce((acc, node) => [node, acc]) as Node[];\r\n      const parsed = parseForm(newNodes, params);\r\n      return parsed;\r\n    }\r\n\r\n    //Operation arity check, optionally disabled for partial closures\r\n    if (ops[op] && doArityCheck) {\r\n      const errors = arityCheck(op, len(nodes), errCtx);\r\n      const err = (value: string, eCtx = errCtx) => [\r\n        <ParserIns>{ typ: \"err\", value, errCtx: eCtx },\r\n      ];\r\n      push(head, errors?.map(e => err(e.m)[0]) ?? []);\r\n      if (!errors) {\r\n        //Upgrade some math and logic functions to their faster counterparts\r\n        if (len(nodes) === 2 && ops[`fast${op}`]) {\r\n          head = nodeParser({ typ: \"sym\", text: `fast${op}`, errCtx });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const args = nodes.map(nodeParser);\r\n  const ins: ParserIns[] = flat(args);\r\n  if (symAt([firstNode]) === \"return\") {\r\n    return [...ins, { typ: \"ret\", value: !!len(args), errCtx }];\r\n  } else if (len(head) === 1 && head[0].typ === \"ref\") {\r\n    //Transform potential external function into string\r\n    const { value: v, errCtx } = head[0];\r\n    head[0] = { typ: \"val\", value: { t: \"str\", v }, errCtx };\r\n  }\r\n  push(ins, head);\r\n  const typ = len(head) > 1 || has([\"npa\", \"upa\"], head[0].typ) ? \"exa\" : \"exe\";\r\n  return [...ins, { typ, value: len(args), errCtx }];\r\n}\r\n\r\nfunction parseArg(node: Node, params: ParamsShape): ParserIns[] {\r\n  if (isToken(node)) {\r\n    const { errCtx } = node;\r\n    if (node.typ === \"str\") {\r\n      return [{ typ: \"val\", value: { t: \"str\", v: node.text }, errCtx }];\r\n    } else if (node.typ === \"num\") {\r\n      return [{ typ: \"val\", value: { t: \"num\", v: toNum(node.text) }, errCtx }];\r\n    } else if (node.typ === \"sym\") {\r\n      const { text } = node;\r\n      const paramNames = params.map(({ name }) => name);\r\n      if (text === \"true\" || text === \"false\") {\r\n        return [\r\n          { typ: \"val\", value: <Val>{ t: \"bool\", v: text === \"true\" }, errCtx },\r\n        ];\r\n      } else if (text === \"null\") {\r\n        return [{ typ: \"val\", value: nullVal, errCtx }];\r\n      } else if (text === \"_\") {\r\n        return [{ typ: \"val\", value: { t: \"wild\", v: undefined }, errCtx }];\r\n      } else if (starts(text, \":\")) {\r\n        return [{ typ: \"val\", value: <Val>{ t: \"key\", v: text }, errCtx }];\r\n      } else if (\r\n        text === \"%\" ||\r\n        (starts(text, \"%\") && isNum(substr(text, 1)))\r\n      ) {\r\n        const value = text === \"%\" ? 0 : toNum(substr(text, 1));\r\n        if (value < 0) {\r\n          return [{ typ: \"val\", value: nullVal, errCtx }];\r\n        }\r\n        return [{ typ: \"upa\", value, text, errCtx }];\r\n      } else if (has(paramNames, text)) {\r\n        const param = params.find(({ name }) => name === text)!;\r\n        if (len(param.position) === 1) {\r\n          return [{ typ: \"npa\", value: param.position[0], text, errCtx }];\r\n        }\r\n        return [{ typ: \"dpa\", value: param.position, errCtx }];\r\n      } else if (text === \"args\") {\r\n        return [{ typ: \"upa\", value: -1, text: \"args\", errCtx }];\r\n      } else if (text === \"PI\" || text === \"E\") {\r\n        const v = text === \"PI\" ? 3.141592653589793 : 2.718281828459045;\r\n        return [{ typ: \"val\", value: { t: \"num\", v }, errCtx }];\r\n      } else if (ops[text]) {\r\n        return [{ typ: \"val\", value: <Val>{ t: \"func\", v: text }, errCtx }];\r\n      }\r\n      return [{ typ: \"ref\", value: text, errCtx }];\r\n    }\r\n    return [];\r\n  } else if (!len(node)) {\r\n    return [];\r\n  }\r\n  return parseForm(node, params);\r\n}\r\n\r\n/** Consumes some tokens and returns ParamsShape.\r\n * Example inputs:\r\n * \"(fn \"   a [b [c]] d [d c b a]\r\n * \"(var \" [a] [1 2] b [1 2]\r\n * \"(function \" [x] (print x) x\r\n * \"(function \" x [x]\r\n * \"(fn \"\r\n * \"(function \"\r\n * */\r\nfunction parseParams(\r\n  nodes: Node[],\r\n  consumeLast: boolean,\r\n  position: number[] = [],\r\n): { shape: ParamsShape; errors: ParserIns[] } {\r\n  const shape: ParamsShape = [],\r\n    errs: ParserIns[] = [];\r\n  let n = 0;\r\n  while (\r\n    len(nodes) > (consumeLast ? 0 : 1) &&\r\n    (isToken(nodes[0]) || symAt(nodes[0]) === \"vec\")\r\n  ) {\r\n    const param = nodes.shift()!;\r\n    if (!isToken(param)) {\r\n      param.shift();\r\n      const parsed = parseParams(param, true, [...position, n]);\r\n      push(shape, parsed.shape);\r\n      push(errs, parsed.errors);\r\n    } else {\r\n      const { typ, errCtx } = param;\r\n      if (typ === \"sym\") {\r\n        shape.push({ name: param.text, position: [...position, n] });\r\n      } else {\r\n        errs.push({ typ: \"err\", value: \"provide parameter name\", errCtx });\r\n      }\r\n    }\r\n    ++n;\r\n  }\r\n  return { shape, errors: errs };\r\n}\r\n\r\nfunction compileFunc({ name, nodes }: NamedNodes): Func | InvokeError {\r\n  const { shape: params, errors } = parseParams(nodes, false);\r\n  const ins = [...errors, ...flat(nodes.map(node => parseArg(node, params)))];\r\n  for (let i = 0, lim = len(ins); i < lim; i++) {\r\n    const { typ, value, errCtx } = ins[i];\r\n    if (typ === \"err\") {\r\n      return <InvokeError>{ e: \"Parse\", m: value, errCtx };\r\n    }\r\n  }\r\n  return { name, ins: <Ins[]>ins };\r\n}\r\n\r\nfunction findParenImbalance(\r\n  tokens: Token[],\r\n  numL: number,\r\n  numR: number,\r\n): [number, number] {\r\n  //Scan for first instance of untimely closed\r\n  //  or last instance of unclosed open\r\n  const untimely = numR >= numL;\r\n  const [l, r] = [untimely ? \"(\" : \")\", untimely ? \")\" : \"(\"];\r\n  const direction = untimely ? 1 : -1;\r\n  for (\r\n    let lim = len(tokens), t = untimely ? 0 : lim - 1, depth = 0;\r\n    untimely ? t < lim : t >= 0;\r\n    t += direction\r\n  ) {\r\n    const {\r\n      typ,\r\n      errCtx: { line, col },\r\n    } = tokens[t];\r\n    depth += toNum(typ === l) - toNum(typ === r);\r\n    if (depth < 0) {\r\n      return [line, col];\r\n    }\r\n  }\r\n  return [0, 0];\r\n}\r\n\r\nfunction tokenErrorDetect(stringError: number[] | undefined, tokens: Token[]) {\r\n  const invokeId = len(tokens) ? tokens[0].errCtx.invokeId : \"\";\r\n  const errors: InvokeError[] = [];\r\n  const err = (m: string, errCtx: ErrCtx) =>\r\n    errors.push({ e: \"Parse\", m, errCtx });\r\n\r\n  //Check for double-quote imbalance\r\n  if (stringError) {\r\n    const [line, col] = stringError;\r\n    err(\"unmatched double quotation marks\", { invokeId, line, col });\r\n    return errors;\r\n  }\r\n\r\n  //Check for paren imbalance\r\n  const countTyp = (t: Token[\"typ\"]) =>\r\n    len(tokens.filter(({ typ }) => typ === t));\r\n  const [numL, numR] = [countTyp(\"(\"), countTyp(\")\")];\r\n  {\r\n    const [line, col] = findParenImbalance(tokens, numL, numR);\r\n    if (line + col) {\r\n      err(\"unmatched parenthesis\", { invokeId: invokeId, line, col });\r\n    }\r\n  }\r\n\r\n  //Check for any empty expressions\r\n  let emptyHead: Token | undefined;\r\n  for (let t = 0, lastWasL = false; t < len(tokens); ++t) {\r\n    const token = tokens[t];\r\n    //To catch (#) and (@)\r\n    if (token.typ === \"sym\" && token.text === \"#\" || token.text === \"@\") {\r\n      continue;\r\n    }\r\n    if (lastWasL && token.typ === \")\") {\r\n      emptyHead = token;\r\n      break;\r\n    }\r\n    lastWasL = token.typ === \"(\";\r\n  }\r\n  if (emptyHead) {\r\n    err(\"empty expression forbidden\", emptyHead.errCtx);\r\n  }\r\n\r\n  return errors;\r\n}\r\n\r\n//TODO: investigate Node implementation replacement\r\nfunction insErrorDetect(fins: Ins[]): InvokeError[] | undefined {\r\n  type TypeInfo = {\r\n    types?: Val[\"t\"][];\r\n    val?: Val;\r\n  };\r\n  const stack: TypeInfo[] = [];\r\n  for (let i = 0, lim = len(fins); i < lim; ++i) {\r\n    const ins = fins[i];\r\n    switch (ins.typ) {\r\n      case \"val\":\r\n        stack.push({ types: [ins.value.t], val: ins.value });\r\n        break;\r\n      case \"exa\":\r\n      case \"exe\": {\r\n        const head = stack.pop()!;\r\n        const args = splice(stack, len(stack) - ins.value, ins.value);\r\n        const badMatch = (okTypes: Val[\"t\"][]) =>\r\n          args.findIndex(\r\n            ({ types }) => types && !okTypes.find(t => has(types, t)),\r\n          );\r\n        const headIs = (t: Val[\"t\"]) =>\r\n          head.val\r\n            ? head.val.t === t\r\n            : head.types && len(head.types) === 1 && head.types[0] === t;\r\n        if (head.val && head.val.t === \"func\") {\r\n          if (head.val.v === \"recur\") {\r\n            splice(stack, len(stack) - ins.value, ins.value);\r\n            break;\r\n          }\r\n          const errors = typeCheck(\r\n            head.val.v,\r\n            args.map(a => a.types ?? []),\r\n            ins.errCtx,\r\n            true,\r\n          );\r\n          if (errors) {\r\n            return errors;\r\n          }\r\n          const { returns, numeric: onlyNum } = ops[head.val.v];\r\n          stack.push(\r\n            onlyNum && onlyNum !== \"in only\"\r\n              ? { types: [\"num\"] }\r\n              : { types: returns },\r\n          );\r\n        } else if (headIs(\"num\")) {\r\n          const badArg = badMatch([\"str\", \"dict\", \"vec\"]);\r\n          if (badArg !== -1) {\r\n            return numOpErr(ins.errCtx, args[badArg].types!);\r\n          }\r\n          stack.push({});\r\n        } else if (headIs(\"key\")) {\r\n          const badArg = badMatch([\"dict\", \"vec\"]);\r\n          if (badArg !== -1) {\r\n            return keyOpErr(ins.errCtx, args[badArg].types!);\r\n          }\r\n          stack.push({});\r\n        } else if (headIs(\"str\") || headIs(\"bool\")) {\r\n          stack.push({});\r\n        } else if (!head.types && !head.val) {\r\n          stack.push({});\r\n        }\r\n        break;\r\n      }\r\n      case \"or\":\r\n        stack.pop();\r\n        stack.push({});\r\n        i += ins.value;\r\n        break;\r\n      case \"cat\":\r\n      case \"var\":\r\n      case \"let\":\r\n      case \"dva\":\r\n      case \"dle\":\r\n      case \"loo\":\r\n      case \"jmp\":\r\n        break;\r\n      case \"clo\": {\r\n        const errors = insErrorDetect(slice(fins, i + 1, i + ins.value.length));\r\n        if (errors) {\r\n          return errors;\r\n        }\r\n        stack.push({});\r\n      }\r\n      case \"ref\":\r\n      case \"npa\":\r\n      case \"upa\":\r\n      case \"dpa\":\r\n        stack.push({});\r\n        break;\r\n      case \"if\": {\r\n        stack.pop();\r\n        stack.push({});\r\n        const ifIns = slice(fins, i + 1, ins.value + 1);\r\n        const errors = insErrorDetect(ifIns);\r\n        if (errors) {\r\n          return errors;\r\n        }\r\n        i += ins.value - 1;\r\n        break;\r\n      }\r\n      case \"mat\": {\r\n        stack.pop(); //first match\r\n        stack.pop(); //cond\r\n        i += ins.value;\r\n        i += fins[i].value as number; //The first jmp\r\n        stack.push({});\r\n        break;\r\n      }\r\n      case \"pop\":\r\n        splice(stack, len(stack) - ins.value, ins.value);\r\n        break;\r\n      case \"ret\":\r\n        if (ins.value) {\r\n          stack.pop();\r\n        }\r\n        break;\r\n      default:\r\n        assertUnreachable(ins);\r\n    }\r\n  }\r\n}\r\n\r\nexport function parse(\r\n  code: string,\r\n  invokeId: string,\r\n): { funcs: Funcs; errors: InvokeError[] } {\r\n  const { tokens, stringError } = tokenise(code, invokeId);\r\n  const tokenErrors = tokenErrorDetect(stringError, tokens);\r\n  if (len(tokenErrors)) {\r\n    return { errors: tokenErrors, funcs: {} };\r\n  }\r\n  const okFuncs: Func[] = [],\r\n    errors: InvokeError[] = [];\r\n  const tree = treeise(slice(tokens));\r\n  const collected = collectFuncs(tree);\r\n  const namedNodes: NamedNodes[] = [];\r\n  collected.forEach(nodeOrErr => {\r\n    if (\"err\" in nodeOrErr) {\r\n      errors.push({ e: \"Parse\", m: nodeOrErr.err, errCtx: nodeOrErr.errCtx });\r\n    } else {\r\n      namedNodes.push({ name: nodeOrErr.name, nodes: nodeOrErr.nodes });\r\n    }\r\n  });\r\n  namedNodes.map(compileFunc).forEach(fae => {\r\n    if (\"e\" in fae) {\r\n      errors.push(fae);\r\n    } else {\r\n      okFuncs.push(fae);\r\n    }\r\n  });\r\n  push(errors, flat(okFuncs.map(f => insErrorDetect(f.ins) ?? [])));\r\n  const funcs: Funcs = {};\r\n  okFuncs.forEach(func => (funcs[func.name ?? \"\"] = func));\r\n  return { errors, funcs };\r\n}\r\n","import { concat, round, getTimeMs, len, padEnd, trim } from \"./poly-fills\";\r\nimport { Ctx, Env, Val, ValOrErr, InvokeResult } from \"./types\";\r\n\r\ntype State = { dict: Map<string, Val>; output: string };\r\n\r\nfunction get(state: State, key: string): ValOrErr {\r\n  if (!state.dict.has(key)) {\r\n    return { kind: \"err\", err: `\"${key}\" not found.` };\r\n  }\r\n  return { kind: \"val\", value: state.dict.get(key)! };\r\n}\r\n\r\nfunction set(state: State, key: string, val: Val): string | undefined {\r\n  state.dict.set(key, val);\r\n  return undefined;\r\n}\r\n\r\nfunction exe(state: State, name: string, args: Val[]): ValOrErr {\r\n  const nullVal: Val = { t: \"null\", v: undefined };\r\n  switch (name) {\r\n    case \"test.function\":\r\n      state.output += args[0].v + \"\\n\";\r\n      break;\r\n    default:\r\n      return { kind: \"err\", err: `operation \"${name}\" does not exist` };\r\n  }\r\n  return { kind: \"val\", value: nullVal };\r\n}\r\n\r\nconst tests: {\r\n  name: string;\r\n  code: string;\r\n  err?: string[];\r\n  out?: string;\r\n}[] = [\r\n  //Basic snippets\r\n  { name: \"Hello, world!\", code: `\"Hello, world!\"`, out: `Hello, world!` },\r\n  {\r\n    name: \"Say Hello, world!\",\r\n    code: `;This is a test comment\r\n           (print \"Hello, world!\")`,\r\n    out: `Hello, world!\\nnull`,\r\n  },\r\n  { name: \"1 + 1 = 2\", code: `(+ 1 1)`, out: `2` },\r\n  { name: \"Negate 1 = -1\", code: `(neg 1)`, out: `-1` },\r\n  { name: \"(1+1)+1+(1+1) = 5\", code: `(+ (+ 1 1) 1 (+ 1 1))`, out: `5` },\r\n  { name: \"Conditional head\", code: `((if true + -) 12 9 1)`, out: `22` },\r\n  {\r\n    name: \"when and unless\",\r\n    code: `[(when 123 (print \"hi\") 234) (unless true (print \"bye\"))]`,\r\n    out: `hi\\n[234 null]`,\r\n  },\r\n  {\r\n    name: \"match and wildcard\",\r\n    code: `(match [1 2]\r\n             [0 0] (print \"hello\")\r\n             [0 2] (print \"bye\")\r\n             [1 _] \"hey\")`,\r\n    out: `hey`,\r\n  },\r\n  { name: \"Cond number head\", code: `((if false 1 2) [:a :b :c])`, out: `:c` },\r\n  {\r\n    name: \"and & short-circuit\",\r\n    code: `[(and true (if true null 1) (print \"hi\")) (and 1 2 3)]`,\r\n    out: `[false true]`,\r\n  },\r\n  {\r\n    name: \"or & short-circuit\",\r\n    code: `[(or true (print \"hi\") 1) (or false (print-str \"-> \") 1)]`,\r\n    out: `-> [true 1]`,\r\n  },\r\n  { name: \"String retrieve\", code: `(2 \"Hello\")`, out: `l` },\r\n  { name: \"Vector retrieve\", code: `(2 [:a :b :c :d])`, out: `:c` },\r\n  {\r\n    name: \"Key as operation\",\r\n    code: `[(:age {:name \"Patrick\" :age 24}) (:abc [:a :abc :c])]`,\r\n    out: `[24 :abc]`,\r\n  },\r\n  {\r\n    name: \"Dictionary as op 1\",\r\n    code: `({\"name\" \"Patrick\" \"age\" 24} \"age\")`,\r\n    out: `24`,\r\n  },\r\n  {\r\n    name: \"Dictionary as op 2\",\r\n    code: `({\"name\" \"Patrick\"} \"age\" 24)`,\r\n    out: `{\"name\" \"Patrick\", \"age\" 24}`,\r\n  },\r\n  {\r\n    name: \"Equalities\",\r\n    code: `[(= 1 2 1)\r\n            (!= 1 2 1)\r\n            (= \"Hello\" \"hello\")\r\n            (!= \"world\" \"world\")\r\n            (= [0 [1]] [0 [1]])]`,\r\n    out: `[false true false false true]`,\r\n  },\r\n  { name: \"Define and retrieve\", code: `(var a 1) a`, out: `1` },\r\n  { name: \"Define and add\", code: `(var a 1) (inc a)`, out: `2` },\r\n  { name: \"Define op and call\", code: `(var f +) (f 2 2)`, out: `4` },\r\n  { name: \"Define vec and call\", code: `(var f [1]) (f 1)`, out: `1` },\r\n  {\r\n    name: \"Define num and call\",\r\n    code: `(var f 1) (f [:a :b :c])`,\r\n    out: `:b`,\r\n  },\r\n  { name: \"Apply op to var\", code: `(var a 10) (var! a + 10)`, out: `20` },\r\n  {\r\n    name: \"Apply op to let\",\r\n    code: `(let a 10) (let! a (if true + -) (+ 2 3) 5)`,\r\n    out: `20`,\r\n  },\r\n  { name: \"Print simple vector\", code: `[1 2 3]`, out: `[1 2 3]` },\r\n  { name: \"Boolean select\", code: `[(true 1 2) (false 1)]`, out: `[1 null]` },\r\n  {\r\n    name: \"Sum vector of numbers\",\r\n    code: `[(reduce + [1 2 3]) (reduce + 3 [1 2 3])]`,\r\n    out: `[6 9]`,\r\n  },\r\n  {\r\n    name: \"Sum vectors of numbers\",\r\n    code: `(map + [1 2 3] [1 2 3 4])`,\r\n    out: `[2 4 6]`,\r\n  },\r\n  {\r\n    name: \"For XY list\",\r\n    code: `(for vec [0 1] [0 1])`,\r\n    out: `[[0 0] [1 0] [0 1] [1 1]]`,\r\n  },\r\n  {\r\n    name: \"Filter by integer\",\r\n    code: `(filter 2 [[1] [:a :b :c] \"hello\" \"hi\"])`,\r\n    out: `[[:a :b :c] \"hello\"]`,\r\n  },\r\n  {\r\n    name: \"Comments, short decimal\",\r\n    code: `;((print \"Hello\")\r\n           .456`,\r\n    out: `0.456`,\r\n  },\r\n  {\r\n    name: \"Dictionary into vector\",\r\n    code: `(into [1 2] {3 4 5 6})`,\r\n    out: `[1 2 [3 4] [5 6]]`,\r\n  },\r\n  {\r\n    name: \"Vector into dictionary\",\r\n    code: `(into {[0] 1 [2] 3} [[0] 2])`,\r\n    out: `{[0] 2, [2] 3}`,\r\n  },\r\n  {\r\n    name: \"While loop\",\r\n    code: `(var n 5)\r\n           (while (< 0 n)\r\n             (print-str n)\r\n             (var n (dec n)))`,\r\n    out: `543210`,\r\n  },\r\n  {\r\n    name: \"Loop\",\r\n    code: `(loop 3 i (print-str i))`,\r\n    out: `012null`,\r\n  },\r\n  {\r\n    name: \"Catch error\",\r\n    code: `(catch\r\n             (:e (catch (let a :a) (+ 1 a) (0 errors)))\r\n             (print \"hi\"))`,\r\n    out: `Type`,\r\n  },\r\n  //Basic functions and closures\r\n  { name: \"Define with no call\", code: `(function func (print \"Nothing.\"))` },\r\n  {\r\n    name: \"Call greet func\",\r\n    code: `(function greeting (print \"Hello!\")) (greeting)`,\r\n    out: `Hello!\\nnull`,\r\n  },\r\n  {\r\n    name: \"Call const value func\",\r\n    code: `(function const 123) (const)`,\r\n    out: `123`,\r\n  },\r\n  {\r\n    name: \"Call identity funcs\",\r\n    code: `(function id1 %)\r\n           (function id2 x x)\r\n           [(id1 123) (id2 456)]`,\r\n    out: `[123 456]`,\r\n  },\r\n  {\r\n    name: \"Call greet with name\",\r\n    code: `(function greeting name (print \"Hello, \" name \"!\"))\r\n           (greeting \"Patrick\")`,\r\n    out: `Hello, Patrick!\\nnull`,\r\n  },\r\n  {\r\n    name: \"Call with too few args\",\r\n    code: `(function func a b c [a b c]) (func 1 2)`,\r\n    out: `[1 2 null]`,\r\n  },\r\n  {\r\n    name: \"Define func and call\",\r\n    code: `(function func a b (+ a b)) (var f func) (f 2 2)`,\r\n    out: `4`,\r\n  },\r\n  {\r\n    name: \"Anonymous parameters\",\r\n    code: `(function avg<n? (< (/ (.. + %) (len %)) %1))\r\n           (avg<n? [0 10 20 30 40] 5)`,\r\n    out: `false`,\r\n  },\r\n  {\r\n    name: \"Call parameter\",\r\n    code: `(function f x (x \"hello\")) (f print)`,\r\n    out: `hello\\nnull`,\r\n  },\r\n  { name: \"Let and retrieve\", code: `(function f (let a 1) a) (f)`, out: `1` },\r\n  {\r\n    name: \"Let num op and call\",\r\n    code: `(function f (let n 0) (n [1])) (f)`,\r\n    out: `1`,\r\n  },\r\n  {\r\n    name: \"Explicit return\",\r\n    code: `(function f (return 123) (print 456)) (f)`,\r\n    out: `123`,\r\n  },\r\n  {\r\n    name: \"Closure 1\",\r\n    code: `(let x 10)\r\n           (let closure #(+ x x))\r\n           (let x 11)\r\n           (closure)`,\r\n    out: `20`,\r\n  },\r\n  {\r\n    name: \"Closure 2\",\r\n    code: `(filter #(or (.. = args) (even? %)) (range 10) 5)`,\r\n    out: `[0 2 4 5 6 8]`,\r\n  },\r\n  {\r\n    name: \"Closure 3\",\r\n    code: `(function f #(+ x x))\r\n           (var x 10) (let c20 (f))\r\n           (var x 20) (let c40 (f))\r\n           [(c20) (c40)]`,\r\n    out: `[20 40]`,\r\n  },\r\n  {\r\n    name: \"Closure with ext func\",\r\n    code: `(#(test.function %) 1)`,\r\n    out: `1\\nnull`,\r\n  },\r\n  {\r\n    name: \"Func returns closure\",\r\n    code: `(function f x #(x 2 2))\r\n           (let closure (f +))\r\n           (closure)`,\r\n    out: `4`,\r\n  },\r\n  {\r\n    name: \"Dictionary closure\",\r\n    code: `(function f x #{x 2})\r\n           (let closure (f :a))\r\n           (closure)`,\r\n    out: `{:a 2}`,\r\n  },\r\n  {\r\n    name: \"Vector closure\",\r\n    code: `(function f x #[1 x %])\r\n           (let closure (f 2))\r\n           (closure 3)`,\r\n    out: `[1 2 3]`,\r\n  },\r\n  {\r\n    name: \"Closure as head\",\r\n    code: `(#[% %1 %2] 1 2 3)`,\r\n    out: `[1 2 3]`,\r\n  },\r\n  {\r\n    name: \"Partial closure 1\",\r\n    code: `(@[] 1 2 3)`,\r\n    out: `[1 2 3]`,\r\n  },\r\n  {\r\n    name: \"Partial closure 2\",\r\n    code: `(@((do +) 2) 2)`,\r\n    out: `4`,\r\n  },\r\n  {\r\n    name: \"Parameterised closure 1\",\r\n    code: `((fn a b (+ a b)) 2 2)`,\r\n    out: `4`,\r\n  },\r\n  {\r\n    name: \"Parameterised closure 2\",\r\n    code: `((fn a b (print-str a b) (+ a b)) 2 2)`,\r\n    out: `224`,\r\n  },\r\n  {\r\n    name: \"Parameterised closure 3\",\r\n    code: `(reduce\r\n             (fn primes num\r\n               (if (find zero? (map (rem num) primes))\r\n                 primes\r\n                 (append num primes)))\r\n             [2]\r\n             (range 3 10))`,\r\n    out: `[2 3 5 7]`,\r\n  },\r\n  {\r\n    name: \"Closure with inter-lets\",\r\n    code: `(let a + c 5 d 10)\r\n           (let closure (fn b (let d 1) (a b c d)))\r\n           (let a - c 4 d 11)\r\n           (closure 1)`,\r\n    out: `7`,\r\n  },\r\n  {\r\n    name: \"Closure with inner-let\",\r\n    code: `(((fn x (let y 1) #[x y]) 2))`,\r\n    out: `[2 1]`,\r\n  },\r\n  {\r\n    name: \"Closure with captured f\",\r\n    code: `[((fn x (@(val x))) 0) (var f val) ((fn y (@(f y))) 0)]`,\r\n    out: `[0 val 0]`,\r\n  },\r\n  {\r\n    name: \"Closure w/ inter-params\",\r\n    code: `(function f x (fn y (fn z [x y z]))) (((f :a) :b) :c)`,\r\n    out: `[:a :b :c]`,\r\n  },\r\n  {\r\n    name: \"Destructure var\",\r\n    code: `(var [x [y]] [1 [2]]) [y x]`,\r\n    out: `[2 1]`,\r\n  },\r\n  {\r\n    name: \"Destructure string\",\r\n    code: `(let [a b c] \"hello\") [a b c]`,\r\n    out: `[\"h\" \"e\" \"l\"]`,\r\n  },\r\n  {\r\n    name: \"Destructure function\",\r\n    code: `(function f a [[b c] d] e [e d c b a]) (f 0 [[1 2] 3] 4)`,\r\n    out: `[4 3 2 1 0]`,\r\n  },\r\n  {\r\n    name: \"Destructuring closure\",\r\n    code: `(let f (fn a [b [c]] d [d c b a])) (f 0 [1 [2]] 3)`,\r\n    out: `[3 2 1 0]`,\r\n  },\r\n  {\r\n    name: \"Destructuring fn decoy\",\r\n    code: `(let f (fn a [a [a]])) (f 0)`,\r\n    out: `[0 [0]]`,\r\n  },\r\n  { name: \"Implicit currying\", code: \"(-> 1 inc (+ 10))\", out: `12` },\r\n  //Runtime errors\r\n  {\r\n    name: \"String instead of number\",\r\n    code: `(function sum (.. + args))\r\n           (print (sum 2 2))\r\n           (sum 2 \"hi\")`,\r\n    out: `4`,\r\n    err: [\"Type\"],\r\n  },\r\n  { name: \"Reference non-existing\", code: `x`, err: [\"Reference\"] },\r\n  {\r\n    name: \"Expired let retrieve\",\r\n    code: `(function f (let a 1) a) (f) a`,\r\n    err: [\"Reference\"],\r\n  },\r\n  { name: \"Call non-existing\", code: `(x)`, err: [\"External\"] },\r\n  { name: \"Call budget\", code: `(function f (f)) (f)`, err: [\"Budget\"] },\r\n  {\r\n    name: \"Loop budget\",\r\n    code: `(var n 10000)\r\n           (while (< 0 n)\r\n             (var n (dec n)))`,\r\n    err: [\"Budget\"],\r\n  },\r\n  { name: \"Range budget\", code: `(range 10000)`, err: [\"Budget\"] },\r\n  {\r\n    name: \"Head exe arity check\",\r\n    code: `(((fn +)) 1)`,\r\n    err: [\"Arity\"],\r\n  },\r\n  //Complex functions\r\n  {\r\n    name: \"Fibonacci 13\",\r\n    code: `(function fib n\r\n             (if (< n 2) n\r\n               (+ (fib (dec n))\r\n                  (fib (- n 2)))))\r\n           (fib 13)`,\r\n    out: `233`,\r\n  },\r\n  {\r\n    name: \"dedupe (recur)\",\r\n    code: `(function dedupe list -out\r\n             (let out (or -out []))\r\n             (let next (if (out (0 list)) [] [(0 list)]))\r\n             (if (empty? list) out\r\n                 (recur (sect list) (into out next))))\r\n           (dedupe [1 1 2 3 3 3])`,\r\n    out: `[1 2 3]`,\r\n  },\r\n  {\r\n    name: \"frequencies\",\r\n    code: `(function frequencies list\r\n             (reduce #(% %1 (inc (or (% %1) 0))) {} list))\r\n           (frequencies \"12121212\")`,\r\n    out: `{\"1\" 4, \"2\" 4}`,\r\n  },\r\n  //Test environment functions\r\n  {\r\n    name: \"set get\",\r\n    code: `[($globals.time_offset 5.5) $globals.time_offset]`,\r\n    out: `[5.5 5.5]`,\r\n  },\r\n  { name: \"exe\", code: `(test.function 123)`, out: `123\\nnull` },\r\n  //Syntax errors\r\n  { name: \"Empty parens\", code: `()`, err: [\"Parse\"] },\r\n  { name: \"Imbalanced parens 1\", code: `(print (\"hello!\")`, err: [\"Parse\"] },\r\n  { name: \"Imbalanced parens 2\", code: `print \"hello!\")`, err: [\"Parse\"] },\r\n  {\r\n    name: \"Imbalanced quotes\",\r\n    code: `(print \"Hello)`,\r\n    err: [\"Parse\"],\r\n  },\r\n  { name: \"Function as op\", code: `(function)`, err: [\"Parse\"] },\r\n  { name: \"Function without name\", code: `(function (+))`, err: [\"Parse\"] },\r\n  { name: \"Function without body\", code: `(function func)`, err: [\"Parse\"] },\r\n  { name: \"Variable not symbol\", code: `(var 1 2)`, err: [\"Parse\"] },\r\n  //Parser type and arity errors\r\n  { name: \"Parser type error 1\", code: `(function f (+ 1 :a))`, err: [\"Type\"] },\r\n  {\r\n    name: \"Parser type error 2\",\r\n    code: `(function f (+ 1 (into {} {})))`,\r\n    err: [\"Type\"],\r\n  },\r\n  {\r\n    name: \"Parser type error 3\",\r\n    code: `(function f (if true (into 2 {}) (+ 2 2)))`,\r\n    err: [\"Type\"],\r\n  },\r\n  { name: \"Parser arity error 1\", code: `(abs)`, err: [\"Parse\"] },\r\n];\r\n\r\nexport function doTests(\r\n  invoke: (\r\n    ctx: Ctx,\r\n    code: string,\r\n    invokeId: string,\r\n    print: boolean,\r\n  ) => InvokeResult,\r\n  terse = true,\r\n): string[] {\r\n  const results: {\r\n    okErr: boolean;\r\n    okOut: boolean;\r\n    elapsedMs: number;\r\n    display: string;\r\n  }[] = [];\r\n  for (let t = 0; t < len(tests); ++t) {\r\n    const { name, code, err, out } = tests[t];\r\n    const state: State = {\r\n      dict: new Map<string, Val>(),\r\n      output: \"\",\r\n    };\r\n    const env: Env = { funcs: {}, vars: {} };\r\n    const startTime = getTimeMs();\r\n    const valOrErrs = invoke(\r\n      {\r\n        get: (key: string) => get(state, key),\r\n        set: (key: string, val: Val) => set(state, key, val),\r\n        print: (str, withNewLine) => {\r\n          state.output += str + (withNewLine ? \"\\n\" : \"\");\r\n        },\r\n        exe: (name: string, args: Val[]) => exe(state, name, args),\r\n        functions: {},\r\n        env,\r\n        loopBudget: 10000,\r\n        rangeBudget: 1000,\r\n        callBudget: 1000,\r\n        recurBudget: 10000,\r\n      },\r\n      code,\r\n      code,\r\n      true,\r\n    );\r\n    const errors = valOrErrs.kind === \"errors\" ? valOrErrs.errors : [];\r\n    const okErr = (err || []).join() === errors.map(({ e }) => e).join();\r\n    const okOut = !out || trim(state.output) === out;\r\n    const elapsedMs = getTimeMs() - startTime;\r\n    const [tNum, tName, tElapsed, tOutput, tErrors] = [\r\n      padEnd(`${t + 1}`, 3),\r\n      padEnd(name, 24),\r\n      padEnd(`${round(elapsedMs)}ms`, 6),\r\n      okOut || out + \"\\t!=\\t\" + trim(state.output),\r\n      okErr ||\r\n        errors.map(\r\n          ({ e, m, errCtx: { line, col } }) => `${e} ${line}:${col}: ${m}`,\r\n        ),\r\n    ];\r\n    results.push({\r\n      okErr,\r\n      okOut,\r\n      elapsedMs,\r\n      display: `${tNum} ${tName} ${tElapsed} ${tOutput} ${tErrors}`,\r\n    });\r\n  }\r\n  const totalMs = results.reduce((sum, { elapsedMs }) => sum + elapsedMs, 0);\r\n  const numPassed = len(results.filter(({ okOut, okErr }) => okOut && okErr));\r\n  return concat(\r\n    results.filter(r => !terse || !r.okOut || !r.okErr).map(r => r.display),\r\n    [`---- ${numPassed}/${len(results)} tests passed in ${round(totalMs)}ms.`],\r\n  );\r\n}\r\n","import { len, slice, splice } from \"./poly-fills\";\r\nimport { assertUnreachable, Dict, Func, InvokeError, Val } from \"./types\";\r\n\r\nexport const num = ({ v }: Val) => v as number;\r\nexport const str = ({ v }: Val) => v as string;\r\nexport const vec = ({ v }: Val) => v as Val[];\r\nexport const dic = ({ v }: Val) => v as Dict;\r\n\r\nexport const _boo = (v: boolean) => <Val>{ t: \"bool\", v };\r\nexport const _num = (v: number) => <Val>{ t: \"num\", v };\r\nexport const _str = (v = \"\") => <Val>{ t: \"str\", v };\r\nexport const _key = (v: string) => <Val>{ t: \"key\", v };\r\nexport const _vec = (v: Val[] = []) => <Val>{ t: \"vec\", v };\r\nexport const _dic = (v: Dict) => <Val>{ t: \"dict\", v };\r\nexport const _nul = () => <Val>{ t: \"null\", v: undefined };\r\nexport const _fun = (v: string) => <Val>{ t: \"func\", v };\r\n\r\nexport const isVecEqual = (a: Val[], b: Val[]): boolean =>\r\n  len(a) === len(b) && !a.some((x, i) => !isEqual(x, b[i]));\r\n\r\nexport const isEqual = (a: Val, b: Val) => {\r\n  if (a.t === \"wild\" || b.t === \"wild\") {\r\n    return true;\r\n  }\r\n  if (a.t !== b.t) {\r\n    return false;\r\n  }\r\n  switch (a.t) {\r\n    case \"null\":\r\n      return true;\r\n    case \"bool\":\r\n      return a.v === b.v;\r\n    case \"num\":\r\n      return a.v === b.v;\r\n    case \"vec\":\r\n      return isVecEqual(a.v, vec(b));\r\n    case \"dict\": {\r\n      const bd = dic(b);\r\n      return len(a.v.keys) === len(bd.keys) && isVecEqual(a.v.keys, bd.keys);\r\n    }\r\n    case \"str\":\r\n    case \"ref\":\r\n    case \"key\":\r\n    case \"func\":\r\n      return str(a) === str(b);\r\n    case \"clo\":\r\n      return (<Func>a.v).name === (<Func>b.v).name;\r\n    case \"ext\":\r\n      return a.v === b.v;\r\n  }\r\n  return assertUnreachable(a);\r\n};\r\n\r\nexport const stringify = (vals: Val[]) =>\r\n  vals.reduce((cat, v) => cat + val2str(v), \"\");\r\n\r\nconst quoteStr = (str: string) =>\r\n  str\r\n    .split(\"\")\r\n    .map(ch => (ch === '\"' ? '\\\\\"' : ch))\r\n    .join(\"\");\r\n\r\nexport const val2str = (val: Val): string => {\r\n  const quoted = (v: Val) =>\r\n    v.t === \"str\" ? `\"${quoteStr(v.v)}\"` : val2str(v);\r\n  if (val.t === \"clo\") {\r\n    return val.v.name ?? \"\";\r\n  } else if (val.t === \"vec\") {\r\n    return `[${val.v.map(quoted).join(\" \")}]`;\r\n  } else if (val.t === \"dict\") {\r\n    const { keys, vals } = val.v;\r\n    const [ks, vs] = [keys.map(quoted), vals.map(quoted)];\r\n    const entries = ks.map((k, i) => `${k} ${vs[i]}`);\r\n    return `{${entries.join(\", \")}}`;\r\n  } else if (val.t === \"null\") {\r\n    return \"null\";\r\n  } else if (val.t === \"wild\") {\r\n    return \"_\";\r\n  }\r\n  return `${val.v}`;\r\n};\r\n\r\nexport const asArray = (val: Val): Val[] =>\r\n  val.t === \"vec\"\r\n    ? slice(val.v)\r\n    : val.t === \"str\"\r\n    ? [...val.v].map(s => ({ t: \"str\", v: s }))\r\n    : val.t === \"dict\"\r\n    ? val.v.keys.map((k, i) => ({\r\n        t: \"vec\",\r\n        v: [k, val.v.vals[i]],\r\n      }))\r\n    : [];\r\n\r\nexport const toDict = (args: Val[]): Val => {\r\n  if (len(args) % 2 === 1) {\r\n    args.pop();\r\n  }\r\n  const keys = args.filter((_, i) => i % 2 === 0);\r\n  const vals = args.filter((_, i) => i % 2 === 1);\r\n  const ddKeys: Val[] = [],\r\n    ddVals: Val[] = [];\r\n  keys.forEach((key, i) => {\r\n    const existingIdx = ddKeys.findIndex(k => isEqual(k, key));\r\n    if (existingIdx === -1) {\r\n      ddKeys.push(key);\r\n      ddVals.push(vals[i]);\r\n    } else {\r\n      ddVals[existingIdx] = vals[i];\r\n    }\r\n  });\r\n  return {\r\n    t: \"dict\",\r\n    v: { keys: ddKeys, vals: ddVals },\r\n  };\r\n};\r\n\r\nexport const dictGet = ({ keys, vals }: Dict, key: Val) => {\r\n  const idx = keys.findIndex(k => isEqual(k, key));\r\n  return idx === -1 ? <Val>{ t: \"null\", v: undefined } : vals[idx];\r\n};\r\n\r\nexport const dictSet = ({ keys, vals }: Dict, key: Val, val: Val) => {\r\n  const [nKeys, nVals] = [slice(keys), slice(vals)];\r\n  const idx = keys.findIndex(k => isEqual(k, key));\r\n  if (idx !== -1) {\r\n    nVals[idx] = val;\r\n  } else {\r\n    nKeys.push(key);\r\n    nVals.push(val);\r\n  }\r\n  return <Dict>{ keys: nKeys, vals: nVals };\r\n};\r\n\r\nexport const dictDrop = ({ keys, vals }: Dict, key: Val) => {\r\n  const [nKeys, nVals] = [slice(keys), slice(vals)];\r\n  const idx = keys.findIndex(k => isEqual(k, key));\r\n  if (idx !== -1) {\r\n    splice(nKeys, idx, 1);\r\n    splice(nVals, idx, 1);\r\n  }\r\n  return <Val>{ t: \"dict\", v: <Dict>{ keys: nKeys, vals: nVals } };\r\n};\r\n\r\nexport function errorsToDict(errors: InvokeError[]) {\r\n  const newKey = (d: Dict, k: string, v: Val) =>\r\n    dictSet(d, { t: \"key\", v: k }, v);\r\n  return errors.map(({ e, m, errCtx }) => {\r\n    let dict = newKey({ keys: [], vals: [] }, \":e\", { t: \"str\", v: e });\r\n    dict = newKey(dict, \":m\", { t: \"str\", v: m });\r\n    dict = newKey(dict, \":line\", { t: \"num\", v: errCtx.line });\r\n    dict = newKey(dict, \":col\", { t: \"num\", v: errCtx.col });\r\n    return <Val>{ t: \"dict\", v: dict };\r\n  });\r\n}\r\n\r\n/** Replaces or sets index or key/value with another value in a string or\r\n * dictionary */\r\nexport function pathSet(path: Val[], replacement: Val, coll: Val): Val {\r\n  //If we're at the end of the path or it's a non-number index for non-dict\r\n  if (\r\n    !len(path) ||\r\n    (coll.t !== \"vec\" && coll.t !== \"dict\") ||\r\n    (coll.t === \"vec\" &&\r\n      (path[0].t !== \"num\" || path[0].v < 0 || path[0].v > len(coll.v)))\r\n  ) {\r\n    return coll;\r\n  }\r\n  if (coll.t === \"vec\") {\r\n    const vecCopy = slice(coll.v);\r\n    const idx = num(path[0]);\r\n    if (len(path) === 1) {\r\n      vecCopy[idx] = replacement;\r\n      return { t: \"vec\", v: vecCopy };\r\n    }\r\n    vecCopy[idx] = pathSet(slice(path, 1), replacement, vecCopy[idx]);\r\n    return { t: \"vec\", v: vecCopy };\r\n  }\r\n  if (len(path) === 1) {\r\n    return { t: \"dict\", v: dictSet(coll.v, path[0], replacement) };\r\n  }\r\n  return {\r\n    t: \"dict\",\r\n    v: dictSet(\r\n      coll.v,\r\n      path[0],\r\n      pathSet(slice(path, 1), replacement, dictGet(coll.v, path[0])),\r\n    ),\r\n  };\r\n}\r\n","export const insituxVersion = 220414;\r\nimport { asBoo } from \"./checks\";\r\nimport { arityCheck, keyOpErr, numOpErr, typeCheck, typeErr } from \"./checks\";\r\nimport { makeEnclosure } from \"./closure\";\r\nimport { parse } from \"./parse\";\r\nimport * as pf from \"./poly-fills\";\r\nconst { abs, sign, sqrt, floor, ceil, round, max, min, logn, log2, log10 } = pf;\r\nconst { cos, sin, tan, acos, asin, atan, sinh, cosh, tanh } = pf;\r\nconst { concat, has, flat, push, reverse, slice, splice, sortBy } = pf;\r\nconst { ends, slen, starts, sub, subIdx, substr, upperCase, lowerCase } = pf;\r\nconst { trim, trimStart, trimEnd, strIdx, replace, rreplace } = pf;\r\nconst { charCode, codeChar, getTimeMs, randInt, randNum } = pf;\r\nconst { isNum, len, objKeys, range, toNum, isArray } = pf;\r\nimport { doTests } from \"./test\";\r\nimport { assertUnreachable, Env, InvokeError, InvokeResult } from \"./types\";\r\nimport { ExternalFunctions, syntaxes } from \"./types\";\r\nimport { Ctx, Dict, ErrCtx, Func, Ins, Val, ops, typeNames } from \"./types\";\r\nimport { asArray, isEqual, num, str, stringify, val2str, vec } from \"./val\";\r\nimport { dic, dictDrop, dictGet, dictSet, toDict, pathSet } from \"./val\";\r\nimport { _boo, _num, _str, _key, _vec, _dic, _nul, _fun } from \"./val\";\r\n\r\nlet letsStack: { [key: string]: Val }[] = [];\r\nlet lets: typeof letsStack[0] = {};\r\nlet recurArgs: undefined | Val[];\r\n\r\ntype _Exception = { errors: InvokeError[] };\r\nfunction _throw(errors: InvokeError[]): Val {\r\n  throw <_Exception>{ errors };\r\n}\r\nfunction isThrown(e: unknown): e is _Exception {\r\n  return !!e && typeof e === \"object\" && \"errors\" in e!;\r\n}\r\nconst throwTypeErr = (msg: string, errCtx: ErrCtx) =>\r\n  _throw([typeErr(msg, errCtx)]);\r\n\r\nfunction exeOp(op: string, args: Val[], ctx: Ctx, errCtx: ErrCtx): Val {\r\n  switch (op) {\r\n    case \"str\":\r\n      return _str(stringify(args));\r\n    case \"strn\":\r\n      return _str(stringify(args.filter(a => a.t !== \"null\")));\r\n    case \"print\":\r\n    case \"print-str\":\r\n      ctx.print(stringify(args), op === \"print\");\r\n      return _nul();\r\n    case \"vec\":\r\n      return _vec(args);\r\n    case \"dict\":\r\n      return toDict(args);\r\n    case \"len\":\r\n      return _num(\r\n        args[0].t === \"str\"\r\n          ? slen(args[0].v)\r\n          : args[0].t === \"vec\"\r\n          ? len(args[0].v)\r\n          : len(dic(args[0]).keys),\r\n      );\r\n    case \"to-num\":\r\n      if (isNum(args[0].v)) {\r\n        return _num(toNum(args[0].v));\r\n      } else {\r\n        return _nul();\r\n      }\r\n    case \"to-key\":\r\n      return _key(`:${val2str(args[0])}`);\r\n    case \"to-vec\":\r\n      return _vec(asArray(args[0]));\r\n    case \"!\":\r\n      return _boo(!asBoo(args[0]));\r\n    case \"=\":\r\n    case \"!=\":\r\n      for (let i = 1, lim = len(args); i < lim; ++i) {\r\n        if (isEqual(args[i - 1], args[i]) !== (op === \"=\")) {\r\n          return _boo(false);\r\n        }\r\n      }\r\n      return _boo(true);\r\n    case \"-\":\r\n      return _num(args.map(num).reduce((sum, n) => sum - n));\r\n    case \"**\":\r\n      return _num(num(args[0]) ** (len(args) === 1 ? 2 : num(args[1])));\r\n    case \"+\":\r\n      return _num(args.map(num).reduce((sum, n) => sum + n));\r\n    case \"*\":\r\n      return _num(args.map(num).reduce((sum, n) => sum * n));\r\n    case \"/\":\r\n      return _num(args.map(num).reduce((sum, n) => sum / n));\r\n    case \"//\":\r\n      return _num(args.map(num).reduce((sum, n) => floor(sum / n)));\r\n    case \"fast=\":\r\n    case \"fast!=\":\r\n      return _boo(isEqual(args[0], args[1]) === (op === \"fast=\"));\r\n    case \"fast-\":\r\n      return _num(<number>args[0].v - <number>args[1].v);\r\n    case \"fast+\":\r\n      return _num(<number>args[0].v + <number>args[1].v);\r\n    case \"fast*\":\r\n      return _num(<number>args[0].v * <number>args[1].v);\r\n    case \"fast/\":\r\n      return _num(<number>args[0].v / <number>args[1].v);\r\n    case \"fast//\":\r\n      return _num(floor(<number>args[0].v / <number>args[1].v));\r\n    case \"fast<\":\r\n      return _boo(<number>args[0].v < <number>args[1].v);\r\n    case \"fast>\":\r\n      return _boo(<number>args[0].v > <number>args[1].v);\r\n    case \"fast<=\":\r\n      return _boo(<number>args[0].v <= <number>args[1].v);\r\n    case \"fast>=\":\r\n      return _boo(<number>args[0].v >= <number>args[1].v);\r\n    case \"neg\":\r\n      return _num(-num(args[0]));\r\n    case \"rem\":\r\n      return _num(args.map(num).reduce((sum, n) => sum % n));\r\n    case \"min\":\r\n      return _num(args.map(num).reduce((sum, n) => min(sum, n)));\r\n    case \"max\":\r\n      return _num(args.map(num).reduce((sum, n) => max(sum, n)));\r\n    case \"<\":\r\n    case \">\":\r\n    case \"<=\":\r\n    case \">=\":\r\n      for (let i = 1, lim = len(args); i < lim; ++i) {\r\n        const [a, b] = [<number>args[i - 1].v, <number>args[i].v];\r\n        if (\r\n          (op === \"<\" && a >= b) ||\r\n          (op === \">\" && a <= b) ||\r\n          (op === \"<=\" && a > b) ||\r\n          (op === \">=\" && a < b)\r\n        ) {\r\n          return _boo(false);\r\n        }\r\n      }\r\n      return _boo(true);\r\n    case \"inc\":\r\n      return _num(<number>args[0].v + 1);\r\n    case \"dec\":\r\n      return _num(<number>args[0].v - 1);\r\n    case \"abs\":\r\n      return _num(abs(<number>args[0].v));\r\n    case \"round\":\r\n      if (len(args) === 2) {\r\n        const x = 10 ** <number>args[0].v;\r\n        return _num(round(<number>args[1].v * x) / x);\r\n      } else {\r\n        return _num(round(<number>args[0].v));\r\n      }\r\n    case \"sin\":\r\n    case \"cos\":\r\n    case \"tan\":\r\n    case \"sqrt\":\r\n    case \"floor\":\r\n    case \"ceil\":\r\n    case \"logn\":\r\n    case \"log2\":\r\n    case \"log10\": {\r\n      const f = { sin, cos, tan, sqrt, floor, ceil, logn, log2, log10 }[op];\r\n      return _num(f(num(args[0])));\r\n    }\r\n    case \"asin\":\r\n    case \"acos\":\r\n    case \"atan\":\r\n    case \"sinh\":\r\n    case \"cosh\":\r\n    case \"tanh\": {\r\n      const f = { asin, acos, atan, sinh, cosh, tanh }[op];\r\n      return _num(f(num(args[0])));\r\n    }\r\n    case \"and\":\r\n      return _boo(args.every(asBoo));\r\n    case \"or\": {\r\n      const i = args.findIndex(asBoo);\r\n      return i === -1 ? _nul() : args[i];\r\n    }\r\n    case \"xor\":\r\n      if (asBoo(args[0]) !== asBoo(args[1])) {\r\n        return asBoo(args[0]) ? args[0] : args[1];\r\n      } else {\r\n        return _boo(false);\r\n      }\r\n    case \"&\":\r\n    case \"|\":\r\n    case \"^\":\r\n    case \"<<\":\r\n    case \">>\":\r\n    case \">>>\":\r\n      const [a, b] = [num(args[0]), num(args[1])];\r\n      return _num(\r\n        op === \"&\"\r\n          ? a & b\r\n          : op === \"|\"\r\n          ? a | b\r\n          : op === \"^\"\r\n          ? a ^ b\r\n          : op === \"<<\"\r\n          ? a << b\r\n          : op === \">>\"\r\n          ? a >> b\r\n          : a >>> b,\r\n      );\r\n    case \"~\":\r\n      return _num(~num(args[0]));\r\n    case \"odd?\":\r\n    case \"even?\":\r\n      return _boo(num(args[0]) % 2 === (op === \"odd?\" ? 1 : 0));\r\n    case \"pos?\":\r\n    case \"neg?\":\r\n    case \"zero?\": {\r\n      const n = num(args[0]);\r\n      return _boo(op === \"pos?\" ? n > 0 : op === \"neg?\" ? n < 0 : !n);\r\n    }\r\n    case \"null?\":\r\n    case \"num?\":\r\n    case \"bool?\":\r\n    case \"str?\":\r\n    case \"dict?\":\r\n    case \"vec?\":\r\n    case \"key?\":\r\n    case \"func?\":\r\n    case \"wild?\":\r\n    case \"ext?\": {\r\n      const { t } = args[0];\r\n      return _boo(\r\n        (op === \"func?\" && (t === \"func\" || t === \"clo\")) ||\r\n          substr(op, 0, slen(op) - 1) === t,\r\n      );\r\n    }\r\n    case \"type-of\":\r\n      return _str(args[0].t);\r\n    case \"substr?\":\r\n      return _boo(!!slen(str(args[0])) && sub(str(args[1]), str(args[0])));\r\n    case \"idx\": {\r\n      let i = -1;\r\n      if (args[1].t === \"str\") {\r\n        if (args[0].t !== \"str\") {\r\n          throwTypeErr(\"strings can only contain strings\", errCtx);\r\n        } else {\r\n          i = subIdx(args[0].v, args[1].v);\r\n        }\r\n      } else if (args[1].t === \"vec\") {\r\n        i = args[1].v.findIndex(a => isEqual(a, args[0]));\r\n      }\r\n      if (i === -1) {\r\n        return _nul();\r\n      } else {\r\n        return _num(i);\r\n      }\r\n    }\r\n    case \"set-at\": {\r\n      const [pathVal, replacement, coll] = args;\r\n      return pathSet(vec(pathVal), replacement, coll);\r\n    }\r\n    case \"juxt\": {\r\n      const makeArg = (value: Val): Ins[] => [\r\n        { typ: \"val\", value, errCtx },\r\n        { typ: \"upa\", value: -1, text: \"args\", errCtx },\r\n        { typ: \"val\", value: _fun(\"...\"), errCtx },\r\n        { typ: \"exe\", value: 2, errCtx },\r\n      ];\r\n      const ins: Ins[] = [\r\n        ...flat(args.map(makeArg)),\r\n        { typ: \"val\", value: _fun(\"vec\"), errCtx },\r\n        { typ: \"exe\", value: len(args), errCtx },\r\n      ];\r\n      return {\r\n        t: \"clo\",\r\n        v: <Func>{\r\n          name: `(juxt ${args.map(val2str).join(\" \")})`,\r\n          ins,\r\n        },\r\n      };\r\n    }\r\n    case \"pos-juxt\": {\r\n      const makeArg = (value: Val, n: number): Ins[] => [\r\n        { typ: \"dpa\", value: [0, n], errCtx },\r\n        { typ: \"val\", value, errCtx },\r\n        { typ: \"exe\", value: 1, errCtx },\r\n      ];\r\n      const ins: Ins[] = [\r\n        ...flat(args.map(makeArg)),\r\n        { typ: \"val\", value: _fun(\"vec\"), errCtx },\r\n        { typ: \"exe\", value: len(args), errCtx },\r\n      ];\r\n      return {\r\n        t: \"clo\",\r\n        v: <Func>{\r\n          name: `(pos-juxt ${args.map(val2str).join(\" \")})`,\r\n          ins,\r\n        },\r\n      };\r\n    }\r\n    case \"map\":\r\n    case \"for\":\r\n    case \"reduce\":\r\n    case \"reductions\":\r\n    case \"filter\":\r\n    case \"remove\":\r\n    case \"find\":\r\n    case \"count\": {\r\n      const closure = getExe(ctx, args.shift()!, errCtx);\r\n      if (op === \"map\" || op === \"for\") {\r\n        const badArg = args.findIndex(\r\n          ({ t }) => t !== \"vec\" && t !== \"str\" && t !== \"dict\",\r\n        );\r\n        if (badArg !== -1) {\r\n          const badType = typeNames[args[badArg].t];\r\n          throwTypeErr(\r\n            `argument ${\r\n              badArg + 2\r\n            } must be either: string, vector, dictionary, not ${badType}`,\r\n            errCtx,\r\n          );\r\n        }\r\n      }\r\n\r\n      if (op === \"for\") {\r\n        const arrays = args.map(asArray);\r\n        const lims = arrays.map(len);\r\n        const divisors = lims.map((_, i) =>\r\n          slice(lims, 0, i + 1).reduce((sum, l) => sum * l),\r\n        );\r\n        divisors.unshift(1);\r\n        const lim = divisors.pop()!;\r\n        if (lim > ctx.loopBudget) {\r\n          _throw([{ e: \"Budget\", m: \"would exceed loop budget\", errCtx }]);\r\n        }\r\n        const array: Val[] = [];\r\n        for (let t = 0; t < lim; ++t) {\r\n          const argIdxs = divisors.map((d, i) => floor((t / d) % lims[i]));\r\n          array.push(closure(arrays.map((a, i) => a[argIdxs[i]])));\r\n        }\r\n        return _vec(array);\r\n      }\r\n\r\n      if (op === \"map\") {\r\n        const arrays = args.map(asArray);\r\n        const shortest = min(...arrays.map(len));\r\n        const array: Val[] = [];\r\n        for (let i = 0; i < shortest; ++i) {\r\n          array.push(closure(arrays.map(a => a[i])));\r\n        }\r\n        return _vec(array);\r\n      }\r\n\r\n      if (op !== \"reduce\" && op != \"reductions\") {\r\n        const arrArg = args.shift()!;\r\n        const array = asArray(arrArg);\r\n        const isRemove = op === \"remove\",\r\n          isFind = op === \"find\",\r\n          isCount = op === \"count\";\r\n        const filtered: Val[] = [];\r\n        let count = 0;\r\n        for (let i = 0, lim = len(array); i < lim; ++i) {\r\n          const b = asBoo(closure([array[i], ...args]));\r\n          if (isCount) {\r\n            count += b ? 1 : 0;\r\n          } else if (isFind) {\r\n            if (b) {\r\n              return array[i];\r\n            }\r\n          } else if (b !== isRemove) {\r\n            filtered.push(array[i]);\r\n          }\r\n        }\r\n        switch (op) {\r\n          case \"count\":\r\n            return _num(count);\r\n          case \"find\":\r\n            return _nul();\r\n        }\r\n        if (arrArg.t === \"str\") {\r\n          return _str(filtered.map(v => val2str(v)).join(\"\"));\r\n        } else if (arrArg.t === \"dict\") {\r\n          return toDict(flat(filtered.map(v => <Val[]>v.v)));\r\n        } else {\r\n          return _vec(filtered);\r\n        }\r\n      }\r\n      const arrayVal = args.pop()!;\r\n      if (!has([\"vec\", \"dict\", \"str\"], arrayVal.t)) {\r\n        throwTypeErr(\r\n          `must reduce either: string, vector, dictionary, not ${\r\n            typeNames[arrayVal.t]\r\n          }`,\r\n          errCtx,\r\n        );\r\n      }\r\n      const array = asArray(arrayVal);\r\n\r\n      if (!len(array)) {\r\n        if (len(args)) {\r\n          return args[0];\r\n        } else {\r\n          return _vec();\r\n        }\r\n      }\r\n      if (len(array) < 2 && !len(args)) {\r\n        return array[0];\r\n      }\r\n\r\n      let reduction: Val = (len(args) ? args : array).shift()!;\r\n      if (op === \"reductions\") {\r\n        const reductions: Val[] = [];\r\n        for (let i = 0, lim = len(array); i < lim; ++i) {\r\n          reductions.push(reduction);\r\n          reduction = closure([reduction, array[i]]);\r\n        }\r\n        reductions.push(reduction);\r\n        return _vec(reductions);\r\n      }\r\n      for (let i = 0, lim = len(array); i < lim; ++i) {\r\n        reduction = closure([reduction, array[i]]);\r\n      }\r\n      return reduction;\r\n    }\r\n    case \"repeat\":\r\n    case \"times\": {\r\n      const toRepeat = args[op === \"repeat\" ? 0 : 1];\r\n      const result: Val[] = [];\r\n      const count = num(args[op === \"repeat\" ? 1 : 0]);\r\n      if (count > ctx.rangeBudget) {\r\n        _throw([{ e: \"Budget\", m: \"would exceed range budget\", errCtx }]);\r\n      }\r\n      ctx.rangeBudget -= count;\r\n      if (toRepeat.t === \"func\" || toRepeat.t === \"clo\") {\r\n        const closure = getExe(ctx, toRepeat, errCtx);\r\n        for (let i = 0; i < count; ++i) {\r\n          result.push(closure([_num(i)]));\r\n        }\r\n      } else {\r\n        for (let i = 0; i < count; ++i) {\r\n          result.push(toRepeat);\r\n        }\r\n      }\r\n      return _vec(result);\r\n    }\r\n    case \"rand-int\":\r\n    case \"rand\": {\r\n      const nArgs = len(args);\r\n      const [a, b] = [\r\n        nArgs < 2 ? 0 : num(args[0]),\r\n        nArgs === 0\r\n          ? 1 + toNum(op === \"rand-int\")\r\n          : nArgs === 1\r\n          ? num(args[0])\r\n          : num(args[1]),\r\n      ];\r\n      return _num(op === \"rand-int\" ? randInt(a, b) : randNum(a, b));\r\n    }\r\n    case \"do\":\r\n    case \"val\":\r\n      return op === \"do\" ? args.pop()! : args.shift()!;\r\n    case \".\":\r\n    case \"..\":\r\n    case \"...\": {\r\n      const closure = getExe(ctx, args.shift()!, errCtx);\r\n      if (op === \".\") {\r\n        return closure(args);\r\n      }\r\n      let flatArgs: Val[] = args;\r\n      if (op === \"..\") {\r\n        flatArgs = flat(args.map(a => (a.t === \"vec\" ? a.v : [a])));\r\n      } else {\r\n        const a = flatArgs.pop()!;\r\n        push(flatArgs, flat([a.t === \"vec\" ? a.v : [a]]));\r\n      }\r\n      return closure(flatArgs);\r\n    }\r\n    case \"into\": {\r\n      if (args[0].t === \"vec\") {\r\n        return _vec(concat(args[0].v, asArray(args[1])));\r\n      } else {\r\n        if (args[1].t === \"vec\") {\r\n          return toDict(concat(flat(asArray(args[0]).map(vec)), args[1].v));\r\n        } else {\r\n          const { keys: ks1, vals: vs1 } = dic(args[0]);\r\n          const { keys: ks2, vals: vs2 } = dic(args[1]);\r\n          return _dic({ keys: concat(ks1, ks2), vals: concat(vs1, vs2) });\r\n        }\r\n      }\r\n    }\r\n    case \"omit\":\r\n      return dictDrop(dic(args[1]), args[0]);\r\n    case \"drop\": {\r\n      const [n, v] = [num(args[0]), vec(args[1])];\r\n      return _vec(concat(slice(v, 0, n), slice(v, n + 1)));\r\n    }\r\n    case \"assoc\":\r\n      return _dic(dictSet(dic(args[2]), args[0], args[1]));\r\n    case \"append\":\r\n      return _vec(concat(vec(args[1]), [args[0]]));\r\n    case \"prepend\":\r\n      return _vec(concat([args[0]], vec(args[1])));\r\n    case \"insert\": {\r\n      const v = vec(args[2]);\r\n      let n = num(args[1]);\r\n      if (n === 0) {\r\n        return _vec(concat([args[0]], v));\r\n      } else if (n === -1) {\r\n        return _vec(concat(v, [args[0]]));\r\n      } else {\r\n        n = n > 0 ? min(n, len(v)) : max(len(v) + 1 + n, 0);\r\n        return _vec(concat(concat(slice(v, 0, n), [args[0]]), slice(v, n)));\r\n      }\r\n    }\r\n    case \"sect\": {\r\n      const v = args[0];\r\n      const vlen = v.t === \"vec\" ? len(v.v) : slen(str(v));\r\n      let a = 0,\r\n        b = vlen;\r\n      switch (len(args)) {\r\n        case 1:\r\n          a = 1;\r\n          break;\r\n        case 2: {\r\n          const del = num(args[1]);\r\n          if (del < 0) {\r\n            b += del;\r\n          } else {\r\n            a += del;\r\n          }\r\n          break;\r\n        }\r\n        case 3: {\r\n          const skip = num(args[1]);\r\n          const take = num(args[2]);\r\n          a = skip < 0 ? vlen + skip + (take < 0 ? take : 0) : a + skip;\r\n          b = (take < 0 ? b : a) + take;\r\n          break;\r\n        }\r\n      }\r\n      a = max(a, 0);\r\n      b = min(b, vlen);\r\n      if (a > b) {\r\n        return (v.t === \"vec\" ? _vec : _str)();\r\n      }\r\n      if (v.t === \"vec\") {\r\n        return _vec(slice(v.v, a, b));\r\n      } else {\r\n        return _str(substr(str(args[0]), a, b - a));\r\n      }\r\n    }\r\n    case \"skip\":\r\n    case \"first\":\r\n    case \"last\":\r\n    case \"crop\": {\r\n      const a = max(0, num(args[0]));\r\n      const { t, v } = args[op === \"crop\" ? 2 : 1];\r\n      const l = t === \"str\" ? slen(<string>v) : len(<Val[]>v);\r\n      let x = op === \"first\" ? 0 : op === \"last\" ? l - a : a;\r\n      const y =\r\n        op === \"first\" ? a : op === \"crop\" ? l - max(0, num(args[1])) : l;\r\n      x = x > y ? y : x;\r\n      return t === \"str\"\r\n        ? _str(substr(<string>v, x, y - x))\r\n        : _vec(slice(<Val[]>v, x, y));\r\n    }\r\n    case \"reverse\":\r\n      if (args[0].t === \"str\") {\r\n        return _str(stringify(reverse(asArray(args[0]))));\r\n      } else {\r\n        return _vec(reverse(asArray(args[0])));\r\n      }\r\n    case \"flatten\": {\r\n      const src = vec(args[0]);\r\n      const flattened: Val[] = [];\r\n      const recur = (vec: Val[]): void =>\r\n        vec.forEach(v => (v.t === \"vec\" ? recur(v.v) : flattened.push(v)));\r\n      recur(src);\r\n      return _vec(flattened);\r\n    }\r\n    case \"shuffle\": {\r\n      const arr = slice(vec(args[0]));\r\n      for (let i = len(arr) - 1; i; --i) {\r\n        const j = floor(randInt(0, i + 1));\r\n        [arr[i], arr[j]] = [arr[j], arr[i]];\r\n      }\r\n      return _vec(arr);\r\n    }\r\n    case \"sample\": {\r\n      const shuffled = slice(vec(args[1]));\r\n      const size = max(0, min(len(shuffled), num(args[0])));\r\n      const minimum = len(shuffled) - size;\r\n      for (let i = len(shuffled) - 1; i > minimum; --i) {\r\n        const index = floor(randInt(0, i + 1));\r\n        [shuffled[i], shuffled[index]] = [shuffled[index], shuffled[i]];\r\n      }\r\n      return _vec(slice(shuffled, minimum));\r\n    }\r\n    case \"sort\":\r\n    case \"sort-by\": {\r\n      const src = asArray(args[op === \"sort\" ? 0 : 1]);\r\n      if (!len(src)) {\r\n        return _vec();\r\n      }\r\n      const mapped: Val[][] = [];\r\n      if (op === \"sort\") {\r\n        push(\r\n          mapped,\r\n          src.map(v => [v, v]),\r\n        );\r\n      } else {\r\n        const closure = getExe(ctx, args[0], errCtx);\r\n        for (let i = 0, lim = len(src); i < lim; ++i) {\r\n          mapped.push([src[i], closure([src[i]])]);\r\n        }\r\n      }\r\n      const okT = mapped[0][1].t;\r\n      if (mapped.some(([_, { t }]) => t !== okT || !has([\"num\", \"str\"], t))) {\r\n        throwTypeErr(\"can only sort by all number or all string\", errCtx);\r\n      }\r\n      if (okT === \"num\") {\r\n        sortBy(mapped, ([x, a], [y, b]) => (num(a) > num(b) ? 1 : -1));\r\n      } else {\r\n        sortBy(mapped, ([x, a], [y, b]) => (str(a) > str(b) ? 1 : -1));\r\n      }\r\n      return _vec(mapped.map(([v]) => v));\r\n    }\r\n    case \"group-by\": {\r\n      const closure = getExe(ctx, args[0], errCtx);\r\n      const groups: Dict = { keys: [], vals: [] };\r\n      const isDic = args[1].t === \"dict\";\r\n      if (isDic) {\r\n        const { keys, vals } = dic(args[1]);\r\n        for (let i = 0, lim = len(keys); i < lim; ++i) {\r\n          const v = closure([keys[i], vals[i]]);\r\n          const existingKey = groups.keys.findIndex(k => isEqual(k, v));\r\n          if (existingKey === -1) {\r\n            groups.keys.push(v);\r\n            groups.vals.push(_dic({ keys: [keys[i]], vals: [vals[i]] }));\r\n          } else {\r\n            const subDict = dic(groups.vals[existingKey]);\r\n            subDict.keys.push(keys[i]);\r\n            subDict.vals.push(vals[i]);\r\n          }\r\n        }\r\n      } else {\r\n        const src = asArray(args[1]);\r\n        for (let i = 0, lim = len(src); i < lim; ++i) {\r\n          const v = closure([src[i]]);\r\n          const existingKey = groups.keys.findIndex(k => isEqual(k, v));\r\n          if (existingKey === -1) {\r\n            groups.keys.push(v);\r\n            groups.vals.push(_vec([src[i]]));\r\n          } else {\r\n            const subVec = vec(groups.vals[existingKey]);\r\n            subVec.push(src[i]);\r\n          }\r\n        }\r\n      }\r\n      return _dic(groups);\r\n    }\r\n    case \"part-by\": {\r\n      const closure = getExe(ctx, args[0], errCtx);\r\n      const isDic = args[1].t === \"dict\";\r\n      if (isDic) {\r\n        const { keys, vals } = dic(args[1]);\r\n        const parted: Dict[] = [\r\n          { keys: [], vals: [] },\r\n          { keys: [], vals: [] },\r\n        ];\r\n        for (let i = 0, lim = len(keys); i < lim; ++i) {\r\n          const p = asBoo(closure([keys[i], vals[i]])) ? 0 : 1;\r\n          parted[p].keys.push(keys[i]);\r\n          parted[p].vals.push(vals[i]);\r\n        }\r\n        return _vec(parted.map(_dic));\r\n      } else {\r\n        const src = asArray(args[1]);\r\n        const parted: Val[][] = [[], []];\r\n        for (let i = 0, lim = len(src); i < lim; ++i) {\r\n          parted[asBoo(closure([src[i]])) ? 0 : 1].push(src[i]);\r\n        }\r\n        return _vec(parted.map(_vec));\r\n      }\r\n    }\r\n    case \"freqs\": {\r\n      const src = asArray(args[0]);\r\n      const distinct: Val[] = [];\r\n      const counts: number[] = [];\r\n      src.forEach(x => {\r\n        const i = distinct.findIndex(y => isEqual(x, y));\r\n        if (i !== -1) {\r\n          ++counts[i];\r\n        } else {\r\n          distinct.push(x);\r\n          counts.push(1);\r\n        }\r\n      });\r\n      return _dic({ keys: distinct, vals: counts.map(_num) });\r\n    }\r\n    case \"distinct\": {\r\n      const arr = len(args) === 1 && args[0].t === \"vec\" ? vec(args[0]) : args;\r\n      const distinct: Val[] = [];\r\n      arr.forEach(a => {\r\n        if (!distinct.some(v => isEqual(a, v))) {\r\n          distinct.push(a);\r\n        }\r\n      });\r\n      return _vec(distinct);\r\n    }\r\n    case \"range\": {\r\n      const [a, b, s] = args.map(num);\r\n      const edgeCase = s && s < 0 && a < b; //e.g. 1 4 -1\r\n      const [x, y] =\r\n        len(args) > 1 ? (edgeCase ? [b - 1, a - 1] : [a, b]) : [0, a];\r\n      const step = sign((y - x) * (s || 1)) * (s || 1);\r\n      const count = ceil(abs((y - x) / step));\r\n      if (!count) {\r\n        return _vec();\r\n      }\r\n      if (count > ctx.rangeBudget) {\r\n        _throw([{ e: \"Budget\", m: \"would exceed range budget\", errCtx }]);\r\n      }\r\n      ctx.rangeBudget -= count;\r\n      const nums = range(count).map(n => n * step + x);\r\n      return _vec(nums.map(_num));\r\n    }\r\n    case \"empty?\":\r\n      return _boo(!len(asArray(args[0])));\r\n    case \"keys\":\r\n    case \"vals\":\r\n      return _vec(dic(args[0])[op === \"keys\" ? \"keys\" : \"vals\"]);\r\n    case \"split\":\r\n      return _vec(str(args[1]).split(str(args[0])).map(_str));\r\n    case \"join\":\r\n      return _str(asArray(args[1]).map(val2str).join(str(args[0])));\r\n    case \"replace\":\r\n    case \"rreplace\": {\r\n      const rop = op === \"replace\" ? replace : rreplace;\r\n      return _str(rop(str(args[2]), str(args[0]), str(args[1])));\r\n    }\r\n    case \"starts?\":\r\n    case \"ends?\":\r\n      return _boo(\r\n        (op === \"starts?\" ? starts : ends)(str(args[1]), str(args[0])),\r\n      );\r\n    case \"upper-case\":\r\n    case \"lower-case\":\r\n    case \"trim\":\r\n    case \"trim-start\":\r\n    case \"trim-end\":\r\n      return _str(\r\n        (op === \"upper-case\"\r\n          ? upperCase\r\n          : op === \"lower-case\"\r\n          ? lowerCase\r\n          : op === \"trim\"\r\n          ? trim\r\n          : op === \"trim-start\"\r\n          ? trimStart\r\n          : trimEnd)(str(args[0])),\r\n      );\r\n    case \"str*\": {\r\n      const text = str(args[0]);\r\n      return _str(\r\n        range(max(ceil(num(args[1])), 0))\r\n          .map(n => text)\r\n          .join(\"\"),\r\n      );\r\n    }\r\n    case \"char-code\": {\r\n      if (args[0].t === \"str\") {\r\n        const n = len(args) > 1 ? num(args[1]) : 0;\r\n        const s = str(args[0]);\r\n        if (slen(s) <= n || n < 0) {\r\n          return _nul();\r\n        } else {\r\n          return _num(charCode(strIdx(s, n)));\r\n        }\r\n      } else {\r\n        return _str(codeChar(num(args[0])));\r\n      }\r\n    }\r\n    case \"time\":\r\n      return _num(getTimeMs());\r\n    case \"version\":\r\n      return _num(insituxVersion);\r\n    case \"tests\":\r\n      return _str(doTests(invoke, !(len(args) && asBoo(args[0]))).join(\"\\n\"));\r\n    case \"symbols\":\r\n      return _vec(symbols(ctx.env, false).map(_str));\r\n    case \"eval\": {\r\n      delete ctx.env.funcs[\"entry\"];\r\n      const invokeId = `${errCtx.invokeId} eval`;\r\n      try {\r\n        const valOrNone = parseAndExe(ctx, str(args[0]), invokeId, []);\r\n        return valOrNone ? valOrNone : _nul();\r\n      } catch (e) {\r\n        if (isThrown(e)) {\r\n          _throw([\r\n            { e: \"Eval\", m: \"error within evaluated code\", errCtx },\r\n            ...e.errors,\r\n          ]);\r\n        }\r\n      }\r\n    }\r\n    case \"about\": {\r\n      const func = str(args[0]);\r\n      const entry = ops[func];\r\n      if (!entry) {\r\n        return _nul();\r\n      }\r\n      const infos: Val[] = [];\r\n      const info = (what: string, val: Val) =>\r\n        infos.push(_key(`:${what}`), val);\r\n      const toStrVec = (v: (string | string[])[]): Val =>\r\n        _vec(v.map(typ => (isArray(typ) ? _vec(typ.map(_str)) : _str(typ))));\r\n      info(\"external?\", _boo(!!entry.external));\r\n      if (entry.exactArity) {\r\n        info(\"exact-arity\", _num(entry.exactArity));\r\n      } else {\r\n        if (entry.minArity) {\r\n          info(\"minimum-arity\", _num(entry.minArity));\r\n        }\r\n        if (entry.maxArity) {\r\n          info(\"maximum-arity\", _num(entry.maxArity));\r\n        }\r\n      }\r\n      if (entry.params || entry.numeric) {\r\n        info(\"in-types\", toStrVec(entry.params ? entry.params : [\"num\"]));\r\n      }\r\n      if (entry.returns || entry.numeric === true) {\r\n        info(\"out-types\", toStrVec(entry.returns ? entry.returns : [\"num\"]));\r\n      }\r\n      return toDict(infos);\r\n    }\r\n    case \"recur\":\r\n      recurArgs = args;\r\n      return _nul();\r\n    case \"reset\":\r\n      ctx.env.vars = {};\r\n      ctx.env.funcs = {};\r\n      letsStack = [];\r\n      return _nul();\r\n  }\r\n\r\n  return _throw([{ e: \"Unexpected\", m: \"operation doesn't exist\", errCtx }]);\r\n}\r\n\r\nconst monoArityError = (t: Val[\"t\"], errCtx: ErrCtx) => [\r\n  {\r\n    e: \"Arity\",\r\n    m: `${typeNames[t]} as operation requires one sole argument`,\r\n    errCtx,\r\n  },\r\n];\r\n\r\nfunction checks(op: string, args: Val[], errCtx: ErrCtx, checkArity: boolean) {\r\n  //Optional arity check\r\n  if (checkArity) {\r\n    const violations = arityCheck(op, len(args), errCtx);\r\n    if (violations) {\r\n      return violations;\r\n    }\r\n  }\r\n  //Argument type check\r\n  const types = args.map(a => [a.t]);\r\n  const violations = typeCheck(op, types, errCtx);\r\n  return violations ? violations : false;\r\n}\r\n\r\nfunction getExe(\r\n  ctx: Ctx,\r\n  op: Val,\r\n  errCtx: ErrCtx,\r\n  checkArity = true,\r\n): (params: Val[]) => Val {\r\n  if (op.t === \"str\" || op.t === \"func\") {\r\n    const name = op.v;\r\n    if (ops[name]) {\r\n      if (ops[name].external) {\r\n        return (params: Val[]) => {\r\n          const violations = checks(name, params, errCtx, checkArity);\r\n          if (violations) {\r\n            _throw(violations);\r\n          }\r\n          const valOrErr = ctx.functions[name].handler(params);\r\n          if (valOrErr.kind === \"err\") {\r\n            return _throw([{ e: \"External\", m: valOrErr.err, errCtx }]);\r\n          }\r\n          return valOrErr.value;\r\n        };\r\n      }\r\n      return (params: Val[]) => {\r\n        const violations = checks(name, params, errCtx, true);\r\n        if (violations) {\r\n          _throw(violations);\r\n        }\r\n        return exeOp(name, params, ctx, errCtx);\r\n      };\r\n    }\r\n    if (name in ctx.env.funcs && name !== \"entry\") {\r\n      return (params: Val[]) => exeFunc(ctx, ctx.env.funcs[name], params);\r\n    }\r\n    if (name in ctx.env.vars) {\r\n      return getExe(ctx, ctx.env.vars[name], errCtx);\r\n    }\r\n    if (name in lets) {\r\n      return getExe(ctx, lets[name], errCtx);\r\n    }\r\n    if (starts(name, \"$\")) {\r\n      return (params: Val[]) => {\r\n        if (!len(params)) {\r\n          _throw(monoArityError(op.t, errCtx));\r\n        }\r\n        if (!ctx.set) {\r\n          const m = `\"set\" feature not implemented on this platform`;\r\n          return _throw([{ e: \"External\", m, errCtx }]);\r\n        }\r\n        const err = ctx.set(substr(name, 1), params[0]);\r\n        if (err) {\r\n          _throw([{ e: \"External\", m: err, errCtx }]);\r\n        }\r\n        return params[0];\r\n      };\r\n    }\r\n    return (params: Val[]) => {\r\n      if (!ctx.exe) {\r\n        const m = `operation \"${name}\" does not exist\"`;\r\n        return _throw([{ e: \"External\", m, errCtx }]);\r\n      }\r\n      const valAndErr = ctx.exe(name, params);\r\n      if (valAndErr.kind === \"val\") {\r\n        return valAndErr.value;\r\n      }\r\n      return _throw([{ e: \"External\", m: valAndErr.err, errCtx }]);\r\n    };\r\n  } else if (op.t === \"clo\") {\r\n    return (params: Val[]) => exeFunc(ctx, op.v, params);\r\n  } else if (op.t === \"key\") {\r\n    return (params: Val[]) => {\r\n      if (!len(params)) {\r\n        _throw(monoArityError(op.t, errCtx));\r\n      }\r\n      if (params[0].t === \"dict\") {\r\n        return dictGet(dic(params[0]), op);\r\n      } else if (params[0].t === \"vec\") {\r\n        const found = vec(params[0]).find(v => isEqual(v, op));\r\n        return found ?? _nul();\r\n      } else {\r\n        return _throw(keyOpErr(errCtx, [params[0].t]));\r\n      }\r\n    };\r\n  } else if (op.t === \"num\") {\r\n    const n = floor(op.v);\r\n    return (params: Val[]) => {\r\n      if (!len(params)) {\r\n        _throw(monoArityError(op.t, errCtx));\r\n      }\r\n      const a = params[0];\r\n      if (a.t !== \"str\" && a.t !== \"vec\" && a.t !== \"dict\") {\r\n        return _throw(numOpErr(errCtx, [a.t]));\r\n      }\r\n      const arr = asArray(a),\r\n        alen = len(arr);\r\n      if ((n >= 0 && n >= alen) || (n < 0 && -n > alen)) {\r\n        return _nul();\r\n      } else if (n < 0) {\r\n        return arr[alen + n];\r\n      }\r\n      return arr[n];\r\n    };\r\n  } else if (op.t === \"vec\") {\r\n    const { v } = op;\r\n    return (params: Val[]) => {\r\n      if (!len(params)) {\r\n        _throw(monoArityError(op.t, errCtx));\r\n      }\r\n      const found = v.find(val => isEqual(val, params[0]));\r\n      return found ?? _nul();\r\n    };\r\n  } else if (op.t === \"dict\") {\r\n    const dict = op.v;\r\n    return (params: Val[]) => {\r\n      if (len(params) === 1) {\r\n        return dictGet(dict, params[0]);\r\n      } else if (len(params) === 2) {\r\n        return _dic(dictSet(dict, params[0], params[1]));\r\n      }\r\n      return _throw([\r\n        { e: \"Arity\", m: \"provide 1 or 2 arguments for dictionary\", errCtx },\r\n      ]);\r\n    };\r\n  } else if (op.t === \"bool\") {\r\n    const cond = op.v;\r\n    return (params: Val[]) => {\r\n      if (!len(params) || len(params) > 2) {\r\n        return _throw([\r\n          { e: \"Arity\", m: \"provide 1 or 2 arguments for boolean\", errCtx },\r\n        ]);\r\n      }\r\n      return cond ? params[0] : len(params) > 1 ? params[1] : _nul();\r\n    };\r\n  }\r\n  return _ =>\r\n    _throw([\r\n      { e: \"Operation\", m: `${val2str(op)} is an invalid operation`, errCtx },\r\n    ]);\r\n}\r\n\r\nfunction errorsToDict(errors: InvokeError[]) {\r\n  const newKey = (d: Dict, k: string, v: Val) => dictSet(d, _key(k), v);\r\n  return errors.map(({ e, m, errCtx }) => {\r\n    let dict = newKey({ keys: [], vals: [] }, \":e\", _str(e));\r\n    dict = newKey(dict, \":m\", _str(m));\r\n    dict = newKey(dict, \":line\", _num(errCtx.line));\r\n    dict = newKey(dict, \":col\", _num(errCtx.col));\r\n    return _dic(dict);\r\n  });\r\n}\r\n\r\nfunction destruct(args: Val[], shape: number[]): Val {\r\n  let arr: Val[] = args;\r\n  for (let a = 0, b = len(shape) - 1; a < b; ++a) {\r\n    const val = arr[shape[a]];\r\n    if (val.t === \"vec\") {\r\n      arr = val.v;\r\n    } else if (val.t === \"str\" && a + 1 === b && shape[a + 1] < slen(val.v)) {\r\n      return _str(strIdx(val.v, shape[a + 1]));\r\n    } else {\r\n      return _nul();\r\n    }\r\n  }\r\n  const pos = shape[len(shape) - 1];\r\n  return pos >= len(arr) ? _nul() : arr[pos];\r\n}\r\n\r\nfunction exeFunc(ctx: Ctx, func: Func, args: Val[], closureDeref = false): Val {\r\n  --ctx.callBudget;\r\n  if (!closureDeref) {\r\n    letsStack.push({});\r\n    lets = letsStack[len(letsStack) - 1];\r\n  }\r\n  const stack: Val[] = [];\r\n  for (let i = 0, lim = len(func.ins); i < lim; ++i) {\r\n    const ins = func.ins[i];\r\n    const { errCtx } = func.ins[i];\r\n\r\n    const tooManyLoops = ctx.loopBudget < 1;\r\n    if (tooManyLoops || ctx.callBudget < 1) {\r\n      _throw([\r\n        {\r\n          e: \"Budget\",\r\n          m: `${tooManyLoops ? \"looped\" : \"called\"} too many times`,\r\n          errCtx,\r\n        },\r\n      ]);\r\n    }\r\n\r\n    switch (ins.typ) {\r\n      case \"val\":\r\n        stack.push(ins.value);\r\n        break;\r\n      case \"var\":\r\n        ctx.env.vars[ins.value] = stack[len(stack) - 1];\r\n        break;\r\n      case \"let\":\r\n        lets[ins.value] = stack[len(stack) - 1];\r\n        break;\r\n      case \"dle\":\r\n      case \"dva\": {\r\n        const val = stack.pop()!;\r\n        let last: Val | undefined;\r\n        ins.value.forEach(({ name, position }) => {\r\n          if (ins.typ === \"dva\") {\r\n            last = ctx.env.vars[name] = destruct([val], position);\r\n          } else {\r\n            last = lets[name] = destruct([val], position);\r\n          }\r\n        });\r\n        stack.push(last!);\r\n        break;\r\n      }\r\n      case \"npa\":\r\n      case \"upa\": {\r\n        const paramIdx = ins.value;\r\n        if (paramIdx === -1) {\r\n          stack.push(_vec(args));\r\n        } else if (len(args) <= paramIdx) {\r\n          stack.push(_nul());\r\n        } else {\r\n          stack.push(args[paramIdx]);\r\n        }\r\n        break;\r\n      }\r\n      case \"dpa\":\r\n        stack.push(destruct(args, ins.value));\r\n        break;\r\n      case \"ref\": {\r\n        const name = ins.value;\r\n        if (ops[name]) {\r\n          stack.push(_fun(name));\r\n        } else if (starts(name, \"$\")) {\r\n          if (!ctx.get) {\r\n            const m = `\"get\" feature not implemented on this platform`;\r\n            return _throw([{ e: \"External\", m, errCtx }]);\r\n          }\r\n          const valAndErr = ctx.get(substr(name, 1));\r\n          if (valAndErr.kind === \"err\") {\r\n            return _throw([{ e: \"External\", m: valAndErr.err, errCtx }]);\r\n          }\r\n          stack.push(valAndErr.value);\r\n        } else if (name in ctx.env.vars) {\r\n          stack.push(ctx.env.vars[name]);\r\n        } else if (name in lets) {\r\n          stack.push(lets[name]);\r\n        } else if (name in ctx.env.funcs) {\r\n          stack.push(_fun(name));\r\n        } else {\r\n          _throw([{ e: \"Reference\", m: `\"${name}\" did not exist`, errCtx }]);\r\n        }\r\n        break;\r\n      }\r\n      case \"exa\":\r\n      case \"exe\": {\r\n        const op = stack.pop()!;\r\n        const closure = getExe(ctx, op, errCtx, ins.typ === \"exa\");\r\n        const nArgs = ins.value;\r\n        const params = splice(stack, len(stack) - nArgs, nArgs);\r\n        try {\r\n          stack.push(closure(params));\r\n        } catch (e) {\r\n          if (isThrown(e)) {\r\n            //Find next catch statement\r\n            const nextCat = slice(func.ins, i).findIndex(\r\n              ins => ins.typ === \"cat\",\r\n            );\r\n            if (nextCat !== -1) {\r\n              i += nextCat;\r\n              lets[\"errors\"] = _vec(errorsToDict(e.errors));\r\n              break;\r\n            }\r\n          }\r\n          throw e;\r\n        }\r\n        if (recurArgs) {\r\n          letsStack[len(letsStack) - 1] = {};\r\n          i = -1;\r\n          args = recurArgs;\r\n          recurArgs = undefined;\r\n          --ctx.recurBudget;\r\n          if (!ctx.recurBudget) {\r\n            _throw([{ e: \"Budget\", m: `recurred too many times`, errCtx }]);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case \"or\":\r\n        if (asBoo(stack[len(stack) - 1])) {\r\n          i += ins.value;\r\n        } else {\r\n          stack.pop();\r\n        }\r\n        break;\r\n      case \"mat\": {\r\n        const a = stack[len(stack) - 2];\r\n        if (!isEqual(a, stack.pop()!)) {\r\n          i += ins.value;\r\n        } else {\r\n          stack.pop();\r\n        }\r\n        break;\r\n      }\r\n      case \"if\":\r\n        if (!asBoo(stack.pop()!)) {\r\n          i += ins.value;\r\n        }\r\n        break;\r\n      case \"jmp\":\r\n      case \"cat\":\r\n        i += ins.value;\r\n        break;\r\n      case \"loo\":\r\n        i += ins.value;\r\n        --ctx.loopBudget;\r\n        break;\r\n      case \"pop\":\r\n        if (ins.value === 1) {\r\n          stack.pop();\r\n        } else {\r\n          splice(stack, len(stack) - ins.value, ins.value);\r\n        }\r\n        break;\r\n      case \"ret\":\r\n        if (!ins.value) {\r\n          stack.push(_nul());\r\n        }\r\n        i = lim;\r\n        break;\r\n      case \"clo\": {\r\n        //Ensure any in-scope declarations are captured here\r\n        const derefIns = slice(ins.value.derefs).map(ins => {\r\n          const decl =\r\n            ins.typ === \"val\" &&\r\n            ins.value.t === \"str\" &&\r\n            (lets[ins.value.v] ?? ctx.env.vars[ins.value.v]);\r\n          return decl ? <Ins>{ typ: \"val\", value: decl } : ins;\r\n        });\r\n        //Dereference closure captures\r\n        const captures = <Val[]>exeFunc(ctx, { ins: derefIns }, args, true).v;\r\n        //Enclose the closure with dereferenced values\r\n        const cins = slice(func.ins, i + 1, i + 1 + ins.value.length);\r\n        stack.push({ t: \"clo\", v: makeEnclosure(ins.value, cins, captures) });\r\n        i += ins.value.length;\r\n        break;\r\n      }\r\n      default:\r\n        assertUnreachable(ins);\r\n    }\r\n  }\r\n  if (closureDeref) {\r\n    return _vec(stack);\r\n  } else {\r\n    letsStack.pop();\r\n    lets = letsStack[len(letsStack) - 1];\r\n  }\r\n  return stack[len(stack) - 1];\r\n}\r\n\r\nfunction parseAndExe(\r\n  ctx: Ctx,\r\n  code: string,\r\n  invokeId: string,\r\n  params: Val[],\r\n): Val | undefined {\r\n  const parsed = parse(code, invokeId);\r\n  if (len(parsed.errors)) {\r\n    _throw(parsed.errors);\r\n  }\r\n  ctx.env.funcs = { ...ctx.env.funcs, ...parsed.funcs };\r\n  if (!(\"entry\" in ctx.env.funcs)) {\r\n    return;\r\n  }\r\n  return exeFunc(ctx, ctx.env.funcs[\"entry\"], params);\r\n}\r\n\r\nfunction ingestExternalOperations(functions: ExternalFunctions) {\r\n  Object.keys(functions).forEach(name => {\r\n    if (ops[name] && !ops[name].external) {\r\n      throw \"Redefining internal operations is disallowed.\";\r\n    }\r\n    ops[name] = { ...functions[name].definition, external: true };\r\n  });\r\n}\r\n\r\nexport function removeExternalOperations(functionNames: string[]) {\r\n  functionNames.forEach(name => {\r\n    if (ops[name] && !ops[name].external) {\r\n      throw \"Removing internal operations is disallowed.\";\r\n    }\r\n    delete ops[name];\r\n  });\r\n}\r\n\r\nfunction innerInvoke(\r\n  ctx: Ctx,\r\n  closure: () => Val | undefined,\r\n  printResult: boolean,\r\n): InvokeResult {\r\n  const { callBudget, loopBudget, recurBudget, rangeBudget } = ctx;\r\n  ingestExternalOperations(ctx.functions);\r\n  let errors: InvokeError[] = [];\r\n  let value: Val | undefined;\r\n  try {\r\n    value = closure();\r\n  } catch (e) {\r\n    if (!isThrown(e)) {\r\n      throw e;\r\n    }\r\n    errors = e.errors;\r\n  }\r\n  [ctx.callBudget, ctx.recurBudget] = [callBudget, recurBudget];\r\n  [ctx.loopBudget, ctx.rangeBudget] = [loopBudget, rangeBudget];\r\n  delete ctx.env.funcs[\"entry\"];\r\n  letsStack = [];\r\n  if (len(errors)) {\r\n    return { kind: \"errors\", errors };\r\n  }\r\n  if (printResult && value) {\r\n    ctx.print(val2str(value), true);\r\n  }\r\n  return value ? { kind: \"val\", value } : { kind: \"empty\" };\r\n}\r\n\r\n/**\r\n * Parses and executes the given code.\r\n * @param ctx An environment context you retain.\r\n * @param code The code to parse and execute.\r\n * @param invokeId A unique ID referenced in invocation errors.\r\n * @param printResult Automatically print the final value of this invocation?\r\n * @returns Invocation errors caused during execution of the code,\r\n * or the final value of the invocation.\r\n */\r\nexport function invoke(\r\n  ctx: Ctx,\r\n  code: string,\r\n  invokeId: string,\r\n  printResult = false,\r\n  params: Val[] = [],\r\n): InvokeResult {\r\n  return innerInvoke(\r\n    ctx,\r\n    () => parseAndExe(ctx, code, invokeId, params),\r\n    printResult,\r\n  );\r\n}\r\n\r\n/**\r\n * Executes a user-defined Insitux function by name.\r\n * @param ctx An environment context you retain.\r\n * @param funcName The function to execute.\r\n * @param params The parameters to pass to the function.\r\n * @param printResult Automatically print the final value of this invocation?\r\n * @returns Invocation errors caused during execution of the function,\r\n * or the final value of the invocation,\r\n * or undefined if the function was not found.\r\n */\r\nexport function invokeFunction(\r\n  ctx: Ctx,\r\n  funcName: string,\r\n  params: Val[],\r\n  printResult = false,\r\n): InvokeResult | undefined {\r\n  if (!(funcName in ctx.env.funcs)) {\r\n    return;\r\n  }\r\n  return innerInvoke(\r\n    ctx,\r\n    () => exeFunc(ctx, ctx.env.funcs[funcName], params),\r\n    printResult,\r\n  );\r\n}\r\n\r\n/**\r\n * @param env An environment context you retain.\r\n * @param alsoSyntax To optionally include syntax symbols.\r\n * @returns List of symbols defined in Insitux, including built-in operations,\r\n * (optionally) syntax, constants, and user-defined functions.\r\n */\r\nexport function symbols(env: Env, alsoSyntax = true): string[] {\r\n  let syms: string[] = [];\r\n  if (alsoSyntax) {\r\n    push(syms, syntaxes);\r\n  }\r\n  push(syms, [\"args\", \"PI\", \"E\"]);\r\n  syms = concat(syms, objKeys(ops));\r\n  syms = concat(syms, objKeys(env.funcs));\r\n  syms = concat(syms, objKeys(env.vars));\r\n  const hidden = [\"entry\"];\r\n  syms = syms.filter(o => !has(hidden, o));\r\n  return sortBy(syms, (a, b) => (a > b ? 1 : -1));\r\n}\r\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"path\");","import { invoke, invokeFunction } from \".\";\r\nimport { padEnd, slen, starts, substr, trimStart } from \"./poly-fills\";\r\nimport { getTimeMs } from \"./poly-fills\";\r\nimport { Ctx, InvokeResult, Val } from \"./types\";\r\n\r\nexport type InvokeOutput = {\r\n  type: \"message\" | \"error\";\r\n  text: string;\r\n}[];\r\n\r\nconst invocations = new Map<string, string>();\r\nexport const parensRx = /[\\[\\]\\(\\) ,]/;\r\n\r\nexport function invoker(\r\n  ctx: Ctx,\r\n  code: string,\r\n  id?: string,\r\n  printResult = true,\r\n): { output: InvokeOutput; result: InvokeResult } {\r\n  id = id ? `-${id}` : `${getTimeMs()}`;\r\n  invocations.set(id, code);\r\n  const result = invoke(ctx, code, id, printResult);\r\n  return { output: invokeResultToOutput(result), result };\r\n}\r\n\r\nexport function functionInvoker(\r\n  ctx: Ctx,\r\n  name: string,\r\n  params: Val[],\r\n  printResult = true,\r\n): { output: InvokeOutput; result?: InvokeResult } {\r\n  const result = invokeFunction(ctx, name, params, printResult);\r\n  if (!result) {\r\n    const message = <InvokeOutput[0]>{\r\n      type: \"message\",\r\n      text: `Invoke Error: function '${name}' not found.`,\r\n    };\r\n    return { output: [message] };\r\n  }\r\n  return { output: invokeResultToOutput(result), result };\r\n}\r\n\r\nfunction invokeResultToOutput(result: InvokeResult) {\r\n  if (result.kind !== \"errors\") {\r\n    return [];\r\n  }\r\n  let out: InvokeOutput = [];\r\n  const msg = (text: string) => out.push({ type: \"message\", text });\r\n  const err = (text: string) => out.push({ type: \"error\", text });\r\n  result.errors.forEach(({ e, m, errCtx: { line, col, invokeId } }) => {\r\n    const invocation = invocations.get(invokeId);\r\n    if (!invocation) {\r\n      msg(`${e} Error: ${invokeId} line ${line} col ${col}: ${m}\\n`);\r\n      return;\r\n    }\r\n    const lineText = invocation.split(\"\\n\")[line - 1];\r\n    const sym = substr(lineText, col - 1).split(parensRx)[0];\r\n    const half1 = trimStart(substr(lineText, 0, col - 1));\r\n    const path = starts(invokeId, \"-\") ? `In ${substr(invokeId, 1)}\\n` : \"\";\r\n    msg(`\\n${padEnd(`${line}`, 4)} ${half1}`);\r\n    if (!sym) {\r\n      const half2 = substr(lineText, col);\r\n      err(lineText[col - 1]);\r\n      msg(`${half2}\\n`);\r\n    } else {\r\n      const half2 = substr(lineText, col - 1 + slen(sym));\r\n      err(sym);\r\n      msg(`${half2}\\n`);\r\n    }\r\n    msg(`${e} Error: ${m}.\\n${path}`);\r\n  });\r\n  return out;\r\n}\r\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"process\");","import readline = require(\"readline\");\r\nimport { appendFileSync, readFileSync, rmSync, writeFileSync } from \"fs\";\r\nimport { unlinkSync, existsSync, mkdirSync } from \"fs\";\r\nimport { insituxVersion, symbols } from \".\";\r\nimport { join as pathJoin, dirname } from \"path\";\r\nimport { Ctx, defaultCtx, ExternalFunctions, Val, ValOrErr } from \"./types\";\r\nimport { Operation } from \"./types\";\r\nimport { InvokeOutput, invoker, parensRx } from \"./invoker\";\r\nimport { tokenise } from \"./parse\";\r\nimport prompt = require(\"prompt-sync\");\r\nimport { exit } from \"process\";\r\nimport { str, _nul, _str, _vec } from \"./val\";\r\nimport fetch from \"cross-fetch\";\r\nimport clone = require(\"git-clone/promise\");\r\n\r\nconst _val = (value: Val) => <ValOrErr>{ kind: \"val\", value };\r\nconst githubRegex = /^(?!https*:)[^\\/]+?\\/[^\\/]+$/;\r\nlet colourMode = true;\r\n\r\n//#region External operations\r\nfunction read(path: string, asLines: boolean) {\r\n  if (!existsSync(path)) {\r\n    return _val(_nul());\r\n  }\r\n  const content = readFileSync(path).toString();\r\n  return <ValOrErr>{\r\n    kind: \"val\",\r\n    value: asLines ? _vec(content.split(/\\r?\\n/).map(_str)) : _str(content),\r\n  };\r\n}\r\n\r\nfunction writeOrAppend(path: string, content: string, isAppend = false) {\r\n  (isAppend ? appendFileSync : writeFileSync)(path, content);\r\n  return _val(_nul());\r\n}\r\n\r\nconst writingOpDef: Operation = {\r\n  exactArity: 2,\r\n  params: [\"str\", \"str\"],\r\n  returns: [\"str\"],\r\n};\r\n\r\nfunction makeFunctions(workingDirectory = process.cwd()) {\r\n  return <ExternalFunctions>{\r\n    read: {\r\n      definition: { exactArity: 1, params: [\"str\"], returns: [\"str\"] },\r\n      handler: ([path]) => read(str(path), false),\r\n    },\r\n    \"read-lines\": {\r\n      definition: { exactArity: 1, params: [\"str\"], returns: [\"vec\"] },\r\n      handler: ([path]) => read(str(path), true),\r\n    },\r\n    write: {\r\n      definition: writingOpDef,\r\n      handler: ([path, content]) => writeOrAppend(str(path), str(content)),\r\n    },\r\n    \"file-append\": {\r\n      definition: writingOpDef,\r\n      handler: params =>\r\n        writeOrAppend(<string>params[0].v, <string>params[1].v, true),\r\n    },\r\n    prompt: {\r\n      definition: {\r\n        exactArity: 1,\r\n        params: [\"str\"],\r\n        returns: [\"str\"],\r\n      },\r\n      handler: params => ({\r\n        kind: \"val\",\r\n        value: { t: \"str\", v: prompt()(<string>params[0].v) },\r\n      }),\r\n    },\r\n    import: {\r\n      definition: {\r\n        exactArity: 1,\r\n        params: [\"str\"],\r\n      },\r\n      handler: params => {\r\n        const p0 = str(params[0]);\r\n        const isGithub = githubRegex.test(p0);\r\n        const isAliased = !p0.endsWith(\".ix\");\r\n        const path = pathJoin(\r\n          workingDirectory,\r\n          isGithub ? `.ix/${p0}/entry.ix` : isAliased ? `.ix/${p0}.ix` : p0,\r\n        );\r\n        //Error due to missing dependency\r\n        if (!existsSync(path)) {\r\n          return { kind: \"err\", err: `not found: ${path}` };\r\n        }\r\n        //Execute and return\r\n        const code = readFileSync(path).toString();\r\n        const oldFuncs = ctx.functions;\r\n        ctx.functions = makeFunctions(dirname(path));\r\n        const { result, output } = invoker(ctx, code, path, false);\r\n        ctx.functions = oldFuncs;\r\n        if (result.kind === \"errors\") {\r\n          printErrorOutput({ output });\r\n          return { kind: \"err\", err: `errors in importing ${path}` };\r\n        }\r\n        return {\r\n          kind: \"val\",\r\n          value: result.kind === \"val\" ? result.value : _nul(),\r\n        };\r\n      },\r\n    },\r\n  };\r\n}\r\n//#endregion\r\n\r\n//#region Context\r\nconst env = new Map<string, Val>();\r\n\r\nfunction get(key: string): ValOrErr {\r\n  return env.has(key)\r\n    ? { kind: \"val\", value: env.get(key)! }\r\n    : { kind: \"err\", err: `key ${key} not found` };\r\n}\r\n\r\nfunction set(key: string, val: Val) {\r\n  env.set(key, val);\r\n  return undefined;\r\n}\r\n\r\nconst ctx: Ctx = {\r\n  ...defaultCtx,\r\n  get,\r\n  set,\r\n  functions: makeFunctions(),\r\n  print(str, withNewLine) {\r\n    process.stdout.write(`\\x1b[32m${str}\\x1b[0m${withNewLine ? \"\\n\" : \"\"}`);\r\n  },\r\n  exe,\r\n};\r\n\r\nfunction exe(name: string, args: Val[]): ValOrErr {\r\n  if (args.length) {\r\n    const a = args[0];\r\n    if (a.t === \"str\" && a.v.startsWith(\"$\")) {\r\n      if (args.length === 1) {\r\n        return get(`${a.v.substring(1)}.${name}`);\r\n      } else {\r\n        set(`${a.v.substring(1)}.${name}`, args[1]);\r\n        return _val(args[1]);\r\n      }\r\n    }\r\n  }\r\n  return { kind: \"err\", err: `operation \"${name}\" does not exist` };\r\n}\r\n//#endregion\r\n\r\n//#region REPL IO\r\n\r\nfunction printErrorAndExit(message: string) {\r\n  printErrorOutput({ output: [{ type: \"error\", text: message + \"\\n\" }] });\r\n  exit();\r\n}\r\n\r\ntype DependencyResolution =\r\n  | { kind: \"http install\"; url: string; alias: string }\r\n  | { kind: \"Github install\"; repo: string }\r\n  | { kind: \"alias remove\"; alias: string }\r\n  | { kind: \"Github remove\"; repo: string };\r\n\r\n/** Checks a dependency is or isn't present, and downloads if necessary. */\r\nasync function dependencyResolve(dependency: DependencyResolution) {\r\n  mkdirSync(\".ix\", { recursive: true });\r\n  try {\r\n    if (dependency.kind === \"http install\") {\r\n      const response = await fetch(dependency.url);\r\n      if (!response.ok) {\r\n        throw `${response.status}: ${response.statusText}: ${dependency.url}`;\r\n      }\r\n      const text = await response.text();\r\n      writeFileSync(`.ix/${dependency.alias}.ix`, text);\r\n    } else if (dependency.kind === \"alias remove\") {\r\n      unlinkSync(`.ix/${dependency.alias}.ix`);\r\n    } else if (\r\n      dependency.kind === \"Github install\" ||\r\n      dependency.kind === \"Github remove\"\r\n    ) {\r\n      const path = `.ix/${dependency.repo}`;\r\n      if (existsSync(path)) {\r\n        rmSync(`.ix/${dependency.repo.split(\"/\")[0]}`, {\r\n          recursive: true,\r\n          force: true,\r\n        });\r\n      }\r\n      if (dependency.kind === \"Github install\") {\r\n        await clone(`https://github.com/${dependency.repo}.git`, path, {\r\n          shallow: true,\r\n        });\r\n      }\r\n    }\r\n  } catch (err) {\r\n    const message =\r\n      typeof err === \"object\" && err && \"message\" in err\r\n        ? (err as { message: string })[\"message\"]\r\n        : `${err}`;\r\n    printErrorAndExit(message);\r\n  }\r\n  console.log(`${dependency.kind} succeeded.`);\r\n}\r\n\r\nasync function depsFileAction(action: \"install\" | \"remove\") {\r\n  const path = \"deps.txt\";\r\n  if (!existsSync(path)) {\r\n    console.log(`${path} not found.`);\r\n    return;\r\n  }\r\n  const deps = readFileSync(path)\r\n    .toString()\r\n    .split(\"\\n\")\r\n    .map(x => x.trim())\r\n    .filter(x => x);\r\n  if (!deps.length) {\r\n    console.log(`${path} is empty.`);\r\n    return;\r\n  }\r\n  for (const dep of deps) {\r\n    await processCliArguments([action[0], ...dep.trim().split(\" \")]);\r\n  }\r\n}\r\n\r\nfunction exitIfBadAlias(alias: string) {\r\n  const aliasValidator = /^[\\w-]+$/;\r\n  if (!aliasValidator.test(alias)) {\r\n    console.log(`Ensure alias matches regular expression: ${aliasValidator}`);\r\n    exit();\r\n  }\r\n}\r\n\r\nconst helpText = `Insitux ${insituxVersion} REPL\r\n$ ix help           #or -h, to show this help\r\n$ ix                #open a REPL session (exit with Ctrl+D or Ctrl+C)\r\n$ ix .              #execute entry.ix in the working directory\r\n$ ix . -r           # then open a REPL session\r\n$ ix file.ix        #execute file.ix in the working directory\r\n$ ix file.ix -r     # then open a REPL session\r\n\r\n$ ix i              #installs dependencies listed in deps.txt\r\n$ ix r              #remove dependencies listed in deps\r\n$ ix i user/repo    #clone Github repository into the .ix directory\r\n$ ix r user/repo    #delete Github repository from the .ix directory\r\n$ ix i alias http  #download file via HTTP into the .ix directory as alias.ix\r\n$ ix r alias        #remove file downloaded earlier over HTTP by alias\r\n\r\nIf you have Visual Studio Code, install the syntax highlighter!\r\n$ code --install-extension insitux.insitux-syntax`;\r\n\r\nasync function processCliArguments(args: string[]) {\r\n  if (!args.length) {\r\n    startRepl();\r\n    return;\r\n  }\r\n\r\n  colourMode = false;\r\n\r\n  const openReplAfter = args.includes(\"-r\");\r\n  const parts = openReplAfter ? args.filter(a => a !== \"-r\") : args;\r\n\r\n  const matchParts = (b: RegExp[]) =>\r\n    parts.length === b.length &&\r\n    parts.every((part, i) => b[i] && b[i].test(part));\r\n\r\n  const [arg0, arg1, arg2] = parts;\r\n  if ([\"help\", \"-h\"].includes(arg0)) {\r\n    console.log(helpText);\r\n    exit();\r\n  } else if (matchParts([/^\\.$/])) {\r\n    //Execute entry.ix in working directory\r\n    const path = \"entry.ix\";\r\n    if (!existsSync(path)) {\r\n      console.log(\"entry.ix does not exist in this directory.\");\r\n    } else {\r\n      const code = readFileSync(path).toString();\r\n      printErrorOutput(invoker(ctx, code, path));\r\n    }\r\n  } else if (matchParts([/^i$/, githubRegex])) {\r\n    //Install dependency via Github\r\n    await dependencyResolve({ kind: \"Github install\", repo: arg1 });\r\n  } else if (matchParts([/^i$/, /.+/, /https*:/])) {\r\n    //Install dependency via HTTP\r\n    exitIfBadAlias(arg1);\r\n    await dependencyResolve({ kind: \"http install\", url: arg2, alias: arg1 });\r\n  } else if (arg0 === \"i\") {\r\n    await depsFileAction(\"install\");\r\n    exit();\r\n  } else if (matchParts([/^r$/, githubRegex])) {\r\n    //Remove Github dependency\r\n    await dependencyResolve({ kind: \"Github remove\", repo: arg1 });\r\n  } else if (matchParts([/^r$/, /.+/])) {\r\n    //Remove aliased dependency\r\n    exitIfBadAlias(arg1);\r\n    await dependencyResolve({ kind: \"alias remove\", alias: arg1 });\r\n  } else if (arg0 === \"r\") {\r\n    await depsFileAction(\"install\");\r\n    exit();\r\n  } else {\r\n    //Execute files\r\n    for (const path of parts) {\r\n      if (!existsSync(path)) {\r\n        console.log(`${path} not found - ignored.`);\r\n      } else {\r\n        const code = readFileSync(path).toString();\r\n        printErrorOutput(invoker(ctx, code, path));\r\n      }\r\n    }\r\n  }\r\n\r\n  if (openReplAfter) {\r\n    colourMode = true;\r\n    startRepl();\r\n  }\r\n}\r\n\r\nfunction startRepl() {\r\n  printErrorOutput(invoker(ctx, `(str \"Insitux \" (version) \" REPL\")`));\r\n\r\n  if (existsSync(\".repl.ix\")) {\r\n    printErrorOutput(invoker(ctx, readFileSync(\".repl.ix\").toString()));\r\n  }\r\n\r\n  const rl = readline.createInterface({\r\n    input: process.stdin,\r\n    output: process.stdout,\r\n    prompt: \" \",\r\n    completer,\r\n    history: existsSync(\".repl-history.txt\")\r\n      ? readFileSync(\".repl-history.txt\").toString().split(\"\\n\").reverse()\r\n      : [],\r\n  });\r\n\r\n  rl.on(\"line\", line => {\r\n    lines.push(line);\r\n    const input = lines.join(\"\\n\");\r\n    if (haveFinishedEntry(input)) {\r\n      if (lines.length === 1) {\r\n        appendFileSync(\".repl-history.txt\", `\\n${input}`);\r\n      }\r\n      lines = [];\r\n      if (input === \"quit\") {\r\n        rl.close();\r\n        return;\r\n      }\r\n      if (input.trim()) {\r\n        printErrorOutput(invoker(ctx, input));\r\n      }\r\n      rl.setPrompt(\" \");\r\n    } else {\r\n      rl.setPrompt(\" \");\r\n    }\r\n    rl.prompt();\r\n  });\r\n\r\n  rl.on(\"close\", () => {\r\n    console.log();\r\n  });\r\n\r\n  rl.prompt();\r\n}\r\n\r\nprocessCliArguments(process.argv.slice(2));\r\n\r\nfunction completer(line: string) {\r\n  const input = line.split(parensRx).pop();\r\n  const completions = symbols(ctx.env);\r\n  if (!input) {\r\n    return [completions, \"\"];\r\n  }\r\n  const hits = completions.filter(c => c.startsWith(input));\r\n  return [hits.length ? hits : completions, input];\r\n}\r\n\r\nlet lines: string[] = [];\r\n\r\nfunction haveFinishedEntry(code: string): boolean {\r\n  const { tokens } = tokenise(code, \"\");\r\n  const numL = tokens.filter(t => t.typ === \"(\").length;\r\n  const numR = tokens.filter(t => t.typ === \")\").length;\r\n  return numL <= numR;\r\n}\r\n\r\nfunction printErrorOutput({ output: lines }: { output: InvokeOutput }) {\r\n  const colours = { error: 31, message: 35 };\r\n  lines.forEach(({ type, text }) => {\r\n    if (colourMode) {\r\n      process.stdout.write(`\\x1b[${colours[type]}m${text}\\x1b[0m`);\r\n    } else {\r\n      process.stdout.write(text);\r\n    }\r\n  });\r\n}\r\n//#endregion\r\n"],"names":[],"sourceRoot":""}